<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js新特性]]></title>
    <url>%2F2021%2F07%2F02%2Fjs%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1. PromiseMDN文档 我们首先定义一个promise方法 1234567891011function setName(newName) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if(newName === 'jack')&#123; resolve(newName) &#125;else&#123; reject(`【$&#123;newName&#125;】 is not a good name, sorry.`) &#125; &#125;, 1000) &#125;)&#125; 第一次调用，给到参数为“Tom”，promise异常对调，进入reject回调中，在catch中接收回调。 123456setName('Tom').then(res =&gt; &#123; console.log(`我的名字是【$&#123;res&#125;】`)&#125;).catch(err =&gt; &#123; console.log(err)&#125;)// console:【Tom】 is not a good name, sorry. 第二次调用，给到参数为“jack”，promise正常对调，进入resolve回调中，在then中接收回调。 123456setName('jack').then(res =&gt; &#123; console.log(`我的名字是【$&#123;res&#125;】`)&#125;).catch(err =&gt; &#123; console.log(err)&#125;)// console: 我的名字是【jack】 2. async/awaitMDN文档 async函数是使用async关键字声明的函数。 async函数是AsyncFunction构造函数的实例， 并且其中允许使用await关键字。async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。 任意一个名称都是有意义的，先从字面意思来理解。async是“异步”的简写，而 await可以认为是 async wait 的简写。所以应该很好理解 async用于申明一个 function 是异步的，而 await用于等待一个异步方法执行完成。 await只能出现在 async函数中 我们还是以上面的例子做一个演示： 还是定义一个promise方法 1234567891011function setName(newName) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if(newName === 'jack')&#123; resolve(newName) &#125;else&#123; reject(`【$&#123;newName&#125;】 is not a good name, sorry.`) &#125; &#125;, 1000) &#125;)&#125; 我们再定义一个带有async的方法，在该方法中调用setName(&#39;jack&#39;)，结果按照我们预料到的一样运行。 123456async function getName() &#123; var name = await setName('jack') console.log(`我的名字是【$&#123;name&#125;】`)&#125;getName()// console: 我的名字是【jack】 第二次调用，我们将setName(&#39;tom&#39;)的参数换成&#39;tom&#39;。 123456async function getName() &#123; var name = await setName('tom') console.log(`我的名字是【$&#123;name&#125;】`)&#125;getName()// console: Uncaught (in promise) 【tom】 is not a good name, sorry. 我们发现，控制台报错了。原因是在第二次调用时，我们给的参数是&#39;tom&#39;, 这让 promise函数进入了reject回调中。 但问题是，我们已经在reject回调中做了异常的处理，为什么还会在控制台上报错呢。 其实我们需要在async函数中使用try-catch来捕获异常，如下： 12345678910async function getName() &#123; try &#123; var name = await setName('tom') console.log(`我的名字是【$&#123;name&#125;】`) &#125; catch (err) &#123; console.log(err) &#125;&#125;getName()// console: 【tom】 is not a good name, sorry. 我们在try中执行正常回调的代码，如果有异常发生，则在catch中捕获异常，做异常处理。 3. 展开操作符展开操作符可用于对象或数组，示例： 对象:123456789var tom = &#123; age: 20,&#125;var jack = &#123; name: 'jack', ...tom&#125;console.log(jack)// console: &#123;name: "jack", age: 20&#125; 如果两个对象中有重复的key值，结果是如何呢？ 12345678910var tom = &#123; age: 20,&#125;var jack = &#123; name: 'jack', age: 18, ...tom,&#125;console.log(jack)// console: &#123;name: "jack", age: 20&#125; 12345678910var tom = &#123; age: 20,&#125;var jack = &#123; ...tom, name: 'jack', age: 18,&#125;console.log(jack)// console: &#123;age: 18, name: "jack"&#125; 从上面的例子中可以看到，后面的key值会覆盖前面的key值。 数组:1234var arr = [1,2,3,4,5]var arr1 = [...arr, 6,7,8]console.log(arr1)// console: [1, 2, 3, 4, 5, 6, 7, 8] 4. 剩余参数123456function sum(a, b, ...c) &#123; return a + b + c.reduce((total, num) =&gt; total + num )&#125;let num = sum(1, 2, 3, 4, 5)console.log(num)// console: 15 如上所示，参数c是由剩余参数组成的一个数组。 5. 字符串插值常用在拼接字符串时。使用${}将数据包裹，使用`来包裹整个字符串。 12345const name = 'jack'const age = 20var userInfo = `名字:$&#123;name&#125;, 年龄:$&#123;age&#125;`console.log(userInfo)// console: 名字:jack, 年龄:20 6. 简写属性这是原本的写法12345678const name = 'jack'const age = 20var userInfo = &#123; name: name, age: age&#125;console.log(userInfo)// console: &#123;name: "jack", age: 20&#125; 简写：12345678const name = 'jack'const age = 20var userInfo = &#123; name, age&#125;console.log(userInfo)// console: &#123;name: "jack", age: 20&#125; 7. 解构赋值对象123456789101112131415161718var userInfo = &#123; name: 'jack', age: 20, school: &#123; schoolName: 'demo school', grade: 'First grade 6 class' &#125;&#125;let &#123; name, age, school: &#123; schoolName, grade &#125; &#125; = userInfoconsole.log(name)// console: jackconsole.log(age)// console: 20console.log(schoolName)// console: demo schoolconsole.log(grade)// console: First grade 6 class 在需要获取嵌套的对象数据时，可以这样获取：let { school: { schoolName, grade } } = userInfo 数组12345678const arr = [1, 2, 3, 4, 5]let [a, b, ...c] = arrconsole.log(a)// console: 1console.log(b)// console: 1console.log(c)// console: [3, 4, 5] 如果我们想间隔取值，可以使用, ,来获取。也可以使用上面说到的【剩余参数】来获取剩余的数组。 注意：此处的剩余参数需写到最后。 结语：以上几个特性，是我在开发过程中时常会用到的，每个新特性在使用中都会给予我巨大的快乐。不论是写法得简便，还是逻辑得清晰。都让我的开发效率得到了巨大的提升。所以，用起来吧！✊✊✊]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steam账号被盗，导致PUBG账号被封找回全过程]]></title>
    <url>%2F2020%2F08%2F13%2Fsteam%E8%B4%A6%E5%8F%B7%E8%A2%AB%E7%9B%97%EF%BC%8C%E5%AF%BC%E8%87%B4PUBG%E8%B4%A6%E5%8F%B7%E8%A2%AB%E5%B0%81%E6%89%BE%E5%9B%9E%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 我的问题先简单描述一下我遇到的问题： steam账号被盗，由于没有及时发现，导致其中的PUBG，也就是吃鸡游戏被官方封禁。 我的steam账号在2019年年底其实就被盗了，但是由于工作很忙，一直想不起来要去找回账号，于是就拖到了现在。 我在steam上买过两款游戏，一个是《GTA5》当时买的时候打折，￥76入手的。另一个就是《PUBG》了，￥98买入。 我也是找回steam账号，重新登录之后才发现《PUBG》被封了。 废话说完，下面开始介绍找回两个账号的历程。 2. 找回steam账号我们先来找回steam账号。 操作完以上截图的过程后，会建立一个steam客服案件。steam会根据你所描述的问题给予相应的帮助。客服的反应还是很快的，当天就回了邮件。邮件当中有一个连接，点击之后就会跳转到浏览器上并打开该客服案件的详情。你需要按照客服所要求的提供相应的证明。如：购买游戏的付款记录等。以下是我给客服上传支付证明的截图。 此处需要注意一下，由于我当时买游戏时用的是支付宝进行的支付，所以消费证明也是在支付宝（浏览器端）里查到的，样子长这样： 把你购买过的游戏的所有购买记录截图后上传，就可以了。我在找消费记录的时候确实废了挺多时间，凭着模糊的印象，记着大概是在2017年下半年买的游戏，一条记录一条记录的看。不过可以确定的是，只要你消费过，肯定是有消费记录的，慢慢找，总能找到。 至此，steam账号算是找回来了。steam官方还会发一封重置密码的邮件让你重新登录，长下面这样： 如果你经历了上面的过程，并成功登录了你的steam账号，你需要马上修改原始密码，并把所有可以做的安全措施做到完备。如：steam手机令牌 令牌的获取需要你在手机上下载steam客户端，并开启令牌。在这期间你需要游戏加速器对steam进行加速，不然没法操作。我是下载了一个【UU加速器】的手机版，可以免费加速steam，比较方便地打开了steam令牌。如果打开令牌，无论你在任何地方，使用任何机器登录你的steam账号，都需要输入一段令牌密码，该令牌密码只能从你的手机上的steamApp中获取，并且它还会一直刷新。但是它并不需要你一直使用游戏加速器。 令牌不仅可以大大提升你steam账号的安全性，主要是在下面找回《PUBG》账号的时候有大的作用。 3. 找回PUBG账号经历了以上找回steam的过程，并且成功地重新登录上了steam，但是不幸的是，你的《PUBG》账号被封了。被封的原因很有可能是因为你的steam账号在被盗期间，租用给了其他玩家，这些玩家不用为了账号的安全负责，所以开挂开的肆无忌惮，也就导致了账号被封。 不过不用担心，PUBG官方还是很开明的。只要你提供PUBG被封确实不是自己所导致的就可以完成解封。以下为我的解封过程。 第一步先去PUBG官网，找到官方客服，进行案件的申请 ，官网链接点这里 我在第一次申请时，提供了以下信息： steamID steam账号名称 购买游戏的凭证（在steam中进行查找并截图） 配合steam客服找回steam账号的邮件截图，以证明账号确实被盗取 购买《PUBG》游戏的支付宝交易记录截图 第二步申请发送后，PUBG官方客服会回复邮件，我是大概在3天后收到的回复邮件，邮件如下： 邮件的内容大体是让我们再继续提供一些证据，如下： steam账号绑定【steam令牌手机验证器】，也就是我上面所讲的。绑定之后就可以在steam中找到并截图 steamID，可以在个人资料界面的URL中找到。在steam中，如果没有打开游戏加速器，就打不开页面。我还是在电脑上下载了一个【UU加速器】，对steam进行加速后即可打开个人资料页面获取steamID。 我们只要按照他所说的继续提供相应的截图就可以了。如下： 第三步做完以上步骤，需要做的就是等待。等待官方客服做最后的验证。我大概等了1周多几天，收到了PUBG账号恢复的邮件： 如果你也收到了这封邮件，就证明你的账号恢复了，接下来就麻溜地上号，开始你的吃鸡生涯吧！！！ End&nbsp;感谢您阅读到此本文版权归作者所有，欢迎转载转载必须在醒目位置标明作者与出处欢迎浏览我之前的文章： 注意！MELDE自行车骗局 ES6中新增的处理字符串的方法 JS中14个数组的高级操作 我被第一次喊【双手抱头！！！】 理财知识]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>steam账号被盗</tag>
        <tag>PUBG账号被封</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汽车保养记录]]></title>
    <url>%2F2020%2F07%2F22%2F%E6%B1%BD%E8%BD%A6%E4%BF%9D%E5%85%BB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[速腾1.4TSI(理论上) 里程 机油 机滤 空气滤芯 燃油滤芯 空调滤芯 刹车油 变速箱油 防冻液 火花塞 价格 5000 ◉ ◉ 每2年更换 免费 10000 ◉ ◉ 545 20000 ◉ ◉ ◉ ◉ 1065 30000 ◉ ◉ ◉ ◉ 790 40000 ◉ ◉ ◉ ◉ 1065 50000 ◉ ◉ 545 60000 ◉ ◉ ◉ ◉ ◉ ◉ ◉ 2150 速腾1.4TSI(实际上) 里程 机油 机滤 空气滤 燃油滤 空调滤 刹车油 变速箱油 防冻液 火花塞 积碳清洗 三元催化清洗 喷油嘴清洗 节气门清洗 价格 5000 ◉ ◉ 免费 10000 ◉ ◉ 暂无 20000 ◉ ◉ ◉ ◉ ◉ 473 30000 ◉ ◉ ◉ ◉ ◉ 893 40000 ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ ◉ 1248 🚗【保养】2021-01-15 途虎（太榆路店）（40461公里） 机油 机滤 空气滤 燃油滤 空调滤 积碳清洗 三元催化清洗 喷油嘴清洗 型号 壳牌/超凡喜力/52-40 SP A3/B4 4L 价格 服务费 备注 🚓【维修】2020-12-15 途虎 （太榆路店）（38773公里） 更换轮胎（前轮 2条） 型号：韩泰 万途仕 K117 225/45R17 91W 价格：478 * 2 = 956 免安装费 / 赠送铝合金气门嘴 / 赠送1年轮胎险 轮胎险：众安在线财产保险股份有限公司承保 保险凭证号：821340106561454890,821340106561454891 本次保养总计花费：956 🚗【保养】2020-07-22 途虎（太榆路店）（30196公里） 机油 【壳牌/Shell】【喜力】【灰壳】【全合成】【5W-40】【SN】 价格：299 机滤 【欧菲/UFI】【20微米过滤】 价格： 35 人工费：39（安装机滤 + 机油） 火花塞 【NGK】【双铂金】【PKER7A8EGS】 商品价格： 79 * 4 = 316 人工费：15 * 4 = 60 以上为途虎App下单，满499减150 原价：749 实付：749 - 150 = 599 空气滤 【冠军】【CU410-03】 价格：42 刹车油 【博世】【德国进口】【ENV6】【1L】 价格：198 人工费 ： 原价：109 实付：54（5折） 以上为在店内检查后，需额外更换的。 实付：294 本次保养总计花费：893 🚗【保养】2019-12-20 途虎 （迎泽西大街店）（20267公里） 机油 【壳牌/Shell】【喜力】【灰壳】【全合成】【5W-40】【SN】 价格：299 机滤 【冠军】【CM107-03】 价格： 19 人工费：39（安装机滤 + 机油） 原价：357 优惠：78 实付：278 以上均在途虎App下单购买 空气滤清器 【马勒】【LX3807】 价格：40 燃油滤清器 【马勒】【KL759】 价格：89 空调滤清器 【马勒】【LAK621】 价格：65 以上项目为到店检测后新增的项目，全部免除人工费 实付：194 本次保养总计花费：473]]></content>
      <categories>
        <category>汽车保养</category>
      </categories>
      <tags>
        <tag>汽车保养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注意！MELDA山地自行车骗局]]></title>
    <url>%2F2019%2F10%2F22%2FMELDA%E5%B1%B1%E5%9C%B0%E8%87%AA%E8%A1%8C%E8%BD%A6%E9%AA%97%E5%B1%80%2F</url>
    <content type="text"><![CDATA[注：以下叙述是我的亲身经历，如有雷同，望赶紧擦亮自己的双眼，避免再次上当！ 01上个周日，早上11点多。我上街买菜准备做午饭，顺路去菜鸟驿站取快递。 刚在菜市场买完菜准备走到菜鸟驿站，有个大概35-40岁的中年男人走上前来，问我要不要山地自行车，普通话还算正宗，所以听不出是哪里的人。 这个人介绍自己是跑物流的，刚刚拉了一单山地车，由于在装货的时候多装了一辆自行车，所以想要自己把这台山地车卖掉，挣点外快。还向我展示了收据，证明该车价值1980。 我起初并没有想买的心思，只是想看看是辆什么样的山地车。（好奇心作祟）😐 这个人带着我七拐八拐走到一个路边，墙角上靠着一辆被塑料袋和纸片包着的自行车，车把和前轮都没安上。看样子是新出厂的车子，并不是“赃物”。这让我有了进一步了解的想法。 这个人继续向我推销，说这台车是“美利达”牌的，出厂价1980元，由于是多出来的，想自己便宜出掉，挣点烟钱。 02我之前也算是很喜欢山地车，所以认识“美利达”这个品牌，但是我并不是十分了解。只是看到自行车车架上有”MELDA”的字样，稍微有点英语常识的人可以拼一下，确实是“美利达”。事情发展到此，我对这辆车的好奇心进一步加深。 然后我问了他价格，但是他并没有正面回答，只是反问我能给多少。我随口一说300，他满脸的不屑。说是怎么还不给我折一半的价钱啊。我心里也有小九九：这车看起来还可以，但是我并不想花太多钱买它。还是贪小便宜的心态。 随后就是讨价还价的戏码。不得不说，他还是很“痛快”的。我于是动心了，最后以300块成交。我微信转账给他，他转身就走了。 成交之后，我还是丝毫没有发现任何不对的情况，自己满心欢喜地以为捡了个“便宜”，累哼哼地拎着车子取了快递，又回了家。 03回家之后，迫不及待地打开包装，自己开始组装。 不得不说，这个山地车山寨得没那么明显，或者也可以说我自己傻的不那么彻底，我完全没有认识到自己已经上当受骗。甚至还很享受自己动手组装车子所带来的成就感。 等我自己已经装好车把和车座时，我才想到要上网搜一搜这个“MELDA”，一搜自己就傻眼了，网上都是网友们痛斥骗子的话语。 如下： 这下我才反应过来，自己掉进了坑里，然后还喜滋滋，满心欢喜地以为自己捡了便宜。嗯~ 蠢得很彻底！😧😧😧 04我们回过头来看整个骗局： 该骗子一开始在路边“招揽顾客”，只要跟上他去看车子的，都是像我一样，要么有买山地车需要的，要么特别喜爱山地车，但是都有一个最重要的特征：想要占点小便宜。 在看到自行车后，他会强调这个车子是怎么怎么好，出厂价是怎么怎么高，只是由于多出来一辆，所以想要低价出手，挣点外快。只要不是一眼就看出来这辆车子是山寨货的人都会被吸引，接下来就会问价格。 在谈价格的时候，骗子自己不会要价，会让你给出价格，不论你给出多少，他们都会嫌低。 反正只要不低于100块钱，他们都是不亏的。只要你有一丝丝不想买的意向，他们会立马同意你的要价，并且会不断地强调自己怎么怎么亏了，你占了怎么怎么大的便宜。 最后，你满以为自己捡了个大便宜，兴冲冲地将车子拎回家，不料这车子是做工粗糙、配件尺寸都不对、成本价也许只有100块的山寨货。 05我随后在【某鱼】上搜了一下“MELDA”，竟然搜出来好几个闲置的“MELDA”山地车。 我不太清楚这些山地车是从哪里来的，但我猜测，应该有一部分人都是像我一样贪小便宜，买了山寨货“MELDA”之后，发现这辆车根本不像自己买的时候骗子说的那么好，甚至都不能骑。所以才挂上去想补回一点损失。 其实我一开始也有类似的想法，但是想到这里，又有点于心不忍了。这和自己收到假币，再转而将假币花出去的做法有何不同。 劝你善良~ 🙏🙏🙏 后期的话，我打算先动手把车子组装一下，如果可以骑，就当个代步工具吧，以后买个菜取个快递可以骑上。（实在不敢骑长途）如果实在组装不上，就扔到地下室吧，引以为戒！！！ 其实，这个山寨车山寨得很明显，通过对比正牌的“美利达”和山寨的“MELDA”，一眼就能分辨出来。 正牌”美利达”的英文拼写是：MERIDA，山寨版的是：MELDA。如下图所示： 正牌美利达： 山寨“MELDA”： 总结可以通过网上的帖子看出来，这伙人已经猖狂了很久。最早的帖子有17年的，被骗的人遍布河北、天津、山西甚至首都北京。 网上的大部分言论都表明该骗子一般穿一身德邦快递或者顺丰快递的工作服，有的甚至开着德邦和顺丰的运输车。车子的来源都说的是出货时多拉了一辆，想自己卖了挣外快。 他们甚至同意买车子的人用手机拍下他自己身份证的照片，更有甚者会起誓说骗人死全家。 不得不说，现在骗子的功夫越来越高。我是95后，平常也喜欢看一些法制频道的新闻和案例，自以为练出了可以识别这些骗局的火眼金睛。殊不知，只要自己稍微有一点贪小便宜的心思，立马会被骗子抓住加以利用。 我把我的经历写下来并分享出去，只是想让更多的人知道这个骗局，引以为戒！以后路上碰到任何向你推销东西的人，敬而远之。 切莫贪便宜，贪小便宜吃大亏。]]></content>
      <categories>
        <category>我的故事</category>
      </categories>
      <tags>
        <tag>骗局</tag>
        <tag>MELDA自行车骗局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析前后端分离]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%B5%85%E6%9E%90%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[前后端分离这个说法其实在数年前就已经出现，但是直到现在还有很多人对其存在误解，误认为前后端分离就是在Web项目的开发过程中，做到前后端分别开发的一种模式。实则不然，前后端分离其实是一种架构模式，它不仅体现在开发过程中对前后端进行了分离，更在应用部署、后续维护等阶段都分别执行分离的操作。 下面我们就前后端分离做一个简单的分析和总结，我会就3个方面对其进行说明：为何要进行前后端分离、前后端分离的好处以及如何进行前后端分离。 1. 为何要进行前后端分离开发效率低下 我们先简单描述一下在前后端分离出现之前，一个javaWeb项目是如何进行开发的。 产品经理提出需求➡️UI进行页面设计➡️前端将设计图转换为HTML页面➡️将页面交由java开发人员进行数据对接，转为jsp页面➡️需求更改➡️前端返工➡️后端返工➡️再次对接➡️完成 可以看出，在一个项目的开发过程中，涉及到了前后端人员多次的交接。在后台人员接好一个页面之后，是将该页面集成在java项目中的。耦合度极高。如果遇到需求反复修改，前后端人员需要不断地循环对页面进行修改、嵌套数据，极大降低开发效率。 代码可维护性弱 在传统的开发中，页面的代码是集成在javaWeb项目里的。前后端的代码统一保存和修改。不论是前端的代码还是后端的代码出问题，都需要在一个项目中进行查找和修改。在修改时，又会遇到某个页面被其他页面调用，改了A页面，B页面受到了影响等问题。剪不断，理还乱。😔 不论是对前端人员还是后端人员来说，有自己的一亩三分地多好！🤔 无法应对前端复杂的业务需求 时至今日，用户不仅关心一个软件是否能用，而且对于它是否好用提出的更多的要求。用户不仅需要简单直观的数据展示，更需要炫酷、靓丽、个性化的操作界面。这使得前端相比前几年变得越来越重要。现在的前端和前两年的前端已经不可同日而语。他们需要掌握越来越多的技能来满足口味日渐挑剔的用户。并且在进入移动终端时代，前端也还要满足不同终端的适配。 现在的一个Web应用，前端在其中占据了比之前更大的比重，这样的情况使得传统的开发模式不堪重负。 以上是简单列举的几个方面，我们可以看到，造成这些问题的一个最主要的原因就是前后端的代码和开发进度耦合度极高。 2. 前后端分离的好处就上面所说的三点，我们再来看看前后端分离之后又有哪些好处。 提升开发效率 前后端分离之后，可以实现前后端代码的解耦。我们再来看看分离之后一个javaWeb项目的开发流程： 产品经理提出需求➡️UI进行页面设计➡️前后端并行开发➡️ 前后端对接 ➡️需求更改➡️前端返工或后端返工➡️再次对接➡️完成 在分离之后，只要在开发前期，前后端人员对所需接口以及接口的参数做出约定，就可以并行开发，互不影响。后端人员不再需要等待前端人员的页面，前端人员也不再需要受制于后端项目。极大地提高了开发效率。 增强代码可维护性 前后端分离之后，代码会分成两个项目来进行保存和修改。对于前后端人员，无论是代码的阅读还是和维护都将变得更加轻松。 他们各自终于有了自己的一亩三分地！😄😄😄 可更好地应对日益复杂的前端页面 将前端从原来的整个项目中抽离出来之后，能够更好地专注于前端的开发。开发效率和能力都将带来提升。 现在专人做专事，比之前更加专业，这也催生了目前流行的“大前端”。现在的前端发展得更加系统化，他们也有包管理工具、路由管理、cookies管理等工具。 同样的，后端人员也可以更加专注于数据和业务，而不用再为了前端页面犯愁了。😆😆😆 3. 如何进行前后端分离在文章开头我们也讲了， 前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。 千万不要以为只有在敲代码的时候把前端和后端分开就是前后端分离了，前后端分离，需要区分前后端项目。 前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。 前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。 前端只需要关注页面的样式与动态数据的解析和渲染，而后端专注于具体业务逻辑和数据地提供。 前后端分离的项目在部署的时候也需要分开来部署，目前流行的方式有以下几种： Node+Server Nginx+Server Nginx+Node+Server 4. 总结对于传统的混合开发模式，历经时间的考验，到现在虽然也能经得起大部分项目的开发，但是放眼未来，我们还是需要将前后分开，让彼此更加专业化、精细化。这便是未来发展的趋势。 End&nbsp;感谢您阅读到此本文版权归作者所有，欢迎转载转载必须在醒目位置标明作者与出处欢迎浏览我之前的文章： ES6中新增的处理字符串的方法 JS中14个数组的高级操作 理财知识]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>前后端分离</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个超实用的JS特性]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%87%A0%E4%B8%AA%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84JS%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[用了这么多年的javaScript， 有几个常用的JS特性时常会用到，这些特性不仅会给工作带来效率得提升，而且可以大大地简化代码。不论是自己以后修改代码，还是他人日后进行维护，都是大大的好事。 下面我们详细地展开来讲每一个特性的使用方法和要注意的地方。 1. 展开操作符用于对象或数组中的展开操作符（…），将一个结构展开为列表。 演示一下： 合并数组： 123let arr = [1,2,3];let arr_ = [4,5, ...arr];console.log(arr_); // [4, 5, 1, 2, 3] 合并对象： 12345678910let obj = &#123; id: '1', name: 'aaa', sex: 'woman'&#125;;let obj_ = &#123; sex: 'man', ...obj,&#125;; console.log(obj_); // id: "1", name: "aaa", sex: "woman" 在合并对象时要注意，如果是相同的对象，写在后面的会覆盖前面的。切记！ 2. 剩余参数先来看一个例子： 12345function add(p1, p2)&#123; let total = p1 + p2; console.log(total);&#125;;add(1, 2, 3); // 3 上面的add()方法，只处理了p1/p2两个参数，而如果我想临时多加几个参数，完成累加才做，该方法就无法处理。下面将对该方法做出优化，可以完成不定个数的参数累加： 12345function add(p1, p2, ...p3)&#123; let total = p1 + p2 + p3.reduce((prev, curr) =&gt; prev + curr); console.log(total);&#125;add(1, 2, 3, 4, 5); // 15 在方法定义时，增加一个...p3参数，在方法体中打印该参数可以看到，p3参数是除了p1/p2参数外的剩余参数所组成的一个数组。借助数组中的reduce()方法，可对剩余参进行操作（此处我进行了累加操作）。这样就可以很简单的完成一个参数个数可变的方法。 3. 字符串模板和插值在不使用vue/react等具有数据双向绑定特性框架的前提下，我们渲染页面中的数据时常会用到字符串模板，在从前，我们一般这样使用： 123var template = "&lt;div&gt;" + "&lt;span&gt;我就是我，颜色不一样的烟火。&lt;/span&gt;"+ "&lt;/div&gt;"; 我们不得不逐行逐句地重复添加引号和加号，以得到更好代码的阅读性。现在我们可以在拥有完美阅读性的前提下更简单地实现字符串模板，请看演示： 123var template = `&lt;div&gt; &lt;span&gt;我就是我，颜色不一样的烟火。&lt;/span&gt; &lt;/div&gt;`; 我们只需要借助一对 ` 将相应的字符串包起来，多方便！还可以使用${}在其中动态插入值。如下： 12345let blogName = '老米的世界';var template = `&lt;div&gt; &lt;p&gt;$&#123;blogName&#125;&lt;/p&gt; &lt;span&gt;我就是我，颜色不一样的烟火。&lt;/span&gt; &lt;/div&gt;`; 4. 方法属性对比一下ES5和ES6即可发现他的好处： 1234const calculate = &#123; add: function(a, b) &#123;return a + b&#125;, sub: function(a, b) &#123;return a - b&#125;&#125; 1234const calculate_ = &#123; add(a, b) &#123;return a + b&#125;, sub(a, b) &#123;return a - b&#125;&#125; 是不是好写多了！ 5. 解构赋值解构对象1234567891011function test(params, type)&#123; let name = params.name; let url = params.url; console.log(name, url, type); &#125;let obj = &#123; name: '老米的世界', url: 'https://mpfly.github.io/'&#125;test(obj, '个人博客'); 在test()方法中，我们需要两行代码来拿到parmas参数中的name和url字段。在使用解构赋值时，则只需一行代码即可。请看以下演示： 1234function test(params, type)&#123; let &#123;name, url&#125; = params; console.log(name, url, type);&#125; 解构数组在这里我们可以使用上面说到的剩余参数来获取剩余的数组成员，也可以使用,,来跳过某一个数组成员。 123let arr = [1,2,3,4,5];let [a, ,b, ...c] = arr;console.log(a, b, c); // 1 3 [4, 5] 6. 数组方法相关的数组操作可以点击查看我之前总结的2篇文章 JS中14个数组的高级操作 7. 字符串方法ES6中新增的处理字符串的方法 End 感谢您阅读到此。 感谢~ 欢迎浏览我之前的文章： 我被第一次喊【双手抱头！！！】 理财知识 我的兴奋点]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我被第一次喊【双手抱头！！！】]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%88%91%E8%A2%AB%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%96%8A%E3%80%90%E5%8F%8C%E6%89%8B%E6%8A%B1%E5%A4%B4%EF%BC%81%EF%BC%81%EF%BC%81%E3%80%91%2F</url>
    <content type="text"><![CDATA[写这篇文章的主要原因是想分享一下自己上个月的遭遇。 之前经常会在电视里的法制节目里看到，一群或便衣或警服的警察在楼梯口整装待发，然后带头的人员会一脚踹开房门，大喊“双手抱头”的场景。 总觉得这样的场景只要我自己不去做违法乱纪的事儿就应该不会遇到，直到上个月中秋节的前一天，也就是9月12日。 01那天是中秋小长假的最后一个工作日，虽然内心早已奔向自由，但还是得熬完这最后一天。 大概早上的9点40分，我正在敲着代码，只听到背后很远的地方传来嘈杂声。起初以为是同事之间的争吵，但是回过头细看：只看见一群人黑压压的从公司那边的楼梯口压过来，不断地喊着“不许动！举起手来！不要动手机和电脑！”。 我一脸懵逼，转头看向身边的同事，N脸懵逼~ 不由分说，一名女警已经走到我们附近。她虽然没穿警服，但是那种威严感还是很足，我不由得站起身来，举起双手，学着记忆中罪犯的样子，把手交叉靠在了脖子上。 身边的同事也一个接一个站起来，把手背在了脖子后。 懵逼~ 02这里要简单介绍一下我当时的公司：这家公司规模不算小，员工大约有200人左右。租了一整层的写字楼，并且员工坐的满满的。每层的写字楼除了有一个正门，两边各有一个逃生通道，通向楼梯口。当时警察们来的时候应该是从这3个入口同时发起“进攻”的。一下上来了20-30号警察。 可以想象，这个场景对我的冲击有多大。 不得不说，这些警察的做事很干练。在让我们站起来双手抱头的同时，已经有好几个警察开始盘问我的同事们。详细得询问姓名，并让交出身份证进行核对。 由于我们员工实在是太多了，而且有许多人都没有携带身份证，所以在盘问了一阵之后，警察们改变了策略：让所有员工依次排队站在通道上，并按照有无身份证分成两列。由多个警察进行询问和核对身份证。 在这期间，陆陆续续有10个左右的同事被“揪出来”，并被带到一个办公室里。 初露端倪~ 03我是从2018年5月份入职的这家公司，当时的公司规模还远没有现在这么大。人事大概在100人左右。从18年下半年开始，公司规模也开始渐渐增加，人数开始增多，最多的时候公司租了整两层写字楼供员工使用。 在被警察“揪出去”的那些人中，我发现一个规律。那些同事都是参与过一个项目的同事，包括前后台、项目经历、运维、测试以及销售人员。一个不落。 这个项目是“信贷项目”。算是这家公司的“顶梁柱”。这个项目在我18年进入公司时就已经在运行了，直到被抓。 万幸的是，我并没有参与这个项目，所以逃过一劫。 万幸~ 04接下来的整整一天，公司的所有员工无法出去，并且不能使用电子设备。我们失联了。 我们在通道一排排的站到10点半，警察告知可以搬过凳子来坐在通道上，但是明确且严厉地告知不能碰电脑和手机。 悬着的心在这时总算是落下来了，我们三五成群的开始议论这个事情。几个和我差不多进入公司的“老”员工也纷纷明白了个大概。 到中午时分，警察们让每个项目组的负责人给每个人点外卖，我们挨过了午饭。午饭过后，员工们可以坐在各自的工位上了，又是一下午的时间。 在这期间，警察们让每一位员工在一张A4纸上详细地写下自己的个人信息，以及在公司担任的职位，和做了哪些工作及项目。 直到下午6点，由于第二天就是中秋小长假了，有许多员工都定了回家的车票。这些员工开始找负责的警察说明情况，警察们开始落实解散员工们的行动。 期待~ 05下午6点半，每个想回家的员工都需要拿着写着自己详细信息的A4纸和身份证排队找相关的警察核实，核实之后才可以离开。 并且员工们被告知：收拾并带走自己的私人物品，不能动电脑，该公司将会被查封。 负责核实的警察只有两个，所以现场就和春运期间的火车站一样，大排起了长队。 最后到7点左右，我终于可以走了。 逃生~ 06回到家之后细想那天发生的事情，这件事情是必然的！ 由于我在该公司待了也挺久的了，事后也能想到几个不正常的地方。 其实从去年开始，就能感觉到公司不正常的地方： 除了刚刚所说的信贷项目，其他项目其实是不怎么挣钱的。那么如何支撑全公司200多号人的工资以及两层办公室的租金？ 只能说是信贷项目的收益高的可怕。 在8月份的时候，公司很紧急的解散了之前的信贷项目，把所有负责信贷项目的员工全部安插到了其他项目中。 说明到此时，公司高层也已经预感到了信贷项目的危机。 之后和一个做开发的同学聊起这件事，他说他公司对面的那家公司，也在前几天被一群警察查封了。 好巧~ 07现在的我从这家公司离职了。8月份的工资没法要回来了。 国庆节前夕，我入职了新公司，并且业务正常。 写这篇文章的目的，也是想把自己的遭遇分享出来，并且给让广大的程序员朋友提个醒：我们做开发的，不是你只写代码，就一定不会触犯到法律。 我们在找工作的时候，不要只盯着公司规模、福利待遇，更要详细地了解你要从事的具体项目。 可能很多同学要提问了：我们还没入职，如何得知该公司进行的项目是否违法。 我也承认，在入职前就调查清楚确实很难，我们要做的就是在入职后，擦亮自己的眼睛，我们虽然是公司的员工，但是我们更是父母的孩子，自己爱人的爱人，我们要对自己负责。 如果你在工作期间发现自己的公司所做的业务或者项目，有那么一丝丝违法的迹象，劝你早日离开。这样的公司是对他们自己不负责任，更是对员工不负责任。就算待遇很高，这样的公司不待也罢。 明目~ 欢迎浏览我之前的文章： 我被第一次喊【双手抱头！！！】 理财知识 我的兴奋点]]></content>
      <categories>
        <category>我的故事</category>
      </categories>
      <tags>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试JS篇]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95JS%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数据类型原始数据类型：Boolean、String、Number、undefined、Null 引用数据类型：对象、数组、函数 Thisthis总是指向函数的直接调用者。而非间接调用者。 如果有new关键字，this指向new出来的这个对象。 什么是window对象? 什么是document对象?window是指浏览器打开的窗口 document是指html文档对象，是window的一个属性。 null，undefined 的区别？ null 一个空对象 表示一个没有值的值，也就是值为空 它的typeof()是object undefined 表示一个变量声明了，但是没有赋值 它的typeof()是undefined 闭包概念：是指在一个函数中创建第二个函数，通过第二个函数来访问第一个函数中的变量和参数。 特性： 函数内嵌套函数 内部函数可以使用外部函数的参数和变量 参数和变量不会被垃圾回收机制回收 use strict作用：严格模式。是ES5发布的一个一个新命令。使得js在更严格的条件下运行，消除js语法的一些不合理、不严谨的语法。 instanceof判断某个对象是否属于某个类 new操作符干了什么? 创建一个空对象，并且this引用这个空对象 继承该函数的原型 属性和方法被添加到this引用的对象中 hasOwnProperty 查找一个对象中是否包含某个属性 不会查找该对象原型链中是否有这个属性，该属性必须是这个对象本身的成员 JSON 一种轻量级的文本数据交换格式，格式简单，易于读写，占用宽带小。 JSON字符串 –&gt; JSON对象 eval(&#39;(&#39;+str+&#39;)&#39;) JSON.parse(str) JSON对象 –&gt; JSON字符串 JSON.stringify(obj) documen.write和 innerHTML的区别document.write()会重新绘制整个页面；innerHTML只会重新绘制一部分。 DOM操作——怎样添加、移除、移动、复制、创建和查找节点?创建：createElement(&#39;div&#39;) 查找：getElementById(‘id’) / querySelector(&#39;#id&#39;) 添加/移动：appendChild(node) / insertBefore(node, node) 移除：removeChild(noed) 复制：node.cloneNode(deep) deep为true时，复制该节点下所有节点。否则只复制当前节点 检测浏览器内核、版本navigator.userAgent 千位分割符1234567function commafy(num) &#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($0, $1) &#123; return $1 + ","; &#125;);&#125; 拆解url的各部分url举例：https://blog.csdn.net/hannah1116/article/details/80078547 location.href： 完整链接 location.protocol：协议 –&gt;https: location.host：域名 –&gt; blog.csdn.net location.pathname：路径名称 –&gt; /hannah1116/article/details/80078547 location.port：端口号 location.search：从问号 (?) 开始的 URL（查询部分） location.hash：从井号 (#) 开始的 URL（锚） ajax12345678910var xhr = new XMLHttpRequest()xhr.open('post', '/api', true)xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; console.log(xhr.responseText) &#125; &#125;&#125;xhr.send(null); call()和apply()的区别js中所有函数都有这两个方法 这两个方法都能继承另一个对象的方法和属性，区别在于参数不一样 Function.call(obj, arg1, arg2,...)和Function.apply(obj, args) 第一个参数都是要调用的函数的对象。call()的剩余参数是传递给要调用的函数的值，而apply()只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 继承12345678function Animal() &#123; this.species = '动物'&#125;function Cat(name, color) &#123; this.name = name; this.color = color&#125; ​ 第一种： 12345function Cat(name, color) &#123; Animal.apply(this) this.name = name; this.color = color&#125; ​ 第二种： 12Cat.prototype = new Animal()Cat.prototype.constructor = Cat]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新生儿医保]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%96%B0%E7%94%9F%E5%84%BF%E5%8C%BB%E4%BF%9D%2F</url>
    <content type="text"><![CDATA[转载自公众号【五哥探险】原文链接 1. 新生儿医保当妈的应该都有感触，新出生的婴儿身体抵抗力较弱，比较容易患病。 有时候一个小小的感冒就有可能引发肺炎，住院四五天，几千块就没了。 但大部分的商业医疗险、重疾险，都要求在孩子出生28天之后才能投保。 再加上90天甚至180天的等待期，基本上在孩子半岁之前，商业保险是指望不上的。 所以这段时间，娃儿生了病，就只能靠医保，越早办理就越划算。 大部分地区规定，一般新生儿出生30天之内参保，自出生之日起就能生效，这段时间生病住院产生的费用，都能报销。 超过30天之后才购买的，自缴费到账次月起，才能用这个医保报销。 如果有些家长粗心大意，等孩子过了一岁采取办理，就要等到第二年的1月1日，才能享受医保待遇了。 2. 如何办理新生儿办理的这个医保，一般是指城乡居民医保，每年只需要缴纳一次费用就能保障一整年。 价格也不贵，大部分城市只需要220块。少部分地区每年一百来块，比如北京每年160元，上海每年130元，普通家庭也负担得起。 在第一次办理之后，往后每年都得在一个固定的时间段缴费。 一般是每年的9月到12月，去街道的医保服务点，就可以续保下一年的保费。 千万别忘了。 不然孩子的医保断了，即使重新补交，也有等待期。 要是这期间生病了，不能报销就亏大了。 办理的手续也非常简单， 先到派出所，把孩子的户口给上了；然后拿着宝宝的户口本页、孩子的出生证明、父母双方的身份证、结婚证，以及孩子一张一寸照片，到区县医保中心进行办理就好了。 如果不在户籍所在地的，比如说两口子都在北上广深工作，老家在广西湖南之类的，想给孩子办理当地的医保，就稍微麻烦些，需要父母双方至少有一方要有当地的居住证。 上海比较严格一些，不仅要有居住证，还要至少120分的积分。 具体办理的流程如下： （以最严格的上海为例）有居住证的那个人，请单位开具一个《上海市民居住证积分通知书》，在“同住人信息”那一栏里，填上配偶和孩子的信息。 最后，拿着夫妻双方的身份证、小朋友的出生证、户口本、居住证，以及上面开的那个通知书，去街道医保服务点进行办理。 拿到这个新生儿医保卡之后，一边住院一边统筹，资金周转不要太安心。 医保统筹报销的范围和报销比例，都和一般的居民医保一样，一般是40%-80%。 其他城市办理的流程，大体上类似，可能会有细微的差距，具体可以拨打当地社保热线12333详细咨询。 3. 补充说明新生儿医保的政策全国大体类似，但是不同的地区在细节上会有些许差距。 主要体现在费用、办理时间、报销比例上。 1. 每年的费用大部分城市，新生儿在出生30天之内办理，每年缴费都是220元。 超过这个时间的话，费用会大幅上涨，有的城市是550元，有的是740元，有的甚至要一千多。 如果是因为晚了一天办理，就要多交几百上千块，很吃亏。 有些城市福利比较好的城市，新生儿办理医保甚至不需要缴费，可以随母报销。 什么意思呢？ 简单来说，如果新生儿的妈妈办理有新农合，那么新生儿医疗待遇的报销，直接使用妈妈的医保就好了。 比如河南、安徽 这些地区办理随母报销，一般凭出生证、以及母亲参加城镇职工基本医疗保险或居民基本医疗保险的有效证件，宝宝就可以享受出生当年城镇居民基本医疗保险待遇了。 随母报销的流程也不复杂： 因为新生儿报销实行的是全额结算，所以需要去当地医保中心报销； 报销时，带上出院票据、出院证明、出生证、费用明细清单、户口本、监护人银行卡原件及复印件，去到当地医保中心提交材料； 等待资料审核，审核通过之后，就等着银行卡入账吧～ 2. 办理时间去年大部分地区的办理时间要求是，出生之后90天之内。 今年大多数地区都收紧到30天之内，但是部分地区还保留着90天的规定。 为了稳妥起见，建议大家最好都按照30天的标准来要求自己，这样能确保不会漏掉。 3. 报销比例虽然今年医保缴费和时间的要求，政策普遍收紧了。 但好消息是，报销比例上涨了。 很多城市，都将最高报销比例，从70%上调到了80%。 比如广州，今年的缴费标准是288元/人（去年是199元/人）。 但在三级医疗机构住院的报销比例，从去年的70%提升到了今年的80%。 4. 总结总体来说，新生儿医保是国家给的福利，非常实用，必须人手必备。 但是很多家人拖延症一犯，磨磨唧唧就错过了最佳办理时间，损失非常大。 尽量在娃儿出生30天之内，抓紧时间，把这个事儿给办了。 最后再次提醒一下，因为各地具体实施方案不同，具体规定可能会有所差异，各位爸爸妈妈们，可以拨打社保服务电话12333详细咨询。]]></content>
      <categories>
        <category>社保</category>
      </categories>
      <tags>
        <tag>社保</tag>
        <tag>新生儿医保</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[社保断缴问题]]></title>
    <url>%2F2019%2F09%2F03%2F%E7%A4%BE%E4%BF%9D%E6%96%AD%E7%BC%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[转载自公众号【五哥探险】原文链接 1. 什么是社保？无论如何，社保都是一定要交的。 因为这不仅是国家给我们的，最基本的社会福利保障。 也是性价比最高、门槛最低的「保险」。 在北上广深这样的一线大城市，买房、买车摇号、小孩上学甚至落户，都对社保缴纳有着一定的要求。 可以说，社保是大多数人立足城市的根本。 具体来说，社保就是我们通常所说的“五险一金”，它包括： 养老保险、医疗保险、失业保险、工伤保险、生育保险和住房公积金。 其中，养老保险、医疗保险、舍也保险、公积金，个人和公司按比例，每个月各交一部分。 每个月具体交多少，以我室友为例，算一笔账。 她在上海税前月薪是1.5W。 每个月五险一金，个人缴纳2625元，公司缴纳5364元。 每个月，社保账户入账7989元，差不多7成的钱是公司交的。 知道为什么很多公司，会偷偷按照最低缴费基数给员工交社保了吧。 因为实在是太！肉！疼！了！ 2. 社保断缴的影响1. 直接影响你的医疗费报销社保断交后，影响最大的是医疗保险。 从断缴第二个月的1号开始，看病就不能再报销医疗费用了。 不过医保卡里，个人账户的钱还可以继续用，不会因为断交就给你清零。 假设，我舍友比较倒霉，断掉社保之后的第二个月突然就生病了。 那么，她去医院看病花的钱，全部都要自己承担，一分钱都报销不了的。 （呸呸呸，这事儿当然是不会发生。） 其次，医保在退休之前，要求男性累计交满25年，女性累计交满20年。 中间如果经常断缴，有可能到退休的时候，累计缴费的时间还不够。 这样退休之后，就不能免费享受医保报销。 在加上，有的城市，如果断缴时间超过3个月，连续缴费时间就会清零，就只能享受最低的医疗报销额度。 这个问题，之前还被谣传说，断交之后，想重新报销必须要等待6个月。 这种说法妥妥就是危言耸听了。 大部分城市，比如北京、上海、广州、郑州，不管中间断了多久，从医保重新续缴的第二个月开始，看病就可以恢复正常报销。 而有的城市，如果断交超过3个月，报销额度和报销时间都会受到影响。 比如深圳，如果断缴3个月以上，年度最高保险限额和门诊大病的报销比例都会大打折扣。 再辛苦下我舍友来举栗子🌰 假设她在深圳连续交了6年医保，中间没断过，那他每年最高能报销160万左右； 但如果中间中断了不管，那么即使重新续上，之后半年内，最高也只能报销11万左右。 （深圳的童鞋想了解具体的影响比例，可以上深圳社保局查询。） 简单来说，就是交的时间越久而且没中断过，报销比例和上限就越高。 还有一些城市，比如太原、重庆、南京，如果断交超过3个月，即使重新续缴，也要等到6个月之后才能报销。 这就意味着，中间这6个月，如果生病的话，就得全部自己掏钱了。 这里顺便科普“连续”和“累计”的区别： 社保断缴后，虽然连续缴费时间会清零，但医保累计缴费年限是不清零的。 也就是说，即使你断缴过社保，但只要你所有缴费的时间，累加在一起超过规定年限（男性25年，女性20年），那在退休后就能享受终身医保待遇。 2. 购房、买车摇号、积分落户、孩子入学都会受影响断交第二大影响的，就是这个安身立命的问题。 想用公积金贷款买房，社保最低要连续缴纳6个月以上。 一些热门城市要求的时间更长。 比如上海，之前规定非沪户籍，只有连续缴满5年的社保，才能在上海买车摇号和买房。 这5年哪怕中断1天，都需要重头开始算。 今年上半年，开始调整为买房前的63个月内，缴满60个月的社保，就放宽了不少。 不仅如此，积分落户、买车摇号、孩子上学等，都要求连续缴纳社保半年以上。 北京、广州、深圳等其他城市，也有各自类似的政策。 3. 生育保险连续缴费年限清零社保断缴，有生育计划的女性，就没有办法报销产检、分娩费用，生育后也无法领取生育津贴等。 因为大多数城市，要求在生孩子之前，要连续缴纳9个月，或者累计交满一年，才能享受上述福利。 所以，只要不是在怀孕期间辞职，就不用太担心。 4. 断缴对养老保险影响不大养老保险，只要你退休时，累计交满15年，就可以领取养老金。 虽然说交的时间越长，养老金就越多。 但是少缴一两个月，影响不是很大。 至于失业保险，这个本来就是失业才会启动的保障。 离职之后可以按照当地社保局规定，申请领取在就业失业补贴。 至于工伤保险，完全就没有影响了，因为离职期间，你根本就用不到。 3. 断交期间应该怎么办呢？这个要分具体情况来分析： 1. 同城市换工作如果1个月内，就可以无缝衔接入职新东家的话，这个影响不大。 直接在新公司继续缴纳社保就可以。 如果1个月内不能入职下家公司，可以自己交社保。 有两个办法： 灵活就业人员社保 简单来说，就是自己准备好相应的资料，到当地社保服务点或社保局，办理个人缴纳社保。 不过需要注意的是，个人只能缴纳养老保险和医疗保险，且只允许本地户籍人员参加。 每个月大概要交多少钱呢？ 以上海为例，灵活就业人口2019年社保缴费上限为24633元，下限是4927元。 养老保险的缴费比例是28%，医疗保险是11.5%。 按照最低4927元来算， 养老保险=4927*28%=1379.56元 医疗保险=4927*11.5%=566.6元 也就是说，每个月需要缴纳1946.16元。 挂靠熟人公司或找社保代缴机构 如果没有当地户口的话，那就只能找熟人公司或者社保代缴机构来。 不过这种情况的话，个人和公司的全部费用，都需要自己承担。 如果我室友找了这种公司，那她每月最低缴费额度为： 养老保险4927元28%+医疗保险4927元11.5%+其他三险≈2054.6元 虽然贵了一点，但图个安心呀。 不过需要注意的是，找代缴机构的话，因为没有真实的劳务关系。 还是有一定风险，在选择上需要注意甄别。 2. 换城市工作如果离职后，换了另一个城市工作，就需要考虑社保异地转移的问题了。 五险一金中，只有养老保险、医疗保险和住房公积金可以转移，而且可以累积。 失业保险和工伤保险，反正也用不到，所以没什么关系。 至于社保关系转移的具体操作步骤，由于各地政策不同，大家可以在各地社保单位网站查询，或者直接打当地社保局热线12333咨询。 现实生活中，很多像我室友这样的年轻人，一时离职一时爽，一直离职一直爽，压根就不在意社保的问题。 却不知道社保原来那么重要！ 毕竟社保可以算是由政府出面，集中一部分社会财富，再扶危济困的“兜底”福利。 该属于社会主义社会羊毛了，该薅还是要薅的。]]></content>
      <categories>
        <category>社保</category>
      </categories>
      <tags>
        <tag>社保</tag>
        <tag>社保断缴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生育保险使用细则]]></title>
    <url>%2F2019%2F09%2F03%2F%E7%94%9F%E8%82%B2%E4%BF%9D%E9%99%A9%E4%BD%BF%E7%94%A8%E7%BB%86%E5%88%99%2F</url>
    <content type="text"><![CDATA[转载自公众号【五哥探险】原文链接 1.生育保险社保里，有一个特别容易被我们忽略的福利，是生育保险。 很多人以为，生育保险就是用来报销生孩子、产检的医疗费，也没几个钱，作用也不大。 其实呀，这里面的福利可大着呢。 医疗费用是小事，生育津贴才是大头。 你想呀，妈妈们在生了宝宝之后，肯定是要休产假的。 国家规定基础的产假是 98 天，如果是剖腹产的话再加 15 天。 生育多胞胎，每多生育一个宝宝，就多加 15 天。 休产假过程中，还能正常领工资，这些钱全靠生育津贴来支撑。 最开心的是，生育津贴拿多少钱，和自己个人工资完全无关！ 和个人工资完全无关！ 和个人工资完全无关！ 和个人工资完全无关！ 重要的事情说三遍！！！ 这个钱，是按照单位上一年的月平均工资来计算的。 计算公式是这样的： 生育津贴 = 上一年本单位人均缴费工资 / 30 天 * 产假天数 举个🌰假设单位上一年的平均工资是 10000 元， 顺产的话，可以领到 10000 / 30 * 98 = 32666 元 剖腹产的话，产假多加 15 天，可以领到 10000 / 30 *（98+15）= 37666 元。 有些单位平均工资高的，能领十来二十万！ 同一家公司，不管你是前台小妹，还是公司高层，你们拿的生育津贴是一样的。 对于工资低于公司平均工资的妈妈来说，就是妥妥的赚到啦～ 如果你自己的工资高于公司平均工资，也不用担心吃亏。 因为差额的部分，公司必须给你补足。 是不是爽歪歪呀～ 发小是剖腹产，一共有 98 + 15 = 113 天产假。 她的工资是 20000 元，上一年单位平均工资是 15000， 生育津贴领了 15000/30*113 = 56500 元。 公司再补给她 18833 元，最后到手 75333 元。 生个娃，在家啥也不干还拿 7 万多，心里美滋滋哒～ 想知道公司的平均工资也很简单，一般社保局就可以查到，有的城市微信公众号也能直接查到，还是挺方便的。 这里需要特别注意一点，如果公司是按照最低工资标准交的社保，比如上海，最低社保标准是 4927 元，那你能拿到的钱就只有 1.6W 左右，缩水非常严重。 所以如果是有计划生宝宝的话，在怀孕前，一定要要求公司按你的实际工资来交生育保险。 其他城市的生育保险也是差不多的内容，只是细则稍有不同。 具体可以在当地社保局网站查询，或者直接打 12333 去问。 2. 怎样才能领到这笔钱呢？只要生育保险交满一年，并且怀孕时仍然再正常缴纳费用，没有中断，就可以报销了。 报销的时候，拿上自己和老公的身份证原件及复印件、结婚证、居住证明、《计划生育服务手册》或《生育证》原件及复印件、婴儿出生证、出院证明（大人和宝宝的都需要）、本人银行结算户存折复印件。 到最近的生育保险服务中心填个申请表，资料交完，等着钱到账吧。 这里特别说明一下，有些城市不像上海这样，直接将钱打到个人银行卡里。 而是员工先把相关材料交给公司财务，等生育保险基金把报销的钱打到对公账户之后，公司再发给个人。 二胎政策开放之后，很多妈妈们也很关心，二胎可以报销么？ 可以的。 只要是符合政策的二胎，都可以报销，报销方式一样的。 如果工作地与户籍地不一致，去哪里报销？ 这个问题不用纠结，在哪里交的生育保险金，就在哪里报销。 至于，男同胞们的终极困惑：男性的生育保险有什么用？ 如果老婆已经有了生育保险，那你的生育保险，除了可以报销 15 天的陪产假津贴，其他没啥用！ 如果你老婆没有生育保险，那就帮大忙了。 可以用你的生育保险，给没有工作的老婆报销生产医疗费和津贴，能报销 50%，回血不少呢！ 生育津贴是国家给我们这些小仙女们的福利，如果因为不了解，白白浪费掉几万甚至几十万的话，那可真真是肝儿疼啦～～ 各位小仙女儿们，涉及自己利益的政策 ，一定要多研究多了解多打听呀～ 平时付出一点点经历，关键时候没准就能帮上大忙呢～ 各位准备喜提宝宝的辣妈虎爸们，速速收藏备用啦～]]></content>
      <categories>
        <category>社保</category>
      </categories>
      <tags>
        <tag>社保</tag>
        <tag>生育保险</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香港问题]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%A6%99%E6%B8%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[外部原因 2013年10月，中国正式向世界提出“一带一路”的合作倡议。 可以用人民币换取“一带一路”沿线国家的能源和矿产 这些国家可以使用人民币来换取中国生产的工业品， 这些交易之间没有美国插手，美国当然也就从中得不到任何好处 所以美国在当时搞出一个“亚太再平衡”的把戏，企图制约中国。在地缘上对中国编织了一个包围网，所以那几年我国的边境不是很太平。 菲律宾黄岩岛事件 南海仲裁事件 中日钓鱼岛 占中事件 2018年3月，人民币原油期货正式在上海上市 可以使用人民币来结算石油。 目前大部分国家都使用美元来结算石油，因此各个国家不得不想方设法搞到美元来购买石油和其他必须使用美元来购买的东西。 但是由于人民币原油期货的出现，现在可以使用人民币来购买石油了，这就撼动了美国的霸权。 美国心里想：你中国看来是要闹我呀，我不能坐以待毙呀。同时又看到我国目前先进的军事和经济实力，又没办法来硬的，只好对你的金融系统做做手脚，威胁中国的金融安全。 那如何对我国的金融系统做手脚呢？ 挑一个重要的地方：香港。 香港是我国最大的金融中心，同时是我国的人民币离岸中心 人民币离岸中心是指其他国家可以用人民币在香港和其他需要人民币的国家进行交易，换取美元或欧元，再将换取的美元和欧元购买其他物品或购买美国国债。香港也就是人民币兑换其他货币的一个银行。 如果将这个可以将人民币兑换其他货币的银行搞垮，那么人民币将会贬值，如果持续贬值，就是会导致中国境内的资本外逃，资本一旦外逃就会引起一系列的连锁反应，像股市大跌，房市崩溃，外汇缩水等等，这样一来最终就会引发金融危机，社会陷入动荡。]]></content>
      <categories>
        <category>政治</category>
      </categories>
      <tags>
        <tag>时政</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facebook像素编码的使用总结]]></title>
    <url>%2F2019%2F08%2F23%2FFacebook%E5%83%8F%E7%B4%A0%E7%BC%96%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 前言之前在做【跨境电商】项目时，由于需要使用Facebook进行广告的投放，所以接触到了Facebook像素编码。他的主要功能就是对电商各个页面的各种操作进行统计，如：浏览商品、加入购物车、购买等动作。每个商户都有一个后台监控系统，可以实时看到每个像素编码的的各个“动作”的统计量。 业务上的大体讲这么多，接下来我将展示几个主要的“动作”的具体代码。🙃🙃🙃 2. 具体代码在代码上的，其实就是几段javaScript代码，下面是几个代码片段。 我将以一个完整的购物流程进行说明： 访问电商 ➡️ 查看某个产品 ➡️ 将该产品添加到购物车 ➡️ 完善地址等购物信息 ➡️ 发起结账 ➡️ 完成结账 1. 初始化像素编码 说明： 在开始进行一系列动作之前，需要先初始化Facebook像素，即引入相关javaScript代码，https://connect.facebook.net/en_US/fbevents.js（该文件需要开启科学上网才能访问到）。 在引入相关必须的JS代码之后，需要执行一个fbq(&#39;init&#39;, facebookID)方法，即初始化该像素编码。这个facebookID可以通过异步操作从后台获取，也可以是一个固定的像素编码。 建议将初始化的代码放在一个公共方法中。 此处需要注意的是，可以一次性初始化多个像素编码。举个例子： 1234let facebookIdList = ['1111111111', '2222222222'];facebookIdList.forEach(facebookID =&gt; &#123; fbq('init', facebookID)&#125;) 代码： 123456789101112function initFacebook(facebookID) &#123; !function (f, b, e, v, n, t, s) &#123; if (f.fbq) return; n = f.fbq = function () &#123;n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments) &#125;;if (!f._fbq) f._fbq = n;n.push = n;n.loaded = !0;n.version = '2.0'; n.queue = [];t = b.createElement(e);t.async = !0;t.src = v; s = b.getElementsByTagName(e)[0]; s.parentNode.insertBefore(t, s) &#125;(window, document, 'script','https://connect.facebook.net/en_US/fbevents.js'); fbq('init', facebookID); // 其中的facebookID可以异步获取，也可以是一个固定的像素编码&#125; 2. 访问页面 说明： 每次访问页面都会执行这个方法。该方法无需参数。 代码： 1fbq('track', 'PageView'); 3. 查看商品 说明： 点击查看某个产品的详情。 参数： 产品id 产品编号 代码： 1234fbq('track', 'ViewContent', &#123; content_ids: 'affProductId',//产品id content_type: 'productSn'//产品编号&#125;); 4. 加入购物车 说明： 将产品加入购物车时执行。 参数： 产品id 产品编号 代码： 1234fbq('track', 'AddToCart', &#123; content_ids: 'affProductId',//产品id content_type: 'productSn'//产品编号&#125;); 5. 添加支付信息 说明： 在用户将要下单前，需要添加收货地址或者完善其他购物信息时执行。该方法无需传参。 代码： 1fbq('track', 'AddPaymentInfo'); 6. 发起结账 说明： 从购物车或者产品详情页发起结账时执行。 参数： 产品价格 产品货币种类 代码： 1234fbq('track', 'InitiateCheckout', &#123; value: totalprice,//产品价格 currency: 'TWD'//产品货币种类&#125;); 7. 完成结账，生成订单 说明： 通过线上付款或者货到付款完成结账动作并且生成订单后执行。 参数： 产品价格 产品货币种类 产品id 产品编号 代码： 123456fbq('track', 'Purchase', &#123; value: '1200', currency: 'TWD', content_ids: 'affProductId', content_type: 'productSn'&#125;); 3. 如何测试上面我们列举了大部分统计方法，相信大家很容易就能掌握并添加到自己的代码中。但是我们添加后，怎么进行测试呢？ 大家可以安装一款Chrome插件??Facebook Pixel Helper，可以在该插件上看到各个方法的执行过程。该插件也需要科学上网才能起作用。 4. 在React项目中的初始化在React项目中，初始化时遇到了一些问题，下面是在React项目中初始化的方法： 123456789101112131415161718192021222324let fbq = '';//初始化facebook像素export function initFacebook() &#123; (function (f, b, e, v, n, t, s)&#123; if (f.fbq) return; n = f.fbq = function () &#123; n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments) &#125;; if (!f._fbq) f._fbq = n; n.push = n; n.loaded = !0; n.version = '2.0'; n.queue = []; t = b.createElement(e); t.async = !0;t.src = v; s = b.getElementsByTagName(e)[0]; s.parentNode.insertBefore(t, s) fbq = n &#125;)(window, document, 'script','https://connect.facebook.net/en_US/fbevents.js'); fbq('init', facebookId); // 初始化像素编码&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Facebook像素编码</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用Next主题的配置]]></title>
    <url>%2F2019%2F08%2F21%2FHexo%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在17年的时候，我通过Hexo自己搞了一个博客，点击访问我的博客。自己也一直在该博客上更新文章，主要写一些技术分享、生活感悟等类型的文章。相信有很多人都对Hexo有所耳闻，今天我们就Hexo下的Next主题的配置写一个小的总结，其中包含了一些最基本的如：打赏、评论、字数统计等功能。 如果你已经创建了你的个人博客，却苦于没有一个好看和好用的主题，就快来学习吧。我将每一个功能需要修改的文件路径都已说明，只要跟着我的教程一步步来配置，相信你的Hexo博客将会焕然一新。 下面让我们来一探究竟！ 1. 博客底部标签样式只需要修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 2. 文章结束标志在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后(END POST BODY)， post-footer 之前添加如代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 3. RSS 切换到根目录下，然后运行如下代码，安装hexo-generator-feed 1$ npm install --save hexo-generator-feed 在hexo的_config.yml中，在最后添加如下代码： 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 在next主题的_config.yml中ctrl + F找到rss:，添加代码如下： （注意在冒号后面要加一个空格） 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 github中。 4. 修改文章内链接文本样式修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式 123456789101112// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; transition color .3s; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 5. 文章字体大小改为16px修改文件 themes\next\source\css\_common\components\post\post.styl，找到.post-body，修改其中代码如下： 1234567.post-body &#123; font-family: $font-family-posts; font-size 16px; +mobile() &#123; word-break: break-word; &#125;&#125; 6. 修改作者头像鼠标上移旋转打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.site-author-image &#123; display: block; margin: 0 auto; cursor pointer; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform .5s ease-out; -moz-transition: -moz-transform .5s ease-out; transition: transform .5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; asd 7. 代码样式——包括代码块和多行代码打开\themes\next\source\css\_custom\custom.styl,向里面加入： 123456789101112131415161718code &#123; color: #ff7600; background: #fbf7f8; margin: 2px; border: 1px solid #d6d6d6;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;.highlight .line &#123; height: 24px;&#125; 8. 站点访问量较低版本的next没有内置busuanzi，推荐以下方法 打开\themes\next\layout\_partials\footer.swig文件 在一开头加上以下代码： 12&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后在合适的位置添加显示统计的代码 123456&lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt; &lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 清除缓存，重新加载，搞定。 版本较高的内置的busuanzi 只需要在主题配置文件中修改如下： 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 本站访问量 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 本站访客数 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 文章阅读量 page_pv_footer: asd 9. 全站字数统计针对较低版本的next，推荐一下方法 切换到根目录下，然后运行如下代码： 1$ npm install hexo-wordcount --save 在/themes/next/layout/_partials/footer.swig文件内合适位置加上： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 清除缓存，重新加载，搞定。 版本比较高的 打开主题配置文件，找到post_wordcount，配置如下： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 10. 阅读时间、文章字数 切换到根目录下，然后运行如下代码： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 清除缓存，重新加载，搞定。 11. 在文章底部增加版权信息 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 保存重新生成即可。 需要在每篇文章的头部添加如下代码： 1copyright: true 12. 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件，在顶部位置插入这样一段代码： 1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 在写文章时，如需对该文章加密，需要在文章头部添加以下代码： 1password: ****** 这样在打开文章时，会自动弹出密码输入框。 13. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ asd 14. 添加友情链接打开主题配置文件修改成这样就行了(links里面写你想要的链接)： 1234567links_icon: linklinks_title: 友情链接# links_layout: blocklinks_layout: inlinelinks: 慧行说: https://www.liuyude.com/ 张鑫旭: https://www.zhangxinxu.com/ asd 15. 评论我使用Valine来进行评论，具体的步骤如下： 在leanCloud)上注册一个账号 注册成功并登录后，你会得到两个数据： App ID App Key 复制并保存 打开主题配置文件，我的版本是v5.1.3，其中已经内置了Valine评论系统，只需要打开即可： 12345678910valine: enable: true appid: yourAppid appkey: yourAppkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 请输入您的评论，看到必回复！ # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size Valine 目前使用的是Gravatar 作为评论列表头像。 请自行登录或注册Gravatar，然后修改自己的头像。 评论的时候，留下在Gravatar注册时所使用的邮箱即可。 16. 添加文章更新时间 修改/themes/next/layout/_macro/post.swig 文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;标签后添加： 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('post.updated') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 在/themes/next/languages/zh_Hans.yml中新增： 12post: updated: 更新于 修改主题配置文件/themes/next/_config.yml，增加一行 1display_updated: true 写文章的时候可以直接在文章开头设置更新时间： 1updated: 2018-01-01 12:30 没有参数的话将会默认显示.md文件的修改日期 17. 文章搜索 根目录下执行： 1npm install hexo-generator-searchdb --save 在主题配置文件/theme/next/_config.yml中添加配置： 12345search: path: search.xml field: post format: html limit: 10000 并修改数据 12local_search: enable: true asd 18. 阅读次数打开主题配置文件/theme/next/_config.yml修改配置如下 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: false site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: false site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 文章阅读量 page_pv_footer: 由上到下分别是 全站的UV 全站的PV 文章的PV 19. 配置背景动画打开主题配置文件/theme/next/_config.yml修改配置如下： 1234567891011# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false asd 20. 首页文章列表鼠标上移样式打开\themes\next\source\css\_custom\custom.styl，向里面加入： 1234567891011// 主页文章添加阴影效果.post &#123; margin-top: 60px; padding: 25px; transition: box-shadow .3s; &amp;:hover&#123; box-shadow: 0px 6px 8px 6px rgba(202,203,203,0.5); -webkit-box-shadow: 0px 6px 8px 6px rgba(202,203,203,0.5); -moz-box-shadow: 0px 6px 8px 6px rgba(202,203,203,0.5); &#125;&#125; asd 21. 去掉文章目录自动生成的编号打开主题配置文件/theme/next/_config.yml修改配置如下： 12# Automatically add list number to toc. number: false asd 22. 文章头部添加【天气】打开\themes\next\layout\_macro\post.swig，在合适位置加入： 12345&#123;% if post.weather%&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-text"&gt;天气：&lt;/span&gt; &lt;span&gt;&#123;&#123; post.weather &#125;&#125;&lt;/span&gt;&#123;% endif %&#125; 在写博文时，需要在头部新增weather字段 123456789title: tags: - 1 - 2categories: weather: 晴date: 2017-01-13 16:07:32copyright: truepassword: asd]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[if 弱判断总结]]></title>
    <url>%2F2019%2F08%2F15%2Fif%20%E5%BC%B1%E5%88%A4%E6%96%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. if 语句会自带一个弱类型的判断，下面我们来看看他的判断规则。空字符串1234567let a = ''if(a)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// false null1234567let a = nullif(a)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// false undefined1234567let a = undefinedif(a)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// false NaN1234567let a = NaNif(a)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// false 空对象{}1234567let a = &#123;&#125;if(a)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// true 空对象[]1234567let a = []if(a)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// true 2. 如何判断空数组和空对象 判断空数组 1234567let a = []if(a.length === 0)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// true 判断空对象 使用Object.keys()方法 12345678let a = &#123;&#125;let arr = Object.keys(a)if(arr.length === 0)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// true 使用Object.getOwnPropertyNames()方法 12345678let a = &#123;&#125;let arr = Object.getOwnPropertyNames(a)if(arr.length === 0)&#123; console.log('true')&#125;else&#123; console.log('false')&#125;// true]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>if方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财知识]]></title>
    <url>%2F2019%2F07%2F25%2F%E7%90%86%E8%B4%A2%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[第一天：了解理财 理财，不仅仅是投资，他还包括了你的收支规划、养老安排、子女教育、税务筹划等。它不仅仅是一个简单的工具，更是一种思维习惯和生活方式。 通货膨胀会让物价上涨，让你的钱变得越来越不值钱。通货膨胀会对两类人不友好： 那些把钱攥手里的，或者存银行的人。 靠死工资过日子的人 学习理财有两个好处： 战胜通货膨胀 帮你增加被动收入 理财有3个常见的误区： 觉得没钱，就不理财。你不理财，财不理你。是因为不理财，才导致了没钱，而不是因为没钱，才没法理财。 把所有的钱都拿来投资，要做好配置。不要把鸡蛋都放在一个篮子里。 理财没学懂就急着上手。要先学习理财知识，不懂不投。 被动收入： 被动收入，就是你不用干活还能拿到的收入就是被动收入。当你的被动收入 &gt; 全部支出时，就实现了财务自由 第二天：我们可以拿出多少钱来理财要先搞清楚自己的资产情况，再来确定可以拿出多少钱来去进行理财。可通过下面几点分析自己的资产情况。 资产负债表： 资产、负债、所有者权益 资产：能换成钱的东西，包括钱、房子、车子等。 负债：欠别人的钱，包括：欠款、车房贷、信用卡、花呗等。 所有者权益：你真正拥有的钱 资产 = 负债 + 所有者权益 收入支出表： 也就是你的收入和支出的记录。也就是我们平常的记账。 拥有清晰、完整的收支记录，可以帮助我们衡量自己的消费情况，如下： 可以看到这个月的支出是否大于自己的收入。 可以看到这个月你的支出，有多少变成了资产，多少变成了消费。 支出大致分两种：消费和资产 消费：我们最常见的支出，各种买买买。 资产：将我们的钱去买国债、基金、理财产品等。以另外一种形式，沉淀下来。 第三天：保险的作用1. 五险一金中的五险，也就是【社保】，它包括： 养老保险 医疗保险 生育保险 工伤保险 失业保险 我们着重讲其中的医疗保险，它有如下特点： 能解决基本的医疗开支问题 覆盖广、水平低，保障力度有限 有免赔额度 有报销的上限：门诊约2w，住院约30w 不是所有药品都能报销 能提供基本的医疗需求保障，虽然必不可少，但是作用有限，仍旧需要商业保险作为补充。 2. 商业保险，主要有4种： 重疾险： ​ 重大疾病保险。当被保人得了某些重大疾病时，能够拿到一笔理赔金。主要弥补因为生病而带来的收入损失，确保在你生病后，还能保持原来的生活水平。 意外险： ​ 当被保人受到意外伤害，造成了身故或残疾时，而赔付的费用。 医疗险： ​ 主要能报销因为看病而产生的医疗费用。医疗险和医保最好配合使用，医疗险可以报销医保报销不了的部分。 寿险： ​ 当被保人不幸身故，他指定的受益人，可以一次性拿到一笔理赔金。它主要保障自己家人未来的生活质量。 3. 配置保险的原则 先保障，后理财。 保障型保险和理财型保险应分开购买，要先买保障型，后买理财型。 市场上有一种返还型保险，即“有病治病，没病返钱”。这就是一种理财型保险。往往收益很低，保障也很差。往往两不相顾，不建议在前期没有保障型保险的时候购买。 先大人，后孩子老人 应先保障大人，尤其在家里扮演收入支柱的。 保险，不是保感情，而是保责任。 第四天：理财产品的分类第一种：收利息的产品通过借给他人钱，收取利息，赚的收益。 主要包括： 银行存款：把钱存银行，收利息 国债：把钱借给国家，收利息 企业债：把钱借给企业，收利息 P2P：把钱借给公司，收利息 特点： 优点：除P2P外的其他比较稳定，稳赚不赔，几乎无风险。 缺点：收益少，回钱慢。 第二种：做买卖的产品通过购买资产，赚的收益。 主要包括： 股票：购买上市公司股份，低买高卖赚取收益。 房子：购买房产，或租或卖赚取收益。 黄金：购买黄金储备，低买高卖赚取收益。 外汇：购买外汇，低买高卖赚取收益。 特点： 优点：收益高，来钱快。 缺点：风险大，几乎无法保证稳赚不赔。且需要对某行业有较深的了解。 第三种：雇人投资的产品通过花钱雇佣专业人士，帮你做投资，获取收益。 主要包括： 基金公司发行的基金 银行发行的理财产品 证券公司发行的券商集合理财产品 信托公司发行的信托理财产品 特点： 优点： 雇佣专业人士投资，风险较低； 每个参与者均摊亏钱风险，降低成本； 对专业行业不用了解太深； 缺点：有亏钱风险。 总结： 第一类产品收益低，但是风险也低； 第二类收益高，但是风险也高，需要专业知识保障； 第三类比较适合什么都不懂的小白，风险低，收益也比第一类要高。值得重点学习。 第五天：认识基金在前一天，我们学到了各种理财产品。其第三类最适合我们小白投资，那就是【雇人投资的产品】。今天我们详细聊聊其中的基金。 1. 基金的概念基金，就是基金公司，雇佣了一个基金经理，用你的钱，来帮你做投资。 自己炒股费事费力，自己还不专业，容易赔。不如就找一个专业的人士，来帮你做投资。 相比较炒股，有以下优点： 节省时间。可以交给专业的基金经理去打理，自己坐享其成。 风险较低。由专业人士操办，较为专业。而且由多人一起承担亏损风险。 不需要很多的专业知识。 2. 基金的分类按照基金经理不同的投资理念，可以分为【主动型基金】和【被动型基金】。 1. 主动型基金主动型基金，就是基金经理根据自己对市场的判断，把资金投资于他认为能赚钱的股票和债券里。希望通过这样的投资组合，跑赢市场。 缺点： 过于依赖基金经理： 如果基金经理的投资水平不高，或者判断失误，就容易亏损。 交易成本偏高： 主动型基金的申购费、赎回费、管理费偏高，这样会拉低你的实际效益。 2. 被动型基金被动型基金，也被叫做指数型基金。他是根据选择的特定的指数股票作为投资的对象，比如我们新闻中常听到的【上证500】、【沪深300】等。 被动型基金基本上是跟着大盘的走势，市场形势好就能盈利。所以某种程度上，买指数基金就是买国运。 只要中国的经济越来越好，中国的指数基金也会越来越好。 所以对于我们小白，通过投资指数基金是我们投资获利最好的方式。 优点： 管理费用低。 被动型基金的股票一般比较优质。 像【沪深300】指数基金股票，就是沪深股市中比较优质的300只股票。 能把人性弱点的负面影响降到最低。 对比主动型基金，收益完全依靠基金经理的操作。操作的好挣钱，一旦失误，就会赔钱。 而被动型基金，几乎可以忽略人为的因素，只要看指数就行。 3. 如何投资基金对于小白来说，最好的投资方式就是【定投】 定投：就是在固定的时间，投入固定的钱。 如：在每个月发了工资之后，将相应的钱划到你的指数基金里去。 定投的好处： 减轻投资压力： 将你要投资的钱，分散开时间多次去投入。如：每个月投1K和一次性投1w，对你的压力就不同。 分散投资成本，降低风险： 基金的价格也是会波动的。每个月投入固定的钱，就不会相差太多。 变相强制储蓄资金，帮你存钱。 4. 总结投资基金，是相比较股票等最适合我们小白的投资方式，而基金中的【被动型基金】是最适合我们普通人投资的基金类型。该种基金具有风险小、费用低等优点。最适合普通人去投资。 投资基金时，我们最好使用【定投】的方式。即：在固定的时间，投入固定的钱。 第六天：国债和国债逆回购1. 国债：国债，收益高，且稳定。 国债的风险，是由政府来承担的。 国债就是由国家政府发行的债券。相当于是国家向老百姓借钱，并给每一个借了钱的人打了一张借条。在到期之后，国家会向老百姓返回本金，并给予一定数量的利息。一般来说，国债的利息要比银行的定期存款多一点。 2. 国债逆回购国债逆回购，就是需要用钱的企业，把他持有的国债作为抵押物，抵押给你，来向你借钱。在到期之后，再把借来的钱连本带利还给你，我们就是赚取这个利息。 由于国债的稳定性和高收益，就算该借钱的企业最后没有还钱，由于我们持有该企业抵押给我们的国债作为保证，也不会太亏。基本可以认为是没有风险的。 3. 如何操作？ 开通股票账户 购买份额 购买国债逆回购的地方主要有2个： 上交所：上海证券交易所——土豪版 一般10W起投，加价也需要是10W的整数倍。他们的代码一般以【GC】开头。由于资金量较大，利率较高。 深交所：深圳证券交易所——平民版 一般1k起投，加价也是1k的整数倍。代码一般以【R】开头。由于资金量较小，利率较低。 一般作为小白的我们，要先选择购买“平民版”的深交所的逆回购，先来学习和练习。 国债逆回购的期限是固定的，分别是： 1天、2天、3天、7天、14天、28天、91天、182天。共9种。 不同期限的品种，收益率也不同，他们会根据市场的需求情况，各自上下浮动。 注：逆回购到期之后，本金和利息将自动回到股票账户。]]></content>
      <categories>
        <category>理财知识</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>理财知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序canvas压缩]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fcanvas%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[最近在开发小程序，需要使用压缩图片，遂做出如下总结。 👇👇👇 1. wxml首先需要在wxml文件中写一个&lt;canvas&gt;&lt;/canvas&gt;。给一个绝对定位样式，这样会隐藏到页面中。不过我习惯在调试的时候，让其显示出来。等调试ok之后，再将其隐藏起来。 1&lt;canvas canvas-id="canvas" style="width:&#123;&#123;cWidth&#125;&#125;px;height:&#123;&#123;cHeight&#125;&#125;px; position: absolute;left:-1000px;top:-1000px;"&gt;&lt;/canvas&gt; 2. javaScript 首先使用wx.chooseImage()方法从相册选取一张照片 可获得该照片的大小，可以用来筛选体积比较大的图片 使用wx.getImageInfo()拿到该图片信息，包括： 图片原始的宽/高 可以通过该原始宽/高来计算该图片在canvas的大小。 使用wx.createCanvasContext()来画图。 使用wx.canvasToTempFilePath()将canvas画板转化成最终的压缩后的图片路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647wx.chooseImage(&#123; count: 1, // 默认9 sizeType: ['compressed'], // 指定只能为压缩图，首先进行一次默认压缩 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (photo) &#123; //-----返回选定照片的本地文件路径列表，获取照片信息----------- wx.getImageInfo(&#123; src: photo.tempFilePaths[0], success: function(res)&#123; //---------利用canvas压缩图片-------------- var ratio = 2; var canvasWidth = res.width //图片原始长宽 var canvasHeight = res.height while (canvasWidth &gt; 400 || canvasHeight &gt; 400)&#123;// 保证宽高在400以内 canvasWidth = Math.trunc(res.width / ratio) canvasHeight = Math.trunc(res.height / ratio) ratio++; &#125; that.setData(&#123; cWidth: canvasWidth, cHeight: canvasHeight &#125;) //----------绘制图形并取出图片路径-------------- var ctx = wx.createCanvasContext('canvas') ctx.drawImage(res.path, 0, 0, canvasWidth, canvasHeight) ctx.draw(false, setTimeout(function()&#123; wx.canvasToTempFilePath(&#123; canvasId: 'canvas', destWidth: canvasWidth, destHeight: canvasHeight, quality: 0.3, // 压缩倍率 success: function (res) &#123; console.log(res.tempFilePath)//压缩过后的最终图片路径 &#125;, fail: function (res) &#123; console.log(res.errMsg) &#125; &#125;) &#125;,100)) //留一定的时间绘制canvas &#125;, fail: function(res)&#123; console.log(res.errMsg) &#125; &#125;) &#125; &#125;) 3. 遇到的问题问题：在开发过程中，发现一个比较有意思的事情：🤔🤔 在使用wx.chooseImage()方法时，在success()回调函数中拿到选择的图片路径，在显示到页面上之后。有的会出现向左偏转90度的问题。而其他都是正常方向显示。 一开始猜测是图片体积大小影响显示方向。在经过若干测试后发现，并不是体积问题。 后来又猜测是图片的尺寸问题，但经过验证后确定，也并不是尺寸影响，😵 解决方法：在wx.chooseImage()后，继续使用wx.getImageInfo()方法。在该方法的success()回调函数中可以拿到图片的原始尺寸。: 123456789101112// 来自于微信官网文档wx.chooseImage(&#123; success (res) &#123; wx.getImageInfo(&#123; src: res.tempFilePaths[0], success (res) &#123; console.log(res.width) // 原始宽度 console.log(res.height) // 原始高度 &#125; &#125;) &#125;&#125;) 我上传的图片都是原始宽度小于原始高度的图片，如960*1920的照片。在上传该图片后，打印该图片的原始宽高，会发现变成了1920*960的尺寸。这也就是其“摔倒”的证据。所以可以在wx.getImageInfo()中判断该图片的宽高。如果他的宽 &gt; 高 ，就说明该图片“摔倒了”。需要添加让其转过来的代码。否则不需要操作。 4. 结语在小程序开发过程中，时常会遇到类似的问题。并且在各大论坛上也找不到相关的解决方法，只能通过自己的小操作来实现业务。 打铁还需自身硬呀~]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode常用的插件]]></title>
    <url>%2F2019%2F07%2F15%2FVSCode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[VSCode常用的插件必备 插件 说明 Beautify 格式化各种语言的代码。ctrl + shift + p 打开控制面板，输入Beautify file， Auto Close Tag 自动添加HTML / XML关闭标签 Auto Rename Tag 自动重命名配对的HTML / XML标签 Bracket Pair Colorizer 颜色识别匹配括号 Chinese (Simplified) Language Pack for Visual Studio Code 中文简体语言包 filesize 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 GitLens — Git supercharged 显示文件最近的 commit 和作者，显示当前行 commit 信息 JavaScript (ES6) code snippets es6代码片段 Live Server 浏览器实时刷新 Path Intellisense 路径自动补全 SVG Viewer 可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项 Vetur Vue 语法高亮显示, 语法错误检查, 代码自动补全(配合 ESLint 插件效果更佳) js snippets js代码片段 Easy LESS 将less文件自动保存为相同名字的css文件 HTML Boilerplate 自动生成h5文件头部信息 open in browser 将静态页面在浏览器中打开 vscode-icons 修改编辑器icon Trailing Spaces 高亮那些冗余的空格，可以快速删掉 Reactjs code snippets 用 ES6 语法去开发 React.js 应用非常方便 Color Info 鼠标上移颜色块，显示该颜色信息 autoprefixer 自动完成css代码兼容 vscode-fileheader 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间快捷键: Ctrl+Alt+i 小程序开发 插件 说明 vscode wxml 为 VSCode 提供 wxml 语法支持及代码片段 小程序助手 minapp 微信小程序标签、属性的智能补全 wxml 格式化功能、高亮组件 Easy WXLESS 将less文件自动转换成wxss文件 主题 插件 One Dark Pro One Dark Pro Vivid 快捷键1234567891011121314151617181920212223242526272829303132333435[ &#123; "key": "ctrl+alt+", "command": "editor.action.addSelectionToNextFindMatch", "when": "editorFocus" &#125;, &#123; "key": "ctrl+d", "command": "-editor.action.addSelectionToNextFindMatch", "when": "editorFocus" &#125;, &#123; "key": "ctrl+d", "command": "editor.action.deleteLines", "when": "textInputFocus &amp;&amp; !editorReadonly" &#125;, &#123; "key": "ctrl+shift+k", "command": "-editor.action.deleteLines", "when": "textInputFocus &amp;&amp; !editorReadonly" &#125;, &#123; "key": "alt+shift+t", "command": "trailing-spaces.deleteTrailingSpaces", "when": "editorTextFocus" &#125;, &#123; "key": "ctrl+shift+f", "command": "HookyQR.beautify", "when": "editorFocus" &#125;, &#123; "key": "ctrl+shift+c", "command": "autoprefixer.execute" &#125;]]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机油知识总结]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%9C%BA%E6%B2%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 机油标号举例：SN 0W 40 想选对机油，就要先了解机油，每桶机油包装都明显的印着机油的标号，抛开品牌，我们以SN 0W-40的机油来举例。前面的SN。这是美国石油协会的标准等级，简称API。S代表汽油发动机用油，如果这个字母变成C，那么则代表是柴油发动机用油，千万别加混了！！！ 有时还会S和C一起出现，那么就代表汽油发动机和柴油发动机都可以使用，不过这种并不多见。S后边的N，则表示的是机油等级，从A一直到N，字幕越靠后等级越高。有些机油则印的是A几B几，比如A3/B4，可以理解为这是欧版的等级标准，A是汽油机，B是轻型柴油机，后边的数字越大，则代表机油等级越高，目前最高等级为5。 2. 对应温度与粘稠度后边的0W-40，W是winter（冬天）的缩写，W前面的数字代表丧失流动性的温度，数字越小，那么就能在越低温度的环境下使用。0W对应的是-35°，5W是-30°以此类推。在选择机油的时候，可以考虑一下用车环境。后边的40，则是机油的粘稠度，数字低流动性好，粘稠度低，数字大则粘稠度高。同品牌机油标号跨度越大，价格也就越高。 机油尽量选择恰当的标号，太高流动性差发动机的运动阻力也会变大，增加油耗。机油泵的效率也会变低，降低润滑效果。粘稠度太低附着力相对弱，增加不必要的磨损，还可能烧机油。 在车主手册上，都会清楚的写着推荐使用的机油标号。但也可以根据自己的情况进行小调整，经常暴力驾驶，发动机温度比较高，机油会相对变稀。或者轻微烧机油、老车可以适当的把粘稠度调高，减少发动机磨损。比如从0W-20调整到0W-30。正常车辆加错标号粘稠度相差大于等于两个级别，就赶紧换回来。 3. 矿物油、半合成、全合成的区别 矿物油等级会便宜一点，是石油提炼的矿物油再添加了添加剂生产出来的。矿物油各项的性能都不是很高，使用里程较短，但价格便宜一般都会用在经济型车上。 半合成机油则是由矿物油的基础，经过加氢裂变技术提纯后的产物，可以理解为矿物油和全合成机油4：6的比例混合。比矿物油各项性能都上升一个等级，使用里程会增加很多，但价格也会随之提高。10万左右售价的车型里，很多都使用的是半合成机油。 全合成机油则各项性能都要提升很多，是目前机油里的“大哥”了，是人工调配的高质量机油。稳定性、持久性等等各项性能都优于矿物和半合成机油。从理论上来说，任何车型都适合加全合成机油。但全合成机油的价格普遍偏高。 4. 品牌选择市场上比较主流的壳牌、嘉实多、美孚等等只要是真货，同标号实际的使用效果相差并不多。只要是真货，都可以放心的选择。别迷信赛车用油，很多赛车油都是为了长期高温环境下使用的，或者粘稠度很高，实际使用里程可能还不如普通机油，很多都是用一次就换掉了，不适合家用。]]></content>
      <categories>
        <category>行车日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《人类简史》 - 笔记]]></title>
    <url>%2F2019%2F06%2F10%2F%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 现代人的祖先是智人。 人类进化出容量大的大脑，可以更好的“思考”。但是到目前为止，人类为什么会进化出大容量的大脑，我们也并不知道。 庞大的大脑是个庞大的负担： 大脑结构脆弱，需要有头骨保护。 即使在休息的时候，大脑依旧会消耗大量能量。 人类直立行走 优点： 获得更大更远的视野 解放手，让手可以发挥其他用途 缺点： 人体结构上不合理，时间长之后会受到背痛、脖子僵硬的困扰 直立行走让臀部变窄，而人类的头越来越大，分娩风险变大。 为了减小分娩风险，人类不得不在婴儿头部很小、很软的时候就脱离母体，让大脑剩余的发育在母亲体外进行。这也导致一个孩子需要很多成年人共同照顾。 人类使用火 改变环境：烧掉难以通行的丛林转变为大片的原野 保护自己：取暖、吓跑野兽 烹饪食物： 食物种类更多了，并且可以杀死其中的病菌。 食物被烹饪后，减少了人类咀嚼和消化的时间。 减短消化道长度、降低能量消耗，可以使大脑获得更多能量。 在历史的路上，有三大重要革命： 大约7万年前，“认知革命“让历史正式启动。 大约12000年前，“农业革命“让历史加速发展。 大约500年前,“科学革命“可以说是让历史画下句点而另创新局。 这本书的内容，讲述的就是这三大革命如何改变了人类和其他生物。 智人之所以能征服世界，是因为有独特的语言。 第二章 人类语言真正最独特的功能，是能够传达并且相信一些根本不存在的事物的信息。然后一起去想象并编织种种虚构的故事，这样的虚构故事赋予智人前所未有的能力,让我们得以集结大批人力、灵活合作。 “八卦”是维系自然团体的力量。等到认知革命之后,智人有了八卦的能力,于是部落规模变得更大,也更稳定。然而,八卦也有限制。社会学研究指出,借由八卦来维持的最大“自然“团体大约是150人。只要超过这个数字,大多数人就无法真正深入了解、八卦所有成员的生活情形。 智人通过创造虚构的故事，就算是大批互不相识的人，只要同样相信某个故事,就能共同合作。最后创造出了有数万居民的城市、有上亿人口的帝国。例如：国家、法律、公司、宗教等。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中新增的处理字符串的方法]]></title>
    <url>%2F2019%2F05%2F25%2FES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 检测字符串中是否包含某字符串12includes()str.includes(searchElement, fromIndex) 参数 描述 searchElement 必须。需要查找的元素值 fromIndex 可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0 12const str = 'abcdefg'str.includes('g') //true 2. 是否以某个字符串开头12startsWith()str.startsWith(searchvalue, start) 参数 描述 searchvalue 必需，要查找的字符串。 start 可选，查找的开始位置，默认为 0。 12const str = 'abcdefg'str.startsWith('a') //true 3. 是否以某个字符串结尾12endsWith()endsWith(searchvalue, end) 参数 描述 searchvalue 必需，要查找的字符串。 end 可选，查找的结束位置，默认为 字符串长度-1。（从字符串开始到第end个） 123const str = 'abcdefg'str.endsWith('g') //truestr.endsWith('g', 3) //false 4. 复制字符串12repeat()repeat(count) 参数 描述 count 必需，复制的次数。 12const str = 'ABC'str.repeat(2) //ABCABC 结语暂时先总结这几个，如有不正确的地方，欢迎在下方留言指正。😀😀😀]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信JSSDK使用步骤]]></title>
    <url>%2F2019%2F05%2F17%2F%E5%BE%AE%E4%BF%A1JSSDK%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[最近在做一个公众号项目，其中用到了微信的【扫一扫】，如何在项目中接入扫一扫呢？下面开始详细说说。 首先查看文档，之前也看到过很多人抱怨腾讯的文档。不得不说，微信的文档写的真的是“普通”。有的东西解释的太过于简单，让人摸不着头脑。无奈只得求救于网上广大的微信开发先行者，看他们写的一些总结并配合官方文档能更速度的了解整个公众号开发。 官方文档 在学习过后，自己也想系统的总结一下，遂有了这篇文章。下面是微信JSSDK使用步骤 1. 在公众号设置js接口安全域名即将你使用的域名在微信公众号设置中绑定安全域名。设置JS接口安全域名后哦，公众号开发者可在该域名下调用微信开放的JS接口 注意事项： 可填写三个域名或路劲，需使用字母、数字及“-”组合，不支持IP地址、端口号及短链域名。 填写的域名必须通过ICP备案的验证 一个自然月内最多可修改并保存3次 可同时绑定3个域名 详情如下面截图： 2. 引入JS文件单页面应用支持以模块化的方式引用，非单页面应用支持在当前页面直接通过script标签的方式引用 安装依赖 npm i -S weixin-js-sdk 引用 import wx from &#39;weixin-js-sdk&#39; 1&lt;script type="text/javascript" src="http://res.wx.qq.com/open/js/jweixin-1.2.0.js"&gt;&lt;/script&gt; 3. 从后台异步获取appId等数据此时会获得以下数据： appId：公众号的唯一标识 timestamp： 生成签名的时间戳 nonceStr：生成签名的随机串 signature：签名 4. 通过config接口注入权限验证配置此处我把config() 、error() 和 ready() 集成到一个方法中，在上一步异步获取数据成功后，执行该方法。 config()方法中的参数即为上一步异步方法获取到的数据，传入即可。 jsApiList参数需要填入你要使用的微信JS接口，此处为`scanQRCode，即【扫一扫】。 1234567891011121314151617181920212223wxConfig( _appid, _timestamp, _nonceStr, _signature) &#123; // 初始化微信api wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: _appid, // 必填，公众号的唯一标识 timestamp: _timestamp, // 必填，生成签名的时间戳 nonceStr: _nonceStr, // 必填，生成签名的随机串 signature: _signature,// 必填，签名，见附录1 jsApiList: ['scanQRCode',] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;); wx.error(function(res) &#123; console.log("初始化出错了：" + res.errMsg);//这个地方的好处就是wx.config配置错误，会弹出窗口哪里错误，然后根据微信文档查询即可。 &#125;); wx.ready(function() &#123; wx.checkJsApi(&#123; jsApiList : ['scanQRCode'], success : function(res) &#123; console.log('初始化扫一扫成功!'); &#125; &#125;); &#125;);&#125; 5. 调起微信扫一扫方法12345678910111213wx.scanQRCode(&#123; desc: 'scanQRCode desc', needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果， scanType: ["qrCode","barCode"], // 可以指定扫二维码还是一维码，默认二者都有 success: function (res) &#123; // 回调 &#125; error: function(res)&#123; if(res.errMsg.indexOf('function_not_exist') &gt; 0)&#123; alert('版本过低请升级') &#125; &#125;&#125;); 6. 结语 以上是以扫一扫为例，做一个大概得总结。调用微信的其他方法大致也一样。欢迎大家转载享用。]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生第一次和第二次事故]]></title>
    <url>%2F2019%2F05%2F15%2F%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%92%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BA%8B%E6%95%85%2F</url>
    <content type="text"><![CDATA[写下文章的日子是5月15日，想起那一天，仍然历历在目~ 从去年5月20日买下车，我几乎天天开车。除了在刚刚开上车的第一个月里，前保险杠被自己蹭了几回，我一直没有出过任何的交通事故。但是，那一天似乎从一开始就不对劲了，仿佛陷入了深渊。 第一起事故——早上 08：28那是2019年5月7日，周二，天气晴朗☀️。早早起床的我如往常一般开车去上班。就在我发动车子开起来不到2分钟，我看到一辆摩托车以并不慢的速度向我“滑”来。那时的他已经摔车了，连人带车一齐向我靠近。 我的车速并不快，不到20/km。但是我也已经反应不过来了，踩死刹车，并下意识向右打方向希望可以躲开。在大概0.01秒之后，我听到了“咚”的一声，摩托车终于还是撞到了。 我收拾心情，拉手刹，挂P挡，熄火，打开双闪。打开车门，看到摩托车骑手（以下简称骑手）正在摘下他的头盔和手套，外表看不到明显伤口，我先询问他伤情如何，回答说没啥大碍。此时摩托车的喇叭可能由于撞击损坏，一直在鸣笛。骑手拜托我把摩托车先熄火，关电门。 现场安静后，我看向摩托车“飞”来的方向，距离20米开外，是一辆还没有完全拐出小区的黑色雅阁。地上是摩托车滑行留下的痕迹。此时骑手已经自己爬起来，一瘸一拐走向路边，看样子他的左腿膝盖或小腿受伤，伤情不明。雅阁车主也下车开始拍照，报警，给保险打电话，在询问骑士伤情后，拨通了120急救热线。 看样子，我好像是躺着中枪了：摩托车由北向南行驶，行驶至小区门口时，恰巧黑色雅阁右拐出小区，摩托车碰撞雅阁左前方后摔倒，并由于惯性继续滑行，在滑行过程中，撞到正在离小区门口20米左右由南向北正常行驶的我。说起倒霉来，这也是算是顶级的了吧。只是当时正在鼓捣电台的我，并没有看到撞击的一幕，当我看到骑手时，他已经离我不到10米远了。 说起电台，说来也奇怪。我每天上班路上都会听广播，那天上车发动后，到摩托车撞到我的这短短2-3分钟之内，电台十分诡异的没有声音，我以为是前一天我把声音调低了，遂转动声音调节旋钮，看到中控屏幕上的声音调节条显示，可是就是没有声音。我又换了几个电台，还是没有声音。开了将近一年，像这样的故障是没有发生过的。可能下回我再碰上电台没声音的情况，我应该会打的上班去。 后续拍张留作证据，大概10分钟后，120到场后送伤者离开。之后继续等待交警到场处理，这一等就是半个小时。不得不说，交警的效率还是真“高”。不过当时是早高峰，路上堵车也可能会延迟交警出警效率。 半个小时后，第一波交警到场（注意：这只是第一波），看样子是个辅警，来了看到有伤者，连忙就叫帮忙的。这个交警当场就宣判黑色雅阁全责，即转弯车辆要避让直行车辆。而雅阁车主当场表示不服，说当时摩托车车速过快，导致自己没有反应时间。遂辅警呼叫第二波交警，继续等待··· 在等待第二波交警期间，骑手朋友赶到现场，并针对事故责任认定与雅阁车主发生多次激烈讨论。我一无辜受伤路人表示很无奈，只得和公司请假，并告诉女朋友大概情况。其余能做的就是继续等待第二波交警处理事故。 继续等了差不多20分钟，第二波交警来了。开着老桑塔纳，从车上下来一个比较“油腻”的交警，光头，体重大约200，脚上一双小花园（即老北京布鞋）。这个交警明显比之前的小辅警专业许多，问了我们三个当事人一些问题，就回车里掏出一把单反，各个角度拍了几张照片后，就通知让挪开车辆了。 之后，“小花园”继续“维持原判”，即黑色雅阁全责，但雅阁车主继续不服。无奈，交警通知把除了我的车之外的两辆事故车辆拖走，第二天让当事人去交警大队处理。由于我只是躺枪的，可以不用去，车也不用被拖走。这也算是这一大早上的结局了。 我的车前保险杠中网被撞烂，保险杠下方衬板被撞出。受损情况轻微。 第二起事故——下午 16：38真的以为自己倒霉的一天就这样结束了？ NO NO NO ! 生活可是比电影精彩多了。无论你在银幕上看到再离奇、再巧合、再不可思议的画面，请一定不要怀疑，某一天，相同的巧合可能会发生在自己的身上。😐 上午处理完之后，时间大概来到10：50分。把车停到停车场后，便和女朋友去吃午饭。吃完饭便和女朋友出去办事。当时她便劝我最好不要开车去，倔强的我是个不相信这些东西的人，执意还是上了车。此时此刻的我十分笃定的劝告大家：一定要听自己女朋友的话！！！ 而继续上车后，广播竟也毫无意外的继续响了起来~~😕 时间来到下午16：38分，我的车行驶在坞城南路和晋阳街交叉口上，女朋友坐在副驾驶。等右拐过这个路口，再行驶不到1KM就到家了。不幸再次发生。 在我右拐行驶到一半左右，因为人行横道有行人通过，我便刹车礼让，而这时后面一辆白色奔驰直挺挺撞了上来。我被追尾了。😟 当时的我出奇地平静，心想：早上才学到一些处理事故的心得，下午就让我实际演练了，还真是及时呀！女朋友则被这突如其来的事故吓得不轻🌹，倒不是因为她胆子小，而是撞击力度确实大，我猜想奔驰车主应该都没有踩刹车，甚至有可能脚还在油门上。 下车后，我“熟练地”掏出手机拍照。这回可是学会了，近处的、远处的、碰撞细节的、车牌信息的，统统存进了我的相册。 对面一身名牌的车主倒也不差，通知保险、报警、拍照一气呵成。等取证完毕之后，我便建议将车脱离事故现场。但是在开车的时候，并没有那么简单。我的后保险杠和奔驰的前保险杠紧紧地钳在了一起，从这儿也能看出来，当时的撞击力度还是很大的。踩了几次油门都没有分开，为了防止两辆车的保险杠继续破损，我们打算等到交警来了之后再挪开。 这次交警来的倒是很及时，不过也是两波。第一位交警来了之后，询问我们是在过了斑马线出的事故还没过斑马线出的事故。原来，过了斑马线就不归人家2大队管了，我们只能继续等到1大队的交警到场。😔🚓 在等待期间，来了两位“不速之客”。一位是奔驰4S店的员工，另一位是大众4S店的员工。原来两位员工在路上看到一辆奔驰和一辆大众追尾，都过来想招揽生意。无奈又想笑。车坏了就得修嘛，要是去他们的4S店修车，他们也是会有提成的！学习了！😆 后来又在那位奔驰4S店员工的催促下，我们两个成功把车分开了。因为各自的保险杠本来就报废了，拉坏了也没事了。 又等了5-10分钟后，1大队的交警到场。由于我们已经驶离了事故现场，所以交警拿过去我们的手机，通过照片来判定责任。现场都是使用手机进行办公： 通过现场照片判定责任 通过车牌号查询到我和奔驰车主的信息，并与车主本人核对 在手机上填写事故责任认定书。上传事故照片，并给2个当事人分别发送验证码，如果当事人无异议，将验证码告知交警，后者便可当场开出责任认定书，并上传至交警支队系统内。 全程没有超过10分钟。当下我便可以在12123手机App上看到开出的责任认定书，内容包括双方车主个人信息、责任认定结果、现场照片等信息。很不错！👍 事故总结 开车要认真。就是很认真的开车都可能会飞来横祸。 出事故后，第一时间拍照。照片内容包括：📷 碰撞细节 在远处拍，把所有事故车辆和道路标线都拍进去 多个角度 每辆车的车牌号特写 如果你是事故责任方（很明显的如：你追尾他人车辆） 下车查看是否有人员伤亡，如有人员伤亡，立即打120 联系自己车辆保险公司，进行报案：告知出事地点，会有出险人员来现场进行确认和勘验。这个关系到之后的理赔事项，切记，切记。 根据现场情况，与其他事故当事人协商处理意见（私了或者报警，我目前接触到的都是报警） 拍照留存证据 协商后，转移事故车辆。 如果你不是事故责任方（比如就像我上面的两起事故） 和上述步骤相同。如果很明确不是自己的责任，不用通知自己的保险公司，只需配合交警或和当事人进行协商处理即可。 必须和对方的出险人员进行有效沟通，留下电话。因为你之后去4S店修车的时候会用到 与责任方协商修车期间的用车问题。如：报销打车费用或租车费用等事项。当场说清楚。 在责任认定后，去4S店修车时，招待你的店员会找你要负责这个事故的出险员的电话，你只需提供即可。4S店会自行和保险公司沟通修车费用，不用你操心。你只需要等4S店的员工给你打电话取车就好。修车时间根据车辆损坏情况而定。 后续 5月7日，两起事故。早上的事故责任当时没定下来。下午的白色奔驰全责。 5月8日，我上班没开车。当天中午的时候，前天早上那起事故责任认定书下来，黑色雅阁全责。 选择修车的4S店，最后选择离公司比较近的一家。开车10分钟。 5月9日，开车上班，午休时间把车开到4S店。将信息留好，4S店通过我联系两家保险的出险员。最后给我一张单子，车修好后通过这张单子取车。 5月9日 — 5月12日，修车，我打车上下班。保存好打车发票。滴滴可直接导出电子发票，也可邮寄纸质发票，超过200免邮费，且需要等待。 5月12日下午，取车。到4S店后，检查车辆维修情况。我检查了小15分钟，没问题后将上述的单子给到4S店工作人员，开车回家。（此处需要说明：由于我这两次事故的损伤都是外伤，前保险杠和后保险杠，没有伤到核心的包括发动机在内的物件，所以我才单枪匹马去取车。如果伤的比较严重的话，建议找一个有经验的人一起） 5月13日，整理修车期间的打车发票，包括打表出租车的纸质发票和滴滴的电子发票。拍照发给事故责任车主，到账150元打车费。💰 结语总得来说，这次的经历还是很刺激的。虽然我不是很喜欢这样的“刺激”，但是确实学习到了很多关于事故处理的流程和需要注意的细节。也让我更加注意行车安全。 后期事故处理、车辆维修、打车费报销也都还算顺利。不到一周就把事情都解决了，此事也算告一段落了。 最后，也提醒广大司机朋友： 道路千万条，安全第一条。行车不规范，亲人两行泪。]]></content>
      <categories>
        <category>行车日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[车辆保险小记]]></title>
    <url>%2F2019%2F05%2F15%2F%E8%BD%A6%E8%BE%86%E4%BF%9D%E9%99%A9%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[现在我们在买车的时候，4S店一般都会强制在他的店里让你买保险，而且又是新车，大部分人都会买全险比较稳妥。所以第一年的保险你大可丢给4S店来帮你办理，你只需要付钱就好。 可是到了第二年，你的保险即将到期，需要续保了，那就只能自己动手查询和办理了。 以下是办理保险业务时需要注意的点，以及一些概念的解读，动手做个记录。 1. 在什么时候可以续保 目前绝大部分地区可提前90天续保 广东地区可提前30天保 2. 可以在哪里续保车险？线上： 平安、人保、太平洋等保险公司的直营网站 车车车险、支付宝、小米金融等第三方车险平台 线下： 保险公司的线下营业点 4S店、洗车店、养车店等代理点 车险代理公司或代理人 在购买车险的时候，可以货比三家，选出最适合的购买渠道。 3. 保险种类1. 交强险6座以下家用车，每年交强险保费为 950元/年 。出险次数对交强险的影响浮动范围： 上一个年度未发生有责任道路交通事故 -10% 上两个年度未发生有责任道路交通事故 -20% 上三个及以上年度未发生有责任道路交通事故 -30% 上一个年度发生一次有责任不涉及死亡的道路交通事故 0% 上一个年度发生两次及两次以上有责任道路交通事故 10% 上一个年度发生有责任道路交通死亡事故 30% 2. 商业险出险次数主要影响NCD系数。第二年没出险，第三年在不考虑其他影响因素的情况下，系数变为0.85。 NCD系数 保险费用浮动 3年无赔 0.60 2年无赔 0.70 1年无赔 0.85 上年1次 1.00 上年2次 1.25 上年3次 1.50 上年4次 1.75 上年5次及以上 2.00 4. 如何购买车险通常来说，我们建议购买的险种，为如下4种，除此之外，可以根据自身情况，再适当添加一些适合自己的险种。 1. 交强险（国家强制）：强制买，赔别人。交强险价格并不高，6座以下私家车一年只要950元。 但是交强险，就相当于我们平常缴纳的社保一样。 价格不贵，但不可能完全报销。 因此我们建议，不要仅买交强险，最好同时搭配一些商业险，让用车更有保障。 交强险赔付金额表格 赔偿项目 有责 无责 医疗费用 1万 1000元 死亡伤残赔偿 11万 1.1万 财产损失赔偿 2000元 100元 合计 12.2万 1.21万 2. 车损险： 赔自己车车损险的全称为”机动车损失保险”，顾名思义，自己的车因为交通事故、意外导致的损失，是由这个险种负责的。 3. 三者险：赔他人三者险的全称为”机动车第三者责任保险”，不小心撞了别人的车，到撞了路边老大爷，都是由这个险种负责的。 4. 不计免赔险：填坑的说到这个险种，就不得不提一个概念，就是免赔率。交通事故中，包括三者险在内的商业险会依照事故划分，有一定的免赔率，次责为最低，5%，全责为最高，20%。不计免赔率负责的，就是把这个免赔率的坑填上。 5. 其他险种根据实际需要购买 座位险，建议需要经常载好友同事的私家车，以及运营车辆购买 涉水险，建议南方地区的车主购买 自燃险，建议使用了三五年以上的老车购买 5. 小刮小蹭不建议用车险我们都知道，自从车险费改之后，我们明年的车险保费，是跟你的车险出险次数挂钩的。 因此一旦发生小刮小蹭，可能修车费用也就两三百元，但明年涨的保费，可能就得上千元了，非常不划算。 但真碰到了撞伤人，或者怼了豪车的情况，大大方方走车险，不用担心你的保费了~ 不过需要注意的是，商业险和交强险的浮动系数是分开来算的。 哪些是车主该买的车险？ - 保瓶儿的回答 - 知乎]]></content>
      <categories>
        <category>行车日常</category>
      </categories>
      <tags>
        <tag>车辆保险</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组高级操作（上）]]></title>
    <url>%2F2019%2F04%2F08%2FJS%E6%95%B0%E7%BB%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[转载自 JS面试之数组的几个不low操作(3) ，点击查看原文 1. 数组扁平化 高级操作 12var arr1 = [1,2,3,[4,5,[6,7,8]]]var arr_1 = arr1.flat(Infinity) 常规操作：利用递归和数组合并方法 concat实现扁平。 123456function flatten(arr) &#123; while(arr.some(item=&gt;Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 2. 去重 高级操作（两种方法） 12var arr1 = [1,2,3,3]arr_1 = [...new Set(arr1)] 1234var arr1 = [1,2,3,3]arr_1 = Array.from( new Set(arr1)) Array.from() 可以将类数组转换为数组，类数组包括但又不限于 Set/ Map，还有包括可遍历的对象。 Set 是ES6提供的新的数据结构，Set对象不是数组， 可以用来保存对象或者基本类型， 所有保存的值都是唯一的。这也就是我们要使用这一特性，实现去重。 常规操作 12345678910111213function distinct(arr) &#123; let resule = [], i, j; for (i = 0; i &lt; arr.length; i++) &#123; for (j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] === arr[j])&#123; j = ++i &#125; &#125; resule.push(arr[i]) &#125; return resule&#125; 3. 排序 高级操作 12var arr1 = [1,2,4,3,8,5]arr1.sort() //升序 12var arr1 = [1,2,4,3,8,5]arr1.sort((a, b) =&gt; b - a) //降序 常规操作 选择排序： 1234567891011function sortFun(arr) &#123; // 选择排序 let i, j; for (i = 0; i &lt; arr.length; i++) &#123; for (j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] &lt; arr[j])&#123; [arr[i], arr[j]] = [arr[j], arr[i]] &#125; &#125; &#125; return arr&#125; 冒泡排序： 1234567891011function bubleSort(arr) &#123; //冒泡排序 let i, j; for (i = arr.length-1; i &gt; 2; i--) &#123; for (j = 0; j &lt; i; j++) &#123; if(arr[i] &gt; arr[j])&#123; [arr[i], arr[j]] = [arr[j], arr[i]] &#125; &#125; &#125; return arr&#125; 4. 最大值、最小值 高级操作 123var arr1 = [1,2,4,3,8,5]Math.max(...arr1)Math.min(...arr1) Math.max() 方法可返回两个指定的数中带有较大的值的那个数 12345var arr1 = [1,2,4,3,8,5]arr1.reduce((prev, cur, curIndex, arr) =&gt; &#123; return Math.max(prev,cur); //return Math.min(prev,cur);&#125;) 常规操作： 先排序，再取最大/最小值。 5. 求和 高级操作 123arr1.reduce((prev, cur, curIndex, arr) =&gt; &#123; return prev + cur&#125;) 常规操作 1234567function sumFun(arr)&#123; let sum = 0, i; for (i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum&#125; 转载自 JS面试之数组的几个不low操作(3) ，点击查看原文]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS数组高级操作（下）]]></title>
    <url>%2F2019%2F04%2F08%2FJS%E6%95%B0%E7%BB%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[转载自 JS面试之数组的几个不low操作(3) ，点击查看原文 1. 合并 高级操作 123var arr1 = [1,2,3,4]var arr2 = [5,6,7,8]arr1.concat(arr2) 1[...arr1,...arr2] 常规操作 12345var arr1 = [1,2,3,4]var arr2 = [5,6,7,8]arr2.forEach(item =&gt; &#123; arr1.push(item)&#125;) 2. 判断是否包含值 高级操作 12var arr1 = [1,2,3,4]arr1.includes(1) // true 或 false 12var arr1 = [1,2,3,4]arr1.indexOf(0) // 该元素在数组内的位置 或者 -1 12var arr1 = [1,2,3,4]arr1.find((item) =&gt; item === 1) //返回该元素 或者 undefined 12var arr1 = [1,2,3,4]arr1.findIndex((item) =&gt; item === 1) //返回该元素所在位置 或者 -1 常规操作 1234arr1.some(item =&gt; &#123; return item === 0&#125;)//返回true 或者 false 3. 类数组转换 高级操作 1234Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)Array.prototype.slice.apply(arguments)Array.from(arguments)[...arguments] 类数组：表示有length属性,但是不具备数组的方法call,apply：是改变slice里面的this指向arguments,所以arguments也可调用数组的方法Array.from是将类似数组或可迭代对象创建为数组...是将类数组扩展为字符串,再定义为数组 常规操作 123456789Array.prototype.slice = function(start,end)&#123; var result = new Array(); start = start || 0; end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 for(var i = start; i &lt; end; i++)&#123; result.push(this[i]); &#125; return result; &#125; 4. 每一项设置值 高级操作 12var arr1 = [1,2,3,4]arr1.fill('1') //["1", "1", "1", "1"] fill() 方法用于将一个固定值替换数组的元素，是ES6新增的方法 array.fill(value, start, end) 参数 说明 value 必需。要填充的值 start 可选。开始填充位置。 end 可选。停止填充位置 (默认为 array.length) 常规操作 12var arr1 = [1,2,3,4]arr1.map(() =&gt; '1') //["1", "1", "1", "1"] 5. 每一项是否满足1234var arr1 = [1,2,3,4]arr1.every(item =&gt; &#123; return item &gt; 0&#125; //true 6. 有一项满足1234var arr1 = [1,2,3,4]arr1.some(item =&gt; &#123; return item &gt; 4&#125; //false 7. 过滤数组1234var arr1 = [1,2,3,4]arr1.filter(item =&gt; &#123; return item &gt; 2&#125; //[3, 4] filter() 是ES5的api，返回满足添加的项的数组。 8. 对象和数组的转换1234var obj = &#123; name: '张三', age: '12'&#125; Object.keys() 1Object.keys(obj) // ["name", "age"] Object.values() 1Object.values(obj) // ["张三", "12"] Object.entries() 1Object.entries(obj) //[[name,'张三'],[age,12]] 9. 对象转换为数组1234567891011121314var obj = &#123; name: '张三', age: '12'&#125;for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; let obj_ = &#123;&#125; obj_[key] = obj[key] arr.push(obj_) &#125;&#125;console.log(arr); // [&#123;name: '张三'&#125;, &#123;age: '12&#125;] 转载自 JS面试之数组的几个不low操作(3) ，点击查看原文]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PC端图片预览——galpop.js]]></title>
    <url>%2F2019%2F04%2F04%2FPC%E7%AB%AF%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E2%80%94%E2%80%94galpop.js%2F</url>
    <content type="text"><![CDATA[之前在项目中使用过一个基于 jquery 的图片预览插件—— jquery.galpop.js，甚是好用。并对它念念不忘🎈🎈🎈。今天来回顾一下，并总结一点使用方法。 1. 介绍该插件由Richard Hung制作，Github地址，官方介绍及使用教程。 2. 可选参数 参数 默认值 可选值 描述 arrowKeys true true/false 使用键盘左箭头键和右箭头键。Esc关闭。 controls true true/false 显示next / prev控制箭头 loop true true/false 允许循环回到开始 maxWidth null integer 宽度的最大像素量 maxHeight null integer 高度的最大像素量 maxScreen 90 integer 屏幕大小的最大百分比（覆盖maxWidth和maxHeight） updateRsz true true/false 更新窗口大小 callback null Function 函数在每个面板完成后运行 lockScroll true true/false 当弹出窗口打开时，防止浏览器滚动 contentType image image, AJAX, iframe 要在弹出框中打开的内容类型 AJAXContainer null jQuery selector 要查找并加载到弹出框中的HTML元素 123456$(function () &#123; $('.className').galpop(&#123; arrowKeys: false, loop: false &#125;);&#125;) 3. &lt;a&gt; 标签上使用的参数（准备接受杨超越地洗礼吧）😆😆😆 title 代码: 123&lt;a href="..." title="杨超越"&gt; &lt;img src="..."/&gt;&lt;/a&gt; 效果: data-galpop-link 代码: 123&lt;a href="..." title="杨超越" data-galpop-link="http://www.baidu.com"&gt; &lt;img src="..."/&gt;&lt;/a&gt; 效果: data-galpop-link-title 代码: 123&lt;a href="..." title="杨超越" data-galpop-link="http://www.baidu.com" data-galpop-link-title="百度链接"&gt; &lt;img src="..."/&gt;&lt;/a&gt; 效果: data-galpop-link-target 加上该属性后，锚点中的页面将会在新的页面打开。 代码: 123&lt;a href="..." title="杨超越" data-galpop-link="http://www.baidu.com" data-galpop-link-title="百度链接" data-galpop-link-target="http://www.baidu.com"&gt; &lt;img src="..."/&gt;&lt;/a&gt; 4. 使用示例因为是基于 jquery 制作的插件，在使用时需要引入 jquery.js 。此外还需要引入该插件的 js/ css 文件。 1. 预览单个图片12345678&lt;a href="https://s2.ax1x.com/2019/03/13/AkieC6.md.jpg" class="galpop" title="图片1"&gt; &lt;img src="https://s2.ax1x.com/2019/03/13/AkieC6.md.jpg" alt="图片1" /&gt;&lt;/a&gt;&lt;script&gt; $(function () &#123; $('.galpop').galpop(); &#125;)&lt;/script&gt; 2. 预览多张图片需要在 &lt;a&gt; 标签上添加 data-galpop-group=&quot;&quot; 属性，图片左右两侧会出现箭头，点击浏览上一张或下一张。 123456789101112&lt;a href="https://s2.ax1x.com/2019/03/13/AkieC6.md.jpg" class="galpop-multiple" data-galpop-group="multiple" title="图片1"&gt; &lt;img src="https://s2.ax1x.com/2019/03/13/AkieC6.md.jpg" alt="图片1" /&gt;&lt;/a&gt;&lt;a href="https://s2.ax1x.com/2019/03/13/Akim8K.md.jpg" class="galpop-multiple" data-galpop-group="multiple" title="图片2"&gt; &lt;img src="https://s2.ax1x.com/2019/03/13/Akim8K.md.jpg" alt="图片2" /&gt;&lt;/a&gt;&lt;script&gt; $(function () &#123; $('.galpop-multiple').galpop(); &#125;)&lt;/script&gt; 3. 回调函数1234567891011121314151617$(function () &#123; $('.galpop-multiple').galpop(&#123; callback: callback &#125;); function callback() &#123; var wrapper = $('#galpop-wrapper'); // 图片的包裹区域 var info = $('#galpop-info'); // 图片左下角的信息展示区域 var count = wrapper.data('count'); // 图片总数 var index = wrapper.data('index') + 1; //当前正在浏览第几个 var string = index +' / '+ count; info.append('&lt;p&gt;'+ string +'&lt;/p&gt;').fadeIn(); &#125;&#125;) 效果: 4. 手动打开一张图片使用 openBox() 方法，可以传入参数对象，当然也可以加入回调函数。 12345678910&lt;button class="openAImage"&gt;手动打开一张图片&lt;/button&gt;$('.openAImage').click(function (e) &#123; var params = &#123; maxWidth: 200, callback: function() &#123; console.log('手动打开回调函数'); &#125; &#125; $.fn.galpop('openBox', params,'https://s2.ax1x.com/2019/03/13/AkieC6.md.jpg')&#125;) 5. 手动打开多张图片和手动打开一张图片同样使用 openBox() 方法，只不过之前的方法中传入的是一个图片的URL，现在需要由多个图片URL组成的数组，其他参数不变。 1234567891011121314&lt;button class="openAImage"&gt;手动打开一组图片&lt;/button&gt;var imgs = [ 'https://s2.ax1x.com/2019/03/13/AkieC6.md.jpg', 'https://s2.ax1x.com/2019/03/13/Akim8K.md.jpg']$('.openAImage').click(function (e) &#123; var params = &#123; maxWidth: 200, callback: function() &#123; console.log('手动打开回调函数'); &#125; &#125; $.fn.galpop('openBox', params, imgs)&#125;) 6. 打开一个iframe页面1234567&lt;a href="./iframe.html" class="click-open-iframe"&gt;点击打开iframe&lt;/a&gt;&lt;script&gt; $('.click-open-iframe').galpop(&#123; contentType: 'iframe', &#125;)&lt;/script&gt; 效果我就不演示了，总感觉不是特别实用。😏 5. 结语⛳⛳⛳ 首先感谢大家能读到这里，不胜感激！！！🤗 以上就是关于该插件的简单介绍和使用方法，以及对其参数的解读和实例，希望能帮到有需要的人。如果有不准确的地方，欢迎在下方评论中指正。😉]]></content>
      <categories>
        <category>jquery插件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用伪类来实现类似微信群聊的头像样式]]></title>
    <url>%2F2019%2F03%2F15%2F%E4%BD%BF%E7%94%A8%E4%BC%AA%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E7%BE%A4%E8%81%8A%E7%9A%84%E5%A4%B4%E5%83%8F%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近看了一篇张鑫旭的博客，觉得人家的想法特别奇特，很值得学习。遂借鉴学习并记录一下，以备不时之需。 原文地址：伪类匹配列表数目实现微信群头像CSS布局的技巧 1. 简介我们在使用微信群聊的时候，群聊的头像，是所在在群聊中的人的头像的一个组合。随着群聊成员数量的不同，群聊头像的样式也不一样。下面就是使用伪类来实现这样一个功能，让其样式随着数量的变化而变化。 2. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697ul&#123; padding: 0; margin: 0; list-style-type: none; width: 240px; height: 240px; background-color: #eee;&#125;li &#123; background: url(https://s2.ax1x.com/2019/03/13/AkieC6.jpg); background-size: 100%; outline: 1px solid #fff;&#125;button&#123; margin-top: 20px;&#125;/* 1个 */li:only-child &#123; height: 100%;&#125;/* 2个 */li:first-child:nth-last-child(2), li:first-child:nth-last-child(2) + li&#123; width: 50%; height: 50%; &#125;li:first-child:nth-last-child(2) + li&#123; margin-left: auto;&#125;/* 3个 */li:first-child:nth-last-child(3), li:first-child:nth-last-child(3) ~ li&#123; width: 50%; height: 50%; float: left; &#125;li:first-child:nth-last-child(3)&#123; margin-left: 25%;&#125;/* 4个 */li:first-child:nth-last-child(4), li:first-child:nth-last-child(4) ~ li &#123; width: 50%; height: 50%; float: left; &#125;/* 5个 */li:first-child:nth-last-child(5)&#123; width: 160px; height: 160px; float: left;&#125;li:first-child:nth-last-child(5) ~ li &#123; width: 80px; height: 80px; float: left;&#125;/* 6个 */li:first-child:nth-last-child(6)&#123; width: 160px; height: 160px; float: left;&#125;li:first-child:nth-last-child(6) ~ li &#123; width: 80px; height: 80px; float: left;&#125;/* 7个 */li:first-child:nth-last-child(7)&#123; width: 80px; height: 80px; margin: auto;&#125;li:first-child:nth-last-child(7) ~ li &#123; width: 80px; height: 80px; float: left;&#125;/* 8个 */li:first-child:nth-last-child(8)&#123; width: 80px; height: 80px; margin-left: 40px; float: left;&#125;li:first-child:nth-last-child(8) ~ li &#123; width: 80px; height: 80px; float: left;&#125;/* 9个 */li:first-child:nth-last-child(9), li:first-child:nth-last-child(9) ~ li &#123; width: 80px; height: 80px; float: left; &#125;&lt;/style&gt; 3. 实现效果： 原文地址：伪类匹配列表数目实现微信群头像CSS布局的技巧]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近随想]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%9C%80%E8%BF%91%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[最近几日，公司不是特别的忙。年后又经历了半个月的奋斗，【跨境电商】第二版终于是又上线了，好在我在年前就已经把重要的工作处理的差不多了，所以年后的这半个多月，也并没有怎么加班，因为有了的第一版的经验，项目上线还算是顺遂。只是后台的系统换了技术，我转而来开发【投放页面】，因为页面比较少，以我的技术，完成起来还是比较顺手的，没有特别大的难题，所以也就成全了我最近的空闲。 这也算是我的博客中的第一篇“随想”类的文章。姑且先写写吧，好久没写，估计会“退化”吧。 今天是周三，从这个周一开始，我每天中午午休的时候，会先睡一觉。公司的午休时间是11:30 -13:00一个半小时。之前我都是在11:30下楼去吃饭，然后上楼娱乐，最后睡觉，睡个大概20分钟。现在我会先从11:30分开始睡，睡到12：30左右，然后下楼吃饭。 每次睡起来都特别精神，以弥补晚上睡不够的情况。觉得还挺好，既能多睡一会儿，还能省去中午吃饭人多拥挤的问题。打算先这样实施一阵子。 下面这张图是我今天睡起来拍的，公司的天花板。 很羡慕那些可以很轻松地把自己心里想的能很完整的写出来的人，自己也想【进化】到那种级别。看来最好的办法就是多写，多阅读。 昨天看了一部动画片——《李献计历险记》，第一个感触就是节奏流畅、画风奇特、配音清奇，尤其是画外音，让人听着“蠢蠢欲动”，很有感觉的一部动画片。 这不动画片09年上映的，直到现在我才完整的看完。这样说的原因是我在17年的时候，曾经在北京的办公室里午休的时候，打算一睹这个被好多网友誉为“他们看过的最好看”的动画片，可惜只看了个开头，便草草收尾了。昨天晚上已经躺床上了，忽然就想了起来，就打开手机看，还是和在北京一样，短短20分钟的片长，看到2/3的时候，就睡着了。剩下的部分第二天看的。 看完第一次之后，发现自己并没有太看懂。只是知道主人公想通过打通关一个游戏，用来穿越回到过去，找自己已经分手的女朋友复合。影片讲了主角在为了打通关的过程中，做了好多事情。如：请日本的一位“游戏怪才”来帮助自己打通关、购买兴奋剂来更好的“操控游戏”、把自己的手指打造成钢铁来更好的操控游戏手柄。 为了购买兴奋剂需要筹集50万，主人给不惜给本拉登送我们的国宝，又给美国人当双面间谍，凡此种种。这就是我第一次看到的。心里想，这也么啥呀，无非故事讲的很流畅，画面很优美，配音很动感（在打本拉登的时候，配音是《黄河大合唱》）。 怀着疑惑的心情，我又开始看第二遍。想从那些一闪而过画面里以及到满嘴京味儿的旁白中get到点啥。恕我愚钝，在看到一半的时候，还是没有想到点啥，于是最终求助于广大网友，让他们先解释一波。 以下是我看过各大网友后的感悟： 该电影是由导演李阳自己制作的，历时两年。 我们现实中的每个人在年轻的时候，都患有电影中的差时症。 电影中的主人公想要回到过去，想找的其实并不是他的女朋友王倩，而是他的初心 就像很多不谙世事的年轻男孩子一样，他们中很多都幻想着拯救世界，可以凭着一己之力，达到和别人不一样的成就。无奈随着自己年龄的长大，社会经验的丰富，我们都逐渐成为了漫漫人海中的一员——我们没有那么的与众不同。我们都随着年龄的增长，差时症也慢慢痊愈了。 我也忽然明白，为什么那么多人对这个电影如此推崇，那是因为他们都从这个电影里看到了自己的影子——我也不例外。 昨天晚上做了一个梦，我很久没有做如此疯狂的梦了。甚至已经很久都没有做梦了。梦里的事情我已经忘的一干二净了，只是记得，梦里的我很年轻，也是长枪短炮，飞天遁地，做着像李献计一样的事情。 借用郭德纲的一句话做结尾吧： 那一夜，我也曾梦见百万雄兵。 《李献计历险记》影评]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue通过$router.push传参数]]></title>
    <url>%2F2018%2F11%2F28%2Fvue%E9%80%9A%E8%BF%87%24router.push%E4%BC%A0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 举例下面通过A页面向B页面传值来举个例子: 123456789//A页面: this.$router.push(&#123; name: '页面B', params: &#123; data: '我是要传递的参数' &#125;&#125;)//B页面拿到传来的值: this.data = this.$route.params.data // 拿到上个页面传来的数据 2. 要注意的地方代码很简单, 以下是需要注意的几点： this.$router.push()方法里的params 可以传多个参数, 如: 123456789//A页面this.$router.push(&#123; name: '页面B', params: &#123; data1: '参数1', data2: '参数2'&#125;&#125;)//B页面, 拿到传来的参数this.data1 = this.$route.params.data1this.data2 = this.$route.params.data2 this.$router.push()方法除了可以传递一般参数以外, 还能传递查询参数,代码如下: 1this.$router.push(&#123;path: '/pagePath', query: &#123;queryData: "2"&#125;&#125;); 最终的效果是: /pagePath?queryData=2 3. 结语以上只是一个简单的总结，之后还会继续书写与总结。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚线-渐变-边框的实现]]></title>
    <url>%2F2018%2F11%2F14%2F%E8%99%9A%E7%BA%BF-%E6%B8%90%E5%8F%98-%E8%BE%B9%E6%A1%86%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[转自：张鑫旭的博客 实现虚线-渐变-边框有以下两种方法 第一种方法： 反向镂空代码如下： 123&lt;div class="box"&gt; &lt;div class="content"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.box &#123; width: 150px; border: 2px dashed #fff; background: linear-gradient(to bottom, #ff1481, #ff5d3e); background-origin: border-box;&#125;.content &#123; height: 100px; background-color: #fff;&#125; 效果如下: 问题：IE10+都能用，但是不能实现直角的边框，所以实用性堪忧。如果设计师对此要求不高，且正好要圆角边框，就可以直接拿来用了。 第二种方法： 借助CSS遮罩代码如下： 1&lt;div class="box"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627.box &#123; width: 200px; height: 150px; border: 2px dashed #ff5d3e; box-sizing: border-box;&#125;@supports (-webkit-mask: none) or (mask: none) &#123; .box &#123; border: none; background: linear-gradient(to bottom, #ff1481, #ff5d3e) no-repeat; -webkit-mask-image: linear-gradient(to right, #000 6px, transparent 6px), linear-gradient(to bottom, #000 6px, transparent 6px), linear-gradient(to right, #000 6px, transparent 6px), linear-gradient(to bottom, #000 6px, transparent 6px); -webkit-mask-repeat: repeat-x, repeat-y, repeat-x, repeat-y; -webkit-mask-position: 0 0, 0 0, 0 100%, 100% 0; -webkit-mask-size: 8px 2px, 2px 8px, 8px 2px, 2px 8px; /* 合并写法 */ mask: linear-gradient(to right, #000 6px, transparent 6px) repeat-x, linear-gradient(to bottom, #000 6px, transparent 6px) repeat-y, linear-gradient(to right, #000 6px, transparent 6px) repeat-x 0 100%, linear-gradient(to bottom, #000 6px, transparent 6px) repeat-y 100% 0; mask-size: 8px 2px, 2px 8px, 8px 2px, 2px 8px; &#125;&#125; 效果如下： 转自：张鑫旭的博客]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>虚线-渐变-边框的实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边框滚动动画]]></title>
    <url>%2F2018%2F11%2F14%2F%E8%BE%B9%E6%A1%86%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[转自：张鑫旭的博客 1. 虚线边框滚动动画兼容IE10+ 123&lt;div class="box"&gt; &lt;div class="content"&gt;内容占位&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122 .box &#123; width: 200px; background: repeating-linear-gradient(135deg, transparent, transparent 3px, #000 3px, #000 8px); animation: shine 1s infinite linear; overflow: hidden;&#125;.content &#123; height: 128px; margin: 1px; padding: 10px; background-color: #fff; &#125;@keyframes shine &#123; 0% &#123; background-position: -1px -1px; &#125; 100% &#123; background-position: -12px -12px; &#125;&#125; 点击查看实例效果 2. 实线边框loading动画兼容IE10+ 1&lt;div class="box"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435.box &#123; height: 96px; width: 128px; display: inline-block; padding: 10px; position: relative; text-align: center; &#125; .box::before &#123; content: ''; position: absolute; left: 0; top: 0; right: 0; bottom: 0; border: 2px solid #cd0000; animation: borderAround 1.5s infinite linear; &#125; @keyframes borderAround &#123; 0%, 100% &#123; clip: rect(0 148px 2px 0); &#125; 25% &#123; clip: rect(0 148px 116px 146px); &#125; 50% &#123; clip: rect(114px 148px 116px 0); &#125; 75% &#123; clip: rect(0 2px 116px 0); &#125; &#125; 点击查看实例效果 转自：张鑫旭的博客]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>边框动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mui——复制到剪贴板]]></title>
    <url>%2F2018%2F10%2F12%2Fmui%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[下面是mui中封装的复制到剪贴板的方法，可以直接复制使用。123456789101112131415161718192021222324252627// 复制方法function copy_fun(copy)&#123;//参数copy是要复制的文本内容 mui.plusReady(function()&#123; //判断是安卓还是ios if(mui.os.ios)&#123; //ios var UIPasteboard = plus.ios.importClass("UIPasteboard"); var generalPasteboard = UIPasteboard.generalPasteboard(); //设置/获取文本内容: generalPasteboard.plusCallMethod(&#123; setValue:copy, forPasteboardType: "public.utf8-plain-text" &#125;); generalPasteboard.plusCallMethod(&#123; valueForPasteboardType: "public.utf8-plain-text" &#125;); mui.toast("已成功复制到剪贴板"); &#125;else&#123; //安卓 var context = plus.android.importClass("android.content.Context"); var main = plus.android.runtimeMainActivity(); var clip = main.getSystemService(context.CLIPBOARD_SERVICE); plus.android.invoke(clip,"setText",copy); mui.toast("已成功复制到剪贴板"); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>mui</category>
      </categories>
      <tags>
        <tag>mui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用clipboard.js插件实现复制功能]]></title>
    <url>%2F2018%2F10%2F12%2F%E4%BD%BF%E7%94%A8clipboard.js%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[之前做前端项目时，用到了复制功能，在网上寻找一圈后，找到了Clipboard.js这个插件。在使用之后，顿时感觉十分的方便，支持ie9及以上。 主要有3个主要的属性： data-clipboard-text=&quot;copytext&quot; 自定义复制内容。 data-clipboard-action=&quot;copy&quot; 还可选 cut。 data-clipboard-target=&quot;dom&quot;指向要复制的 dom，可以是 &lt;input&gt; / &lt;textarea&gt;，也可以是 &lt;div&gt; 等其他元素。 示例代码：1. 复制input/textarea框中的内容：html: 12&lt;input id="foo" type="text" value="hello"&gt;&lt;button class="btn" data-clipboard-action="copy" data-clipboard-target="#foo"&gt;Copy&lt;/button&gt; js: 123456789var clipboard = new ClipboardJS('.btn'); clipboard.on('success', function(e) &#123; console.log(e); &#125;); clipboard.on('error', function(e) &#123; console.log(e);&#125;); 2. 复制自定义内容_1（在方法内定义）：12345678910111213141516&lt;button class="btn"&gt;Copy&lt;/button&gt;&lt;script&gt; var clipboard = new ClipboardJS('.btn', &#123; text: function() &#123; return 'to be or not to be'; &#125; &#125;); clipboard.on('success', function(e) &#123; console.log(e); &#125;); clipboard.on('error', function(e) &#123; console.log(e); &#125;);&lt;/script&gt; 3. 自定义复制内容_2（在行内定义）12345678910&lt;button class="btn" data-clipboard-text="1"&gt;Copy&lt;/button&gt;&lt;script&gt; var clipboard = new ClipboardJS('.btn'); clipboard.on('success', function(e) &#123; console.log(e); &#125;); clipboard.on('error', function(e) &#123; console.log(e); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>js插件</category>
      </categories>
      <tags>
        <tag>clipboard.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴fonticon字体图标的使用]]></title>
    <url>%2F2018%2F08%2F17%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4fonticon%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[很早之前就知道阿里巴巴的fonticon矢量图标库，以前是这么使用的：下载某个图标的.png格式，然后引用到项目中，通过img标签或者background来使用。当然我知道该矢量图库可以将图标转换为字体文件来使用，但是一直没有机会来使用。因为大部分时间，设计都会把图标以图片的格式准备好，我只需要做一张雪碧图，就可以很好的使用了。下面来总结一下该字体图标的使用方法。 1. 如何将字体图标下载到本地以图说明（本次下载的是一个多色图标）： 下载到本地后，是一个压缩包，解压之后，会看到下面的文件。 那3个示例网页中得到以下信息： 在使用Unicode引入时，图标的Unicode编码 在使用-class引入时，图标的类名 各种引入方式的简单介绍 2. 怎么在html页面中使用在页面上使用时，有三种引入方式： 1.unicode引入：unicode是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 在刚刚下载下的文件夹中找到iconfont.woff文件，并放到你项目的根目录下。页面中是这样的： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; @font-face &#123; font-family: 'iconfont'; src: url('iconfont.eot'); src: url('iconfont.eot?#iefix') format('embedded-opentype'), url('iconfont.woff') format('woff'), url('iconfont.ttf') format('truetype'), url('iconfont.svg#iconfont') format('svg'); &#125; .iconfont&#123; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale; &#125; i&#123; font-size: 34px !important; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;unicode引入&lt;/h1&gt; &lt;i class="iconfont"&gt;&amp;#xe616;&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; 2.font-class方式：font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题。 与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 在刚刚下载下的文件夹中找到iconfont.css文件，放到你项目的任意位置，并在页面中引入该css文件。页面中是这样的： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;阿里巴巴fonticon字体图标的使用&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="iconfont.css"/&gt; &lt;style type="text/css"&gt; i&#123; font-size: 34px !important; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;font-class引入&lt;/h1&gt; &lt;i class="iconfont icon-bofang-tingzhi-zanting"&gt;&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; 3.symbol方式：这是一种全新的使用方式，应该说这才是未来的主流， 这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点：在刚刚下载下的文件夹中找到iconfont.js文件，放到你项目的任意位置，并在页面中引入该css文件。页面中是这样的： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。 在刚刚下载下的文件夹中找到iconfont.js文件，放到你项目的任意位置，并在页面中引入该js文件。页面中是这样的： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;阿里巴巴fonticon字体图标的使用&lt;/title&gt; &lt;script src="iconfont.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125; svg&#123; font-size: 34px !important; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;symbol引入&lt;/h1&gt; &lt;svg class="icon" aria-hidden="true"&gt; &lt;use xlink:href="#icon-bofang-tingzhi-zanting"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; 3. 总结以上就是使用阿里矢量图库的字体图标的三种方法，除了symbol方式可以直接使用多色图标（也就是一个图标中有多个颜色），其他的两种都不能直接使用。只能使用单色。 总的来说，还是第二种，也就是通过类名来引入更加的方便使用（个人意见）。在切换图标时，可以直接通过更换类名来实现。而且对于现在的我而言，多色图标使用频率较少，大部分时间都是在使用单色图标，就完全可以满足我的需求了。 好了，以上就是一个简单的使用过程，希望能帮到大家。]]></content>
      <categories>
        <category>字体图标</category>
      </categories>
      <tags>
        <tag>fonticon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒计时插件]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%80%92%E8%AE%A1%E6%97%B6%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031// time --&gt; 传入一个时间字符串，格式为：HH:mm:ssfunction timer(time)&#123; var newTime = "" var h = parseInt(time.split(':')[0]) var m = parseInt(time.split(':')[1]) var s = parseInt(time.split(':')[2]) var timers = setInterval(function()&#123; if(s == 0)&#123; s = 60; m--; s--; if(m == 0)&#123; if(h == 0)&#123; &#125;else&#123; m = 59; h--; s--; &#125; &#125; &#125;else&#123; s--; &#125; if(s == 0 &amp;&amp; m==0 &amp;&amp; h==0)&#123; clearInterval(timers) &#125; newTime = addZero(h)+":"+addZero(m)+":"+addZero(s) console.log(newTime) &#125;,1000)&#125; 下面的方法为搭配使用的方法：该方法的作用是：假如“时”、“分”、“秒”中的数字是一位数时，在它之前补零。 123456789function addZero(num)&#123; var num_ = num+''; if(num_.length != 2)&#123; return '0'+num &#125;else&#123; return num &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中常用的正则表达式]]></title>
    <url>%2F2018%2F08%2F14%2FJS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[16进制的HEX色值1/^#[\da-f]&#123;3&#125;([\da-f]&#123;3&#125;)?$/ 0~1之间的小数，不含0和11/0(\.[0-9]&#123;0,2&#125;)/ 姓名1/^[\u4e00-\u9fa5]&#123;1,5&#125;$/ 手机1/^[1][3,4,5,7,8][0-9]&#123;9&#125;$/; 密码1/^[\w_-~!@#$%^&amp;*`./]&#123;6,20&#125;$/ 身份证号1/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/ 邮箱1/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/ 字符串内不包含空格1/^\S*$/]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie8及其以下版本兼容性问题之圆角阴影]]></title>
    <url>%2F2018%2F08%2F07%2Fie8%E5%8F%8A%E5%85%B6%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E4%B9%8B%E5%9C%86%E8%A7%92%E9%98%B4%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[解决办法在http://css3pie.com/页面下载一个PIE.htc的文件，加载到根目录下，然后在css中加上一句behavior:url(../js/PIE.htc); 示例1234567.border_radius &#123; border:1px solid #000; -moz-border-radius:15px; -webkit-border-radius:15px; border-radius:15px; behavior:url(../js/PIE.htc);&#125; 其中文件的路径是相对html的，所以在服务器上最好用绝对路径。 对于有些父元素已经设置了position属性的元素，会出现无法显示的情况，此时可以给元素加上position:relative；如下： 12345678.border_radius &#123; border:1px solid #000; -moz-border-radius:15px; -webkit-border-radius:15px; border-radius:15px; position:relative; behavior:url(../js/PIE.htc);&#125; 也可以将元素的z-index值设大一些。如果元素不能显示，可以考虑给其父级元素设置定位属性。 使用css3的box-shadow属性时，也在样式中添加behavior:url(../js/PIE.htc);即可。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>ie8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue v-model的深入理解]]></title>
    <url>%2F2018%2F08%2F04%2FVue%20v-model%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 概念v-model：主要是针对表单来使用的 2. 基础用法你可以用v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。 3. 内涵用法12&lt;input v-model="demo" /&gt;&lt;input v-bind:value="demo" v-on:input="demo= $event.target.value" /&gt; 以上的代码中，第一行的代码只是第二行的代码的语法糖。第二行代码中将value值绑定到demo上，并监听输入动作，输入改变时，将新的value值传输给demo。第二行中的代码还可以简写成如下： 1&lt;input :value="demo" @input="demo = $event.target.value" /&gt; 4. 结语以上是在学习Vue过程中所学到的基础性的东西，简单记录下来。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将中文文字提取为中文拼音首字母，并实现排序]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%B0%86%E4%B8%AD%E6%96%87%E6%96%87%E5%AD%97%E6%8F%90%E5%8F%96%E4%B8%BA%E4%B8%AD%E6%96%87%E6%8B%BC%E9%9F%B3%E9%A6%96%E5%AD%97%E6%AF%8D%EF%BC%8C%E5%B9%B6%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本文为转载，点击查看原文地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var getPy = (function() &#123; //函数使用,本表收录的字符的Unicode编码范围为19968至40869, XDesigner 整理 var strChineseFirstPY = "YDYQSXMWZSSXJBYMGCCZQPSSQBYCDSCDQLDYLYBSSJGYZZJJFKCCLZDHWDWZJLJPFYYNWJJTMYHZWZHFLZPPQHGSCYYYNJQYXXGJHHSDSJNKKTMOMLCRXYPSNQSECCQZGGLLYJLMYZZSECYKYYHQWJSSGGYXYZYJWWKDJHYCHMYXJTLXJYQBYXZLDWRDJRWYSRLDZJPCBZJJBRCFTLECZSTZFXXZHTRQHYBDLYCZSSYMMRFMYQZPWWJJYFCRWFDFZQPYDDWYXKYJAWJFFXYPSFTZYHHYZYSWCJYXSCLCXXWZZXNBGNNXBXLZSZSBSGPYSYZDHMDZBQBZCWDZZYYTZHBTSYYBZGNTNXQYWQSKBPHHLXGYBFMJEBJHHGQTJCYSXSTKZHLYCKGLYSMZXYALMELDCCXGZYRJXSDLTYZCQKCNNJWHJTZZCQLJSTSTBNXBTYXCEQXGKWJYFLZQLYHYXSPSFXLMPBYSXXXYDJCZYLLLSJXFHJXPJBTFFYABYXBHZZBJYZLWLCZGGBTSSMDTJZXPTHYQTGLJSCQFZKJZJQNLZWLSLHDZBWJNCJZYZSQQYCQYRZCJJWYBRTWPYFTWEXCSKDZCTBZHYZZYYJXZCFFZZMJYXXSDZZOTTBZLQWFCKSZSXFYRLNYJMBDTHJXSQQCCSBXYYTSYFBXDZTGBCNSLCYZZPSAZYZZSCJCSHZQYDXLBPJLLMQXTYDZXSQJTZPXLCGLQTZWJBHCTSYJSFXYEJJTLBGXSXJMYJQQPFZASYJNTYDJXKJCDJSZCBARTDCLYJQMWNQNCLLLKBYBZZSYHQQLTWLCCXTXLLZNTYLNEWYZYXCZXXGRKRMTCNDNJTSYYSSDQDGHSDBJGHRWRQLYBGLXHLGTGXBQJDZPYJSJYJCTMRNYMGRZJCZGJMZMGXMPRYXKJNYMSGMZJYMKMFXMLDTGFBHCJHKYLPFMDXLQJJSMTQGZSJLQDLDGJYCALCMZCSDJLLNXDJFFFFJCZFMZFFPFKHKGDPSXKTACJDHHZDDCRRCFQYJKQCCWJDXHWJLYLLZGCFCQDSMLZPBJJPLSBCJGGDCKKDEZSQCCKJGCGKDJTJDLZYCXKLQSCGJCLTFPCQCZGWPJDQYZJJBYJHSJDZWGFSJGZKQCCZLLPSPKJGQJHZZLJPLGJGJJTHJJYJZCZMLZLYQBGJWMLJKXZDZNJQSYZMLJLLJKYWXMKJLHSKJGBMCLYYMKXJQLBMLLKMDXXKWYXYSLMLPSJQQJQXYXFJTJDXMXXLLCXQBSYJBGWYMBGGBCYXPJYGPEPFGDJGBHBNSQJYZJKJKHXQFGQZKFHYGKHDKLLSDJQXPQYKYBNQSXQNSZSWHBSXWHXWBZZXDMNSJBSBKBBZKLYLXGWXDRWYQZMYWSJQLCJXXJXKJEQXSCYETLZHLYYYSDZPAQYZCMTLSHTZCFYZYXYLJSDCJQAGYSLCQLYYYSHMRQQKLDXZSCSSSYDYCJYSFSJBFRSSZQSBXXPXJYSDRCKGJLGDKZJZBDKTCSYQPYHSTCLDJDHMXMCGXYZHJDDTMHLTXZXYLYMOHYJCLTYFBQQXPFBDFHHTKSQHZYYWCNXXCRWHOWGYJLEGWDQCWGFJYCSNTMYTOLBYGWQWESJPWNMLRYDZSZTXYQPZGCWXHNGPYXSHMYQJXZTDPPBFYHZHTJYFDZWKGKZBLDNTSXHQEEGZZYLZMMZYJZGXZXKHKSTXNXXWYLYAPSTHXDWHZYMPXAGKYDXBHNHXKDPJNMYHYLPMGOCSLNZHKXXLPZZLBMLSFBHHGYGYYGGBHSCYAQTYWLXTZQCEZYDQDQMMHTKLLSZHLSJZWFYHQSWSCWLQAZYNYTLSXTHAZNKZZSZZLAXXZWWCTGQQTDDYZTCCHYQZFLXPSLZYGPZSZNGLNDQTBDLXGTCTAJDKYWNSYZLJHHZZCWNYYZYWMHYCHHYXHJKZWSXHZYXLYSKQYSPSLYZWMYPPKBYGLKZHTYXAXQSYSHXASMCHKDSCRSWJPWXSGZJLWWSCHSJHSQNHCSEGNDAQTBAALZZMSSTDQJCJKTSCJAXPLGGXHHGXXZCXPDMMHLDGTYBYSJMXHMRCPXXJZCKZXSHMLQXXTTHXWZFKHCCZDYTCJYXQHLXDHYPJQXYLSYYDZOZJNYXQEZYSQYAYXWYPDGXDDXSPPYZNDLTWRHXYDXZZJHTCXMCZLHPYYYYMHZLLHNXMYLLLMDCPPXHMXDKYCYRDLTXJCHHZZXZLCCLYLNZSHZJZZLNNRLWHYQSNJHXYNTTTKYJPYCHHYEGKCTTWLGQRLGGTGTYGYHPYHYLQYQGCWYQKPYYYTTTTLHYHLLTYTTSPLKYZXGZWGPYDSSZZDQXSKCQNMJJZZBXYQMJRTFFBTKHZKBXLJJKDXJTLBWFZPPTKQTZTGPDGNTPJYFALQMKGXBDCLZFHZCLLLLADPMXDJHLCCLGYHDZFGYDDGCYYFGYDXKSSEBDHYKDKDKHNAXXYBPBYYHXZQGAFFQYJXDMLJCSQZLLPCHBSXGJYNDYBYQSPZWJLZKSDDTACTBXZDYZYPJZQSJNKKTKNJDJGYYPGTLFYQKASDNTCYHBLWDZHBBYDWJRYGKZYHEYYFJMSDTYFZJJHGCXPLXHLDWXXJKYTCYKSSSMTWCTTQZLPBSZDZWZXGZAGYKTYWXLHLSPBCLLOQMMZSSLCMBJCSZZKYDCZJGQQDSMCYTZQQLWZQZXSSFPTTFQMDDZDSHDTDWFHTDYZJYQJQKYPBDJYYXTLJHDRQXXXHAYDHRJLKLYTWHLLRLLRCXYLBWSRSZZSYMKZZHHKYHXKSMDSYDYCJPBZBSQLFCXXXNXKXWYWSDZYQOGGQMMYHCDZTTFJYYBGSTTTYBYKJDHKYXBELHTYPJQNFXFDYKZHQKZBYJTZBXHFDXKDASWTAWAJLDYJSFHBLDNNTNQJTJNCHXFJSRFWHZFMDRYJYJWZPDJKZYJYMPCYZNYNXFBYTFYFWYGDBNZZZDNYTXZEMMQBSQEHXFZMBMFLZZSRXYMJGSXWZJSPRYDJSJGXHJJGLJJYNZZJXHGXKYMLPYYYCXYTWQZSWHWLYRJLPXSLSXMFSWWKLCTNXNYNPSJSZHDZEPTXMYYWXYYSYWLXJQZQXZDCLEEELMCPJPCLWBXSQHFWWTFFJTNQJHJQDXHWLBYZNFJLALKYYJLDXHHYCSTYYWNRJYXYWTRMDRQHWQCMFJDYZMHMYYXJWMYZQZXTLMRSPWWCHAQBXYGZYPXYYRRCLMPYMGKSJSZYSRMYJSNXTPLNBAPPYPYLXYYZKYNLDZYJZCZNNLMZHHARQMPGWQTZMXXMLLHGDZXYHXKYXYCJMFFYYHJFSBSSQLXXNDYCANNMTCJCYPRRNYTYQNYYMBMSXNDLYLYSLJRLXYSXQMLLYZLZJJJKYZZCSFBZXXMSTBJGNXYZHLXNMCWSCYZYFZLXBRNNNYLBNRTGZQYSATSWRYHYJZMZDHZGZDWYBSSCSKXSYHYTXXGCQGXZZSHYXJSCRHMKKBXCZJYJYMKQHZJFNBHMQHYSNJNZYBKNQMCLGQHWLZNZSWXKHLJHYYBQLBFCDSXDLDSPFZPSKJYZWZXZDDXJSMMEGJSCSSMGCLXXKYYYLNYPWWWGYDKZJGGGZGGSYCKNJWNJPCXBJJTQTJWDSSPJXZXNZXUMELPXFSXTLLXCLJXJJLJZXCTPSWXLYDHLYQRWHSYCSQYYBYAYWJJJQFWQCQQCJQGXALDBZZYJGKGXPLTZYFXJLTPADKYQHPMATLCPDCKBMTXYBHKLENXDLEEGQDYMSAWHZMLJTWYGXLYQZLJEEYYBQQFFNLYXRDSCTGJGXYYNKLLYQKCCTLHJLQMKKZGCYYGLLLJDZGYDHZWXPYSJBZKDZGYZZHYWYFQYTYZSZYEZZLYMHJJHTSMQWYZLKYYWZCSRKQYTLTDXWCTYJKLWSQZWBDCQYNCJSRSZJLKCDCDTLZZZACQQZZDDXYPLXZBQJYLZLLLQDDZQJYJYJZYXNYYYNYJXKXDAZWYRDLJYYYRJLXLLDYXJCYWYWNQCCLDDNYYYNYCKCZHXXCCLGZQJGKWPPCQQJYSBZZXYJSQPXJPZBSBDSFNSFPZXHDWZTDWPPTFLZZBZDMYYPQJRSDZSQZSQXBDGCPZSWDWCSQZGMDHZXMWWFYBPDGPHTMJTHZSMMBGZMBZJCFZWFZBBZMQCFMBDMCJXLGPNJBBXGYHYYJGPTZGZMQBQTCGYXJXLWZKYDPDYMGCFTPFXYZTZXDZXTGKMTYBBCLBJASKYTSSQYYMSZXFJEWLXLLSZBQJJJAKLYLXLYCCTSXMCWFKKKBSXLLLLJYXTYLTJYYTDPJHNHNNKBYQNFQYYZBYYESSESSGDYHFHWTCJBSDZZTFDMXHCNJZYMQWSRYJDZJQPDQBBSTJGGFBKJBXTGQHNGWJXJGDLLTHZHHYYYYYYSXWTYYYCCBDBPYPZYCCZYJPZYWCBDLFWZCWJDXXHYHLHWZZXJTCZLCDPXUJCZZZLYXJJTXPHFXWPYWXZPTDZZBDZCYHJHMLXBQXSBYLRDTGJRRCTTTHYTCZWMXFYTWWZCWJWXJYWCSKYBZSCCTZQNHXNWXXKHKFHTSWOCCJYBCMPZZYKBNNZPBZHHZDLSYDDYTYFJPXYNGFXBYQXCBHXCPSXTYZDMKYSNXSXLHKMZXLYHDHKWHXXSSKQYHHCJYXGLHZXCSNHEKDTGZXQYPKDHEXTYKCNYMYYYPKQYYYKXZLTHJQTBYQHXBMYHSQCKWWYLLHCYYLNNEQXQWMCFBDCCMLJGGXDQKTLXKGNQCDGZJWYJJLYHHQTTTNWCHMXCXWHWSZJYDJCCDBQCDGDNYXZTHCQRXCBHZTQCBXWGQWYYBXHMBYMYQTYEXMQKYAQYRGYZSLFYKKQHYSSQYSHJGJCNXKZYCXSBXYXHYYLSTYCXQTHYSMGSCPMMGCCCCCMTZTASMGQZJHKLOSQYLSWTMXSYQKDZLJQQYPLSYCZTCQQPBBQJZCLPKHQZYYXXDTDDTSJCXFFLLCHQXMJLWCJCXTSPYCXNDTJSHJWXDQQJSKXYAMYLSJHMLALYKXCYYDMNMDQMXMCZNNCYBZKKYFLMCHCMLHXRCJJHSYLNMTJZGZGYWJXSRXCWJGJQHQZDQJDCJJZKJKGDZQGJJYJYLXZXXCDQHHHEYTMHLFSBDJSYYSHFYSTCZQLPBDRFRZTZYKYWHSZYQKWDQZRKMSYNBCRXQBJYFAZPZZEDZCJYWBCJWHYJBQSZYWRYSZPTDKZPFPBNZTKLQYHBBZPNPPTYZZYBQNYDCPJMMCYCQMCYFZZDCMNLFPBPLNGQJTBTTNJZPZBBZNJKLJQYLNBZQHKSJZNGGQSZZKYXSHPZSNBCGZKDDZQANZHJKDRTLZLSWJLJZLYWTJNDJZJHXYAYNCBGTZCSSQMNJPJYTYSWXZFKWJQTKHTZPLBHSNJZSYZBWZZZZLSYLSBJHDWWQPSLMMFBJDWAQYZTCJTBNNWZXQXCDSLQGDSDPDZHJTQQPSWLYYJZLGYXYZLCTCBJTKTYCZJTQKBSJLGMGZDMCSGPYNJZYQYYKNXRPWSZXMTNCSZZYXYBYHYZAXYWQCJTLLCKJJTJHGDXDXYQYZZBYWDLWQCGLZGJGQRQZCZSSBCRPCSKYDZNXJSQGXSSJMYDNSTZTPBDLTKZWXQWQTZEXNQCZGWEZKSSBYBRTSSSLCCGBPSZQSZLCCGLLLZXHZQTHCZMQGYZQZNMCOCSZJMMZSQPJYGQLJYJPPLDXRGZYXCCSXHSHGTZNLZWZKJCXTCFCJXLBMQBCZZWPQDNHXLJCTHYZLGYLNLSZZPCXDSCQQHJQKSXZPBAJYEMSMJTZDXLCJYRYYNWJBNGZZTMJXLTBSLYRZPYLSSCNXPHLLHYLLQQZQLXYMRSYCXZLMMCZLTZSDWTJJLLNZGGQXPFSKYGYGHBFZPDKMWGHCXMSGDXJMCJZDYCABXJDLNBCDQYGSKYDQTXDJJYXMSZQAZDZFSLQXYJSJZYLBTXXWXQQZBJZUFBBLYLWDSLJHXJYZJWTDJCZFQZQZZDZSXZZQLZCDZFJHYSPYMPQZMLPPLFFXJJNZZYLSJEYQZFPFZKSYWJJJHRDJZZXTXXGLGHYDXCSKYSWMMZCWYBAZBJKSHFHJCXMHFQHYXXYZFTSJYZFXYXPZLCHMZMBXHZZSXYFYMNCWDABAZLXKTCSHHXKXJJZJSTHYGXSXYYHHHJWXKZXSSBZZWHHHCWTZZZPJXSNXQQJGZYZYWLLCWXZFXXYXYHXMKYYSWSQMNLNAYCYSPMJKHWCQHYLAJJMZXHMMCNZHBHXCLXTJPLTXYJHDYYLTTXFSZHYXXSJBJYAYRSMXYPLCKDUYHLXRLNLLSTYZYYQYGYHHSCCSMZCTZQXKYQFPYYRPFFLKQUNTSZLLZMWWTCQQYZWTLLMLMPWMBZSSTZRBPDDTLQJJBXZCSRZQQYGWCSXFWZLXCCRSZDZMCYGGDZQSGTJSWLJMYMMZYHFBJDGYXCCPSHXNZCSBSJYJGJMPPWAFFYFNXHYZXZYLREMZGZCYZSSZDLLJCSQFNXZKPTXZGXJJGFMYYYSNBTYLBNLHPFZDCYFBMGQRRSSSZXYSGTZRNYDZZCDGPJAFJFZKNZBLCZSZPSGCYCJSZLMLRSZBZZLDLSLLYSXSQZQLYXZLSKKBRXBRBZCYCXZZZEEYFGKLZLYYHGZSGZLFJHGTGWKRAAJYZKZQTSSHJJXDCYZUYJLZYRZDQQHGJZXSSZBYKJPBFRTJXLLFQWJHYLQTYMBLPZDXTZYGBDHZZRBGXHWNJTJXLKSCFSMWLSDQYSJTXKZSCFWJLBXFTZLLJZLLQBLSQMQQCGCZFPBPHZCZJLPYYGGDTGWDCFCZQYYYQYSSCLXZSKLZZZGFFCQNWGLHQYZJJCZLQZZYJPJZZBPDCCMHJGXDQDGDLZQMFGPSYTSDYFWWDJZJYSXYYCZCYHZWPBYKXRYLYBHKJKSFXTZJMMCKHLLTNYYMSYXYZPYJQYCSYCWMTJJKQYRHLLQXPSGTLYYCLJSCPXJYZFNMLRGJJTYZBXYZMSJYJHHFZQMSYXRSZCWTLRTQZSSTKXGQKGSPTGCZNJSJCQCXHMXGGZTQYDJKZDLBZSXJLHYQGGGTHQSZPYHJHHGYYGKGGCWJZZYLCZLXQSFTGZSLLLMLJSKCTBLLZZSZMMNYTPZSXQHJCJYQXYZXZQZCPSHKZZYSXCDFGMWQRLLQXRFZTLYSTCTMJCXJJXHJNXTNRZTZFQYHQGLLGCXSZSJDJLJCYDSJTLNYXHSZXCGJZYQPYLFHDJSBPCCZHJJJQZJQDYBSSLLCMYTTMQTBHJQNNYGKYRQYQMZGCJKPDCGMYZHQLLSLLCLMHOLZGDYYFZSLJCQZLYLZQJESHNYLLJXGJXLYSYYYXNBZLJSSZCQQCJYLLZLTJYLLZLLBNYLGQCHXYYXOXCXQKYJXXXYKLXSXXYQXCYKQXQCSGYXXYQXYGYTQOHXHXPYXXXULCYEYCHZZCBWQBBWJQZSCSZSSLZYLKDESJZWMYMCYTSDSXXSCJPQQSQYLYYZYCMDJDZYWCBTJSYDJKCYDDJLBDJJSODZYSYXQQYXDHHGQQYQHDYXWGMMMAJDYBBBPPBCMUUPLJZSMTXERXJMHQNUTPJDCBSSMSSSTKJTSSMMTRCPLZSZMLQDSDMJMQPNQDXCFYNBFSDQXYXHYAYKQYDDLQYYYSSZBYDSLNTFQTZQPZMCHDHCZCWFDXTMYQSPHQYYXSRGJCWTJTZZQMGWJJTJHTQJBBHWZPXXHYQFXXQYWYYHYSCDYDHHQMNMTMWCPBSZPPZZGLMZFOLLCFWHMMSJZTTDHZZYFFYTZZGZYSKYJXQYJZQBHMBZZLYGHGFMSHPZFZSNCLPBQSNJXZSLXXFPMTYJYGBXLLDLXPZJYZJYHHZCYWHJYLSJEXFSZZYWXKZJLUYDTMLYMQJPWXYHXSKTQJEZRPXXZHHMHWQPWQLYJJQJJZSZCPHJLCHHNXJLQWZJHBMZYXBDHHYPZLHLHLGFWLCHYYTLHJXCJMSCPXSTKPNHQXSRTYXXTESYJCTLSSLSTDLLLWWYHDHRJZSFGXTSYCZYNYHTDHWJSLHTZDQDJZXXQHGYLTZPHCSQFCLNJTCLZPFSTPDYNYLGMJLLYCQHYSSHCHYLHQYQTMZYPBYWRFQYKQSYSLZDQJMPXYYSSRHZJNYWTQDFZBWWTWWRXCWHGYHXMKMYYYQMSMZHNGCEPMLQQMTCWCTMMPXJPJJHFXYYZSXZHTYBMSTSYJTTQQQYYLHYNPYQZLCYZHZWSMYLKFJXLWGXYPJYTYSYXYMZCKTTWLKSMZSYLMPWLZWXWQZSSAQSYXYRHSSNTSRAPXCPWCMGDXHXZDZYFJHGZTTSBJHGYZSZYSMYCLLLXBTYXHBBZJKSSDMALXHYCFYGMQYPJYCQXJLLLJGSLZGQLYCJCCZOTYXMTMTTLLWTGPXYMZMKLPSZZZXHKQYSXCTYJZYHXSHYXZKXLZWPSQPYHJWPJPWXQQYLXSDHMRSLZZYZWTTCYXYSZZSHBSCCSTPLWSSCJCHNLCGCHSSPHYLHFHHXJSXYLLNYLSZDHZXYLSXLWZYKCLDYAXZCMDDYSPJTQJZLNWQPSSSWCTSTSZLBLNXSMNYYMJQBQHRZWTYYDCHQLXKPZWBGQYBKFCMZWPZLLYYLSZYDWHXPSBCMLJBSCGBHXLQHYRLJXYSWXWXZSLDFHLSLYNJLZYFLYJYCDRJLFSYZFSLLCQYQFGJYHYXZLYLMSTDJCYHBZLLNWLXXYGYYHSMGDHXXHHLZZJZXCZZZCYQZFNGWPYLCPKPYYPMCLQKDGXZGGWQBDXZZKZFBXXLZXJTPJPTTBYTSZZDWSLCHZHSLTYXHQLHYXXXYYZYSWTXZKHLXZXZPYHGCHKCFSYHUTJRLXFJXPTZTWHPLYXFCRHXSHXKYXXYHZQDXQWULHYHMJTBFLKHTXCWHJFWJCFPQRYQXCYYYQYGRPYWSGSUNGWCHKZDXYFLXXHJJBYZWTSXXNCYJJYMSWZJQRMHXZWFQSYLZJZGBHYNSLBGTTCSYBYXXWXYHXYYXNSQYXMQYWRGYQLXBBZLJSYLPSYTJZYHYZAWLRORJMKSCZJXXXYXCHDYXRYXXJDTSQFXLYLTSFFYXLMTYJMJUYYYXLTZCSXQZQHZXLYYXZHDNBRXXXJCTYHLBRLMBRLLAXKYLLLJLYXXLYCRYLCJTGJCMTLZLLCYZZPZPCYAWHJJFYBDYYZSMPCKZDQYQPBPCJPDCYZMDPBCYYDYCNNPLMTMLRMFMMGWYZBSJGYGSMZQQQZTXMKQWGXLLPJGZBQCDJJJFPKJKCXBLJMSWMDTQJXLDLPPBXCWRCQFBFQJCZAHZGMYKPHYYHZYKNDKZMBPJYXPXYHLFPNYYGXJDBKXNXHJMZJXSTRSTLDXSKZYSYBZXJLXYSLBZYSLHXJPFXPQNBYLLJQKYGZMCYZZYMCCSLCLHZFWFWYXZMWSXTYNXJHPYYMCYSPMHYSMYDYSHQYZCHMJJMZCAAGCFJBBHPLYZYLXXSDJGXDHKXXTXXNBHRMLYJSLTXMRHNLXQJXYZLLYSWQGDLBJHDCGJYQYCMHWFMJYBMBYJYJWYMDPWHXQLDYGPDFXXBCGJSPCKRSSYZJMSLBZZJFLJJJLGXZGYXYXLSZQYXBEXYXHGCXBPLDYHWETTWWCJMBTXCHXYQXLLXFLYXLLJLSSFWDPZSMYJCLMWYTCZPCHQEKCQBWLCQYDPLQPPQZQFJQDJHYMMCXTXDRMJWRHXCJZYLQXDYYNHYYHRSLSRSYWWZJYMTLTLLGTQCJZYABTCKZCJYCCQLJZQXALMZYHYWLWDXZXQDLLQSHGPJFJLJHJABCQZDJGTKHSSTCYJLPSWZLXZXRWGLDLZRLZXTGSLLLLZLYXXWGDZYGBDPHZPBRLWSXQBPFDWOFMWHLYPCBJCCLDMBZPBZZLCYQXLDOMZBLZWPDWYYGDSTTHCSQSCCRSSSYSLFYBFNTYJSZDFNDPDHDZZMBBLSLCMYFFGTJJQWFTMTPJWFNLBZCMMJTGBDZLQLPYFHYYMJYLSDCHDZJWJCCTLJCLDTLJJCPDDSQDSSZYBNDBJLGGJZXSXNLYCYBJXQYCBYLZCFZPPGKCXZDZFZTJJFJSJXZBNZYJQTTYJYHTYCZHYMDJXTTMPXSPLZCDWSLSHXYPZGTFMLCJTYCBPMGDKWYCYZCDSZZYHFLYCTYGWHKJYYLSJCXGYWJCBLLCSNDDBTZBSCLYZCZZSSQDLLMQYYHFSLQLLXFTYHABXGWNYWYYPLLSDLDLLBJCYXJZMLHLJDXYYQYTDLLLBUGBFDFBBQJZZMDPJHGCLGMJJPGAEHHBWCQXAXHHHZCHXYPHJAXHLPHJPGPZJQCQZGJJZZUZDMQYYBZZPHYHYBWHAZYJHYKFGDPFQSDLZMLJXKXGALXZDAGLMDGXMWZQYXXDXXPFDMMSSYMPFMDMMKXKSYZYSHDZKXSYSMMZZZMSYDNZZCZXFPLSTMZDNMXCKJMZTYYMZMZZMSXHHDCZJEMXXKLJSTLWLSQLYJZLLZJSSDPPMHNLZJCZYHMXXHGZCJMDHXTKGRMXFWMCGMWKDTKSXQMMMFZZYDKMSCLCMPCGMHSPXQPZDSSLCXKYXTWLWJYAHZJGZQMCSNXYYMMPMLKJXMHLMLQMXCTKZMJQYSZJSYSZHSYJZJCDAJZYBSDQJZGWZQQXFKDMSDJLFWEHKZQKJPEYPZYSZCDWYJFFMZZYLTTDZZEFMZLBNPPLPLPEPSZALLTYLKCKQZKGENQLWAGYXYDPXLHSXQQWQCQXQCLHYXXMLYCCWLYMQYSKGCHLCJNSZKPYZKCQZQLJPDMDZHLASXLBYDWQLWDNBQCRYDDZTJYBKBWSZDXDTNPJDTCTQDFXQQMGNXECLTTBKPWSLCTYQLPWYZZKLPYGZCQQPLLKCCYLPQMZCZQCLJSLQZDJXLDDHPZQDLJJXZQDXYZQKZLJCYQDYJPPYPQYKJYRMPCBYMCXKLLZLLFQPYLLLMBSGLCYSSLRSYSQTMXYXZQZFDZUYSYZTFFMZZSMZQHZSSCCMLYXWTPZGXZJGZGSJSGKDDHTQGGZLLBJDZLCBCHYXYZHZFYWXYZYMSDBZZYJGTSMTFXQYXQSTDGSLNXDLRYZZLRYYLXQHTXSRTZNGZXBNQQZFMYKMZJBZYMKBPNLYZPBLMCNQYZZZSJZHJCTZKHYZZJRDYZHNPXGLFZTLKGJTCTSSYLLGZRZBBQZZKLPKLCZYSSUYXBJFPNJZZXCDWXZYJXZZDJJKGGRSRJKMSMZJLSJYWQSKYHQJSXPJZZZLSNSHRNYPZTWCHKLPSRZLZXYJQXQKYSJYCZTLQZYBBYBWZPQDWWYZCYTJCJXCKCWDKKZXSGKDZXWWYYJQYYTCYTDLLXWKCZKKLCCLZCQQDZLQLCSFQCHQHSFSMQZZLNBJJZBSJHTSZDYSJQJPDLZCDCWJKJZZLPYCGMZWDJJBSJQZSYZYHHXJPBJYDSSXDZNCGLQMBTSFSBPDZDLZNFGFJGFSMPXJQLMBLGQCYYXBQKDJJQYRFKZTJDHCZKLBSDZCFJTPLLJGXHYXZCSSZZXSTJYGKGCKGYOQXJPLZPBPGTGYJZGHZQZZLBJLSQFZGKQQJZGYCZBZQTLDXRJXBSXXPZXHYZYCLWDXJJHXMFDZPFZHQHQMQGKSLYHTYCGFRZGNQXCLPDLBZCSCZQLLJBLHBZCYPZZPPDYMZZSGYHCKCPZJGSLJLNSCDSLDLXBMSTLDDFJMKDJDHZLZXLSZQPQPGJLLYBDSZGQLBZLSLKYYHZTTNTJYQTZZPSZQZTLLJTYYLLQLLQYZQLBDZLSLYYZYMDFSZSNHLXZNCZQZPBWSKRFBSYZMTHBLGJPMCZZLSTLXSHTCSYZLZBLFEQHLXFLCJLYLJQCBZLZJHHSSTBRMHXZHJZCLXFNBGXGTQJCZTMSFZKJMSSNXLJKBHSJXNTNLZDNTLMSJXGZJYJCZXYJYJWRWWQNZTNFJSZPZSHZJFYRDJSFSZJZBJFZQZZHZLXFYSBZQLZSGYFTZDCSZXZJBQMSZKJRHYJZCKMJKHCHGTXKXQGLXPXFXTRTYLXJXHDTSJXHJZJXZWZLCQSBTXWXGXTXXHXFTSDKFJHZYJFJXRZSDLLLTQSQQZQWZXSYQTWGWBZCGZLLYZBCLMQQTZHZXZXLJFRMYZFLXYSQXXJKXRMQDZDMMYYBSQBHGZMWFWXGMXLZPYYTGZYCCDXYZXYWGSYJYZNBHPZJSQSYXSXRTFYZGRHZTXSZZTHCBFCLSYXZLZQMZLMPLMXZJXSFLBYZMYQHXJSXRXSQZZZSSLYFRCZJRCRXHHZXQYDYHXSJJHZCXZBTYNSYSXJBQLPXZQPYMLXZKYXLXCJLCYSXXZZLXDLLLJJYHZXGYJWKJRWYHCPSGNRZLFZWFZZNSXGXFLZSXZZZBFCSYJDBRJKRDHHGXJLJJTGXJXXSTJTJXLYXQFCSGSWMSBCTLQZZWLZZKXJMLTMJYHSDDBXGZHDLBMYJFRZFSGCLYJBPMLYSMSXLSZJQQHJZFXGFQFQBPXZGYYQXGZTCQWYLTLGWSGWHRLFSFGZJMGMGBGTJFSYZZGZYZAFLSSPMLPFLCWBJZCLJJMZLPJJLYMQDMYYYFBGYGYZMLYZDXQYXRQQQHSYYYQXYLJTYXFSFSLLGNQCYHYCWFHCCCFXPYLYPLLZYXXXXXKQHHXSHJZCFZSCZJXCPZWHHHHHAPYLQALPQAFYHXDYLUKMZQGGGDDESRNNZLTZGCHYPPYSQJJHCLLJTOLNJPZLJLHYMHEYDYDSQYCDDHGZUNDZCLZYZLLZNTNYZGSLHSLPJJBDGWXPCDUTJCKLKCLWKLLCASSTKZZDNQNTTLYYZSSYSSZZRYLJQKCQDHHCRXRZYDGRGCWCGZQFFFPPJFZYNAKRGYWYQPQXXFKJTSZZXSWZDDFBBXTBGTZKZNPZZPZXZPJSZBMQHKCYXYLDKLJNYPKYGHGDZJXXEAHPNZKZTZCMXCXMMJXNKSZQNMNLWBWWXJKYHCPSTMCSQTZJYXTPCTPDTNNPGLLLZSJLSPBLPLQHDTNJNLYYRSZFFJFQWDPHZDWMRZCCLODAXNSSNYZRESTYJWJYJDBCFXNMWTTBYLWSTSZGYBLJPXGLBOCLHPCBJLTMXZLJYLZXCLTPNCLCKXTPZJSWCYXSFYSZDKNTLBYJCYJLLSTGQCBXRYZXBXKLYLHZLQZLNZCXWJZLJZJNCJHXMNZZGJZZXTZJXYCYYCXXJYYXJJXSSSJSTSSTTPPGQTCSXWZDCSYFPTFBFHFBBLZJCLZZDBXGCXLQPXKFZFLSYLTUWBMQJHSZBMDDBCYSCCLDXYCDDQLYJJWMQLLCSGLJJSYFPYYCCYLTJANTJJPWYCMMGQYYSXDXQMZHSZXPFTWWZQSWQRFKJLZJQQYFBRXJHHFWJJZYQAZMYFRHCYYBYQWLPEXCCZSTYRLTTDMQLYKMBBGMYYJPRKZNPBSXYXBHYZDJDNGHPMFSGMWFZMFQMMBCMZZCJJLCNUXYQLMLRYGQZCYXZLWJGCJCGGMCJNFYZZJHYCPRRCMTZQZXHFQGTJXCCJEAQCRJYHPLQLSZDJRBCQHQDYRHYLYXJSYMHZYDWLDFRYHBPYDTSSCNWBXGLPZMLZZTQSSCPJMXXYCSJYTYCGHYCJWYRXXLFEMWJNMKLLSWTXHYYYNCMMCWJDQDJZGLLJWJRKHPZGGFLCCSCZMCBLTBHBQJXQDSPDJZZGKGLFQYWBZYZJLTSTDHQHCTCBCHFLQMPWDSHYYTQWCNZZJTLBYMBPDYYYXSQKXWYYFLXXNCWCXYPMAELYKKJMZZZBRXYYQJFLJPFHHHYTZZXSGQQMHSPGDZQWBWPJHZJDYSCQWZKTXXSQLZYYMYSDZGRXCKKUJLWPYSYSCSYZLRMLQSYLJXBCXTLWDQZPCYCYKPPPNSXFYZJJRCEMHSZMSXLXGLRWGCSTLRSXBZGBZGZTCPLUJLSLYLYMTXMTZPALZXPXJTJWTCYYZLBLXBZLQMYLXPGHDSLSSDMXMBDZZSXWHAMLCZCPJMCNHJYSNSYGCHSKQMZZQDLLKABLWJXSFMOCDXJRRLYQZKJMYBYQLYHETFJZFRFKSRYXFJTWDSXXSYSQJYSLYXWJHSNLXYYXHBHAWHHJZXWMYLJCSSLKYDZTXBZSYFDXGXZJKHSXXYBSSXDPYNZWRPTQZCZENYGCXQFJYKJBZMLJCMQQXUOXSLYXXLYLLJDZBTYMHPFSTTQQWLHOKYBLZZALZXQLHZWRRQHLSTMYPYXJJXMQSJFNBXYXYJXXYQYLTHYLQYFMLKLJTMLLHSZWKZHLJMLHLJKLJSTLQXYLMBHHLNLZXQJHXCFXXLHYHJJGBYZZKBXSCQDJQDSUJZYYHZHHMGSXCSYMXFEBCQWWRBPYYJQTYZCYQYQQZYHMWFFHGZFRJFCDPXNTQYZPDYKHJLFRZXPPXZDBBGZQSTLGDGYLCQMLCHHMFYWLZYXKJLYPQHSYWMQQGQZMLZJNSQXJQSYJYCBEHSXFSZPXZWFLLBCYYJDYTDTHWZSFJMQQYJLMQXXLLDTTKHHYBFPWTYYSQQWNQWLGWDEBZWCMYGCULKJXTMXMYJSXHYBRWFYMWFRXYQMXYSZTZZTFYKMLDHQDXWYYNLCRYJBLPSXCXYWLSPRRJWXHQYPHTYDNXHHMMYWYTZCSQMTSSCCDALWZTCPQPYJLLQZYJSWXMZZMMYLMXCLMXCZMXMZSQTZPPQQBLPGXQZHFLJJHYTJSRXWZXSCCDLXTYJDCQJXSLQYCLZXLZZXMXQRJMHRHZJBHMFLJLMLCLQNLDXZLLLPYPSYJYSXCQQDCMQJZZXHNPNXZMEKMXHYKYQLXSXTXJYYHWDCWDZHQYYBGYBCYSCFGPSJNZDYZZJZXRZRQJJYMCANYRJTLDPPYZBSTJKXXZYPFDWFGZZRPYMTNGXZQBYXNBUFNQKRJQZMJEGRZGYCLKXZDSKKNSXKCLJSPJYYZLQQJYBZSSQLLLKJXTBKTYLCCDDBLSPPFYLGYDTZJYQGGKQTTFZXBDKTYYHYBBFYTYYBCLPDYTGDHRYRNJSPTCSNYJQHKLLLZSLYDXXWBCJQSPXBPJZJCJDZFFXXBRMLAZHCSNDLBJDSZBLPRZTSWSBXBCLLXXLZDJZSJPYLYXXYFTFFFBHJJXGBYXJPMMMPSSJZJMTLYZJXSWXTYLEDQPJMYGQZJGDJLQJWJQLLSJGJGYGMSCLJJXDTYGJQJQJCJZCJGDZZSXQGSJGGCXHQXSNQLZZBXHSGZXCXYLJXYXYYDFQQJHJFXDHCTXJYRXYSQTJXYEFYYSSYYJXNCYZXFXMSYSZXYYSCHSHXZZZGZZZGFJDLTYLNPZGYJYZYYQZPBXQBDZTZCZYXXYHHSQXSHDHGQHJHGYWSZTMZMLHYXGEBTYLZKQWYTJZRCLEKYSTDBCYKQQSAYXCJXWWGSBHJYZYDHCSJKQCXSWXFLTYNYZPZCCZJQTZWJQDZZZQZLJJXLSBHPYXXPSXSHHEZTXFPTLQYZZXHYTXNCFZYYHXGNXMYWXTZSJPTHHGYMXMXQZXTSBCZYJYXXTYYZYPCQLMMSZMJZZLLZXGXZAAJZYXJMZXWDXZSXZDZXLEYJJZQBHZWZZZQTZPSXZTDSXJJJZNYAZPHXYYSRNQDTHZHYYKYJHDZXZLSWCLYBZYECWCYCRYLCXNHZYDZYDYJDFRJJHTRSQTXYXJRJHOJYNXELXSFSFJZGHPZSXZSZDZCQZBYYKLSGSJHCZSHDGQGXYZGXCHXZJWYQWGYHKSSEQZZNDZFKWYSSTCLZSTSYMCDHJXXYWEYXCZAYDMPXMDSXYBSQMJMZJMTZQLPJYQZCGQHXJHHLXXHLHDLDJQCLDWBSXFZZYYSCHTYTYYBHECXHYKGJPXHHYZJFXHWHBDZFYZBCAPNPGNYDMSXHMMMMAMYNBYJTMPXYYMCTHJBZYFCGTYHWPHFTWZZEZSBZEGPFMTSKFTYCMHFLLHGPZJXZJGZJYXZSBBQSCZZLZCCSTPGXMJSFTCCZJZDJXCYBZLFCJSYZFGSZLYBCWZZBYZDZYPSWYJZXZBDSYUXLZZBZFYGCZXBZHZFTPBGZGEJBSTGKDMFHYZZJHZLLZZGJQZLSFDJSSCBZGPDLFZFZSZYZYZSYGCXSNXXCHCZXTZZLJFZGQSQYXZJQDCCZTQCDXZJYQJQCHXZTDLGSCXZSYQJQTZWLQDQZTQCHQQJZYEZZZPBWKDJFCJPZTYPQYQTTYNLMBDKTJZPQZQZZFPZSBNJLGYJDXJDZZKZGQKXDLPZJTCJDQBXDJQJSTCKNXBXZMSLYJCQMTJQWWCJQNJNLLLHJCWQTBZQYDZCZPZZDZYDDCYZZZCCJTTJFZDPRRTZTJDCQTQZDTJNPLZBCLLCTZSXKJZQZPZLBZRBTJDCXFCZDBCCJJLTQQPLDCGZDBBZJCQDCJWYNLLZYZCCDWLLXWZLXRXNTQQCZXKQLSGDFQTDDGLRLAJJTKUYMKQLLTZYTDYYCZGJWYXDXFRSKSTQTENQMRKQZHHQKDLDAZFKYPBGGPZREBZZYKZZSPEGJXGYKQZZZSLYSYYYZWFQZYLZZLZHWCHKYPQGNPGBLPLRRJYXCCSYYHSFZFYBZYYTGZXYLXCZWXXZJZBLFFLGSKHYJZEYJHLPLLLLCZGXDRZELRHGKLZZYHZLYQSZZJZQLJZFLNBHGWLCZCFJYSPYXZLZLXGCCPZBLLCYBBBBUBBCBPCRNNZCZYRBFSRLDCGQYYQXYGMQZWTZYTYJXYFWTEHZZJYWLCCNTZYJJZDEDPZDZTSYQJHDYMBJNYJZLXTSSTPHNDJXXBYXQTZQDDTJTDYYTGWSCSZQFLSHLGLBCZPHDLYZJYCKWTYTYLBNYTSDSYCCTYSZYYEBHEXHQDTWNYGYCLXTSZYSTQMYGZAZCCSZZDSLZCLZRQXYYELJSBYMXSXZTEMBBLLYYLLYTDQYSHYMRQWKFKBFXNXSBYCHXBWJYHTQBPBSBWDZYLKGZSKYHXQZJXHXJXGNLJKZLYYCDXLFYFGHLJGJYBXQLYBXQPQGZTZPLNCYPXDJYQYDYMRBESJYYHKXXSTMXRCZZYWXYQYBMCLLYZHQYZWQXDBXBZWZMSLPDMYSKFMZKLZCYQYCZLQXFZZYDQZPZYGYJYZMZXDZFYFYTTQTZHGSPCZMLCCYTZXJCYTJMKSLPZHYSNZLLYTPZCTZZCKTXDHXXTQCYFKSMQCCYYAZHTJPCYLZLYJBJXTPNYLJYYNRXSYLMMNXJSMYBCSYSYLZYLXJJQYLDZLPQBFZZBLFNDXQKCZFYWHGQMRDSXYCYTXNQQJZYYPFZXDYZFPRXEJDGYQBXRCNFYYQPGHYJDYZXGRHTKYLNWDZNTSMPKLBTHBPYSZBZTJZSZZJTYYXZPHSSZZBZCZPTQFZMYFLYPYBBJQXZMXXDJMTSYSKKBJZXHJCKLPSMKYJZCXTMLJYXRZZQSLXXQPYZXMKYXXXJCLJPRMYYGADYSKQLSNDHYZKQXZYZTCGHZTLMLWZYBWSYCTBHJHJFCWZTXWYTKZLXQSHLYJZJXTMPLPYCGLTBZZTLZJCYJGDTCLKLPLLQPJMZPAPXYZLKKTKDZCZZBNZDYDYQZJYJGMCTXLTGXSZLMLHBGLKFWNWZHDXUHLFMKYSLGXDTWWFRJEJZTZHYDXYKSHWFZCQSHKTMQQHTZHYMJDJSKHXZJZBZZXYMPAGQMSTPXLSKLZYNWRTSQLSZBPSPSGZWYHTLKSSSWHZZLYYTNXJGMJSZSUFWNLSOZTXGXLSAMMLBWLDSZYLAKQCQCTMYCFJBSLXCLZZCLXXKSBZQCLHJPSQPLSXXCKSLNHPSFQQYTXYJZLQLDXZQJZDYYDJNZPTUZDSKJFSLJHYLZSQZLBTXYDGTQFDBYAZXDZHZJNHHQBYKNXJJQCZMLLJZKSPLDYCLBBLXKLELXJLBQYCXJXGCNLCQPLZLZYJTZLJGYZDZPLTQCSXFDMNYCXGBTJDCZNBGBQYQJWGKFHTNPYQZQGBKPBBYZMTJDYTBLSQMPSXTBNPDXKLEMYYCJYNZCTLDYKZZXDDXHQSHDGMZSJYCCTAYRZLPYLTLKXSLZCGGEXCLFXLKJRTLQJAQZNCMBYDKKCXGLCZJZXJHPTDJJMZQYKQSECQZDSHHADMLZFMMZBGNTJNNLGBYJBRBTMLBYJDZXLCJLPLDLPCQDHLXZLYCBLCXZZJADJLNZMMSSSMYBHBSQKBHRSXXJMXSDZNZPXLGBRHWGGFCXGMSKLLTSJYYCQLTSKYWYYHYWXBXQYWPYWYKQLSQPTNTKHQCWDQKTWPXXHCPTHTWUMSSYHBWCRWXHJMKMZNGWTMLKFGHKJYLSYYCXWHYECLQHKQHTTQKHFZLDXQWYZYYDESBPKYRZPJFYYZJCEQDZZDLATZBBFJLLCXDLMJSSXEGYGSJQXCWBXSSZPDYZCXDNYXPPZYDLYJCZPLTXLSXYZYRXCYYYDYLWWNZSAHJSYQYHGYWWAXTJZDAXYSRLTDPSSYYFNEJDXYZHLXLLLZQZSJNYQYQQXYJGHZGZCYJCHZLYCDSHWSHJZYJXCLLNXZJJYYXNFXMWFPYLCYLLABWDDHWDXJMCXZTZPMLQZHSFHZYNZTLLDYWLSLXHYMMYLMBWWKYXYADTXYLLDJPYBPWUXJMWMLLSAFDLLYFLBHHHBQQLTZJCQJLDJTFFKMMMBYTHYGDCQRDDWRQJXNBYSNWZDBYYTBJHPYBYTTJXAAHGQDQTMYSTQXKBTZPKJLZRBEQQSSMJJBDJOTGTBXPGBKTLHQXJJJCTHXQDWJLWRFWQGWSHCKRYSWGFTGYGBXSDWDWRFHWYTJJXXXJYZYSLPYYYPAYXHYDQKXSHXYXGSKQHYWFDDDPPLCJLQQEEWXKSYYKDYPLTJTHKJLTCYYHHJTTPLTZZCDLTHQKZXQYSTEEYWYYZYXXYYSTTJKLLPZMCYHQGXYHSRMBXPLLNQYDQHXSXXWGDQBSHYLLPJJJTHYJKYPPTHYYKTYEZYENMDSHLCRPQFDGFXZPSFTLJXXJBSWYYSKSFLXLPPLBBBLBSFXFYZBSJSSYLPBBFFFFSSCJDSTZSXZRYYSYFFSYZYZBJTBCTSBSDHRTJJBYTCXYJEYLXCBNEBJDSYXYKGSJZBXBYTFZWGENYHHTHZHHXFWGCSTBGXKLSXYWMTMBYXJSTZSCDYQRCYTWXZFHMYMCXLZNSDJTTTXRYCFYJSBSDYERXJLJXBBDEYNJGHXGCKGSCYMBLXJMSZNSKGXFBNBPTHFJAAFXYXFPXMYPQDTZCXZZPXRSYWZDLYBBKTYQPQJPZYPZJZNJPZJLZZFYSBTTSLMPTZRTDXQSJEHBZYLZDHLJSQMLHTXTJECXSLZZSPKTLZKQQYFSYGYWPCPQFHQHYTQXZKRSGTTSQCZLPTXCDYYZXSQZSLXLZMYCPCQBZYXHBSXLZDLTCDXTYLZJYYZPZYZLTXJSJXHLPMYTXCQRBLZSSFJZZTNJYTXMYJHLHPPLCYXQJQQKZZSCPZKSWALQSBLCCZJSXGWWWYGYKTJBBZTDKHXHKGTGPBKQYSLPXPJCKBMLLXDZSTBKLGGQKQLSBKKTFXRMDKBFTPZFRTBBRFERQGXYJPZSSTLBZTPSZQZSJDHLJQLZBPMSMMSXLQQNHKNBLRDDNXXDHDDJCYYGYLXGZLXSYGMQQGKHBPMXYXLYTQWLWGCPBMQXCYZYDRJBHTDJYHQSHTMJSBYPLWHLZFFNYPMHXXHPLTBQPFBJWQDBYGPNZTPFZJGSDDTQSHZEAWZZYLLTYYBWJKXXGHLFKXDJTMSZSQYNZGGSWQSPHTLSSKMCLZXYSZQZXNCJDQGZDLFNYKLJCJLLZLMZZNHYDSSHTHZZLZZBBHQZWWYCRZHLYQQJBEYFXXXWHSRXWQHWPSLMSSKZTTYGYQQWRSLALHMJTQJSMXQBJJZJXZYZKXBYQXBJXSHZTSFJLXMXZXFGHKZSZGGYLCLSARJYHSLLLMZXELGLXYDJYTLFBHBPNLYZFBBHPTGJKWETZHKJJXZXXGLLJLSTGSHJJYQLQZFKCGNNDJSSZFDBCTWWSEQFHQJBSAQTGYPQLBXBMMYWXGSLZHGLZGQYFLZBYFZJFRYSFMBYZHQGFWZSYFYJJPHZBYYZFFWODGRLMFTWLBZGYCQXCDJYGZYYYYTYTYDWEGAZYHXJLZYYHLRMGRXXZCLHNELJJTJTPWJYBJJBXJJTJTEEKHWSLJPLPSFYZPQQBDLQJJTYYQLYZKDKSQJYYQZLDQTGJQYZJSUCMRYQTHTEJMFCTYHYPKMHYZWJDQFHYYXWSHCTXRLJHQXHCCYYYJLTKTTYTMXGTCJTZAYYOCZLYLBSZYWJYTSJYHBYSHFJLYGJXXTMZYYLTXXYPZLXYJZYZYYPNHMYMDYYLBLHLSYYQQLLNJJYMSOYQBZGDLYXYLCQYXTSZEGXHZGLHWBLJHEYXTWQMAKBPQCGYSHHEGQCMWYYWLJYJHYYZLLJJYLHZYHMGSLJLJXCJJYCLYCJPCPZJZJMMYLCQLNQLJQJSXYJMLSZLJQLYCMMHCFMMFPQQMFYLQMCFFQMMMMHMZNFHHJGTTHHKHSLNCHHYQDXTMMQDCYZYXYQMYQYLTDCYYYZAZZCYMZYDLZFFFMMYCQZWZZMABTBYZTDMNZZGGDFTYPCGQYTTSSFFWFDTZQSSYSTWXJHXYTSXXYLBYQHWWKXHZXWZNNZZJZJJQJCCCHYYXBZXZCYZTLLCQXYNJYCYYCYNZZQYYYEWYCZDCJYCCHYJLBTZYYCQWMPWPYMLGKDLDLGKQQBGYCHJXY"; //此处收录了375个多音字,数据来自于http://www.51window.net/page/pinyin var oMultiDiff = &#123;"19969": "DZ", "19975": "WM", "19988": "QJ", "20048": "YL", "20056": "SC", "20060": "NM", "20094": "QG", "20127": "QJ", "20167": "QC", "20193": "YG", "20250": "KH", "20256": "ZC", "20282": "SC", "20285": "QJG", "20291": "TD", "20314": "YD", "20340": "NE", "20375": "TD", "20389": "YJ", "20391": "CZ", "20415": "PB", "20446": "YS", "20447": "SQ", "20504": "TC", "20608": "KG", "20854": "QJ", "20857": "ZC", "20911": "PF", "20504": "TC", "20608": "KG", "20854": "QJ", "20857": "ZC", "20911": "PF", "20985": "AW", "21032": "PB", "21048": "XQ", "21049": "SC", "21089": "YS", "21119": "JC", "21242": "SB", "21273": "SC", "21305": "YP", "21306": "QO", "21330": "ZC", "21333": "SDC", "21345": "QK", "21378": "CA", "21397": "SC", "21414": "XS", "21442": "SC", "21477": "JG", "21480": "TD", "21484": "ZS", "21494": "YX", "21505": "YX", "21512": "HG", "21523": "XH", "21537": "PB", "21542": "PF", "21549": "KH", "21571": "E", "21574": "DA", "21588": "TD", "21589": "O", "21618": "ZC", "21621": "KHA", "21632": "ZJ", "21654": "KG", "21679": "LKG", "21683": "KH", "21710": "A", "21719": "YH", "21734": "WOE", "21769": "A", "21780": "WN", "21804": "XH", "21834": "A", "21899": "ZD", "21903": "RN", "21908": "WO", "21939": "ZC", "21956": "SA", "21964": "YA", "21970": "TD", "22003": "A", "22031": "JG", "22040": "XS", "22060": "ZC", "22066": "ZC", "22079": "MH", "22129": "XJ", "22179": "XA", "22237": "NJ", "22244": "TD", "22280": "JQ", "22300": "YH", "22313": "XW", "22331": "YQ", "22343": "YJ", "22351": "PH", "22395": "DC", "22412": "TD", "22484": "PB", "22500": "PB", "22534": "ZD", "22549": "DH", "22561": "PB", "22612": "TD", "22771": "KQ", "22831": "HB", "22841": "JG", "22855": "QJ", "22865": "XQ", "23013": "ML", "23081": "WM", "23487": "SX", "23558": "QJ", "23561": "YW", "23586": "YW", "23614": "YW", "23615": "SN", "23631": "PB", "23646": "ZS", "23663": "ZT", "23673": "YG", "23762": "TD", "23769": "ZS", "23780": "QJ", "23884": "QK", "24055": "XH", "24113": "DC", "24162": "ZC", "24191": "GA", "24273": "QJ", "24324": "NL", "24377": "TD", "24378": "QJ", "24439": "PF", "24554": "ZS", "24683": "TD", "24694": "WE", "24733": "LK", "24925": "TN", "25094": "ZG", "25100": "XQ", "25103": "XH", "25153": "PB", "25170": "PB", "25179": "KG", "25203": "PB", "25240": "ZS", "25282": "FB", "25303": "NA", "25324": "KG", "25341": "ZY", "25373": "WZ", "25375": "XJ", "25384": "A", "25457": "A", "25528": "SD", "25530": "SC", "25552": "TD", "25774": "ZC", "25874": "ZC", "26044": "YW", "26080": "WM", "26292": "PB", "26333": "PB", "26355": "ZY", "26366": "CZ", "26397": "ZC", "26399": "QJ", "26415": "ZS", "26451": "SB", "26526": "ZC", "26552": "JG", "26561": "TD", "26588": "JG", "26597": "CZ", "26629": "ZS", "26638": "YL", "26646": "XQ", "26653": "KG", "26657": "XJ", "26727": "HG", "26894": "ZC", "26937": "ZS", "26946": "ZC", "26999": "KJ", "27099": "KJ", "27449": "YQ", "27481": "XS", "27542": "ZS", "27663": "ZS", "27748": "TS", "27784": "SC", "27788": "ZD", "27795": "TD", "27812": "O", "27850": "PB", "27852": "MB", "27895": "SL", "27898": "PL", "27973": "QJ", "27981": "KH", "27986": "HX", "27994": "XJ", "28044": "YC", "28065": "WG", "28177": "SM", "28267": "QJ", "28291": "KH", "28337": "ZQ", "28463": "TL", "28548": "DC", "28601": "TD", "28689": "PB", "28805": "JG", "28820": "QG", "28846": "PB", "28952": "TD", "28975": "ZC", "29100": "A", "29325": "QJ", "29575": "SL", "29602": "FB", "30010": "TD", "30044": "CX", "30058": "PF", "30091": "YSP", "30111": "YN", "30229": "XJ", "30427": "SC", "30465": "SX", "30631": "YQ", "30655": "QJ", "30684": "QJG", "30707": "SD", "30729": "XH", "30796": "LG", "30917": "PB", "31074": "NM", "31085": "JZ", "31109": "SC", "31181": "ZC", "31192": "MLB", "31293": "JQ", "31400": "YX", "31584": "YJ", "31896": "ZN", "31909": "ZY", "31995": "XJ", "32321": "PF", "32327": "ZY", "32418": "HG", "32420": "XQ", "32421": "HG", "32438": "LG", "32473": "GJ", "32488": "TD", "32521": "QJ", "32527": "PB", "32562": "ZSQ", "32564": "JZ", "32735": "ZD", "32793": "PB", "33071": "PF", "33098": "XL", "33100": "YA", "33152": "PB", "33261": "CX", "33324": "BP", "33333": "TD", "33406": "YA", "33426": "WM", "33432": "PB", "33445": "JG", "33486": "ZN", "33493": "TS", "33507": "QJ", "33540": "QJ", "33544": "ZC", "33564": "XQ", "33617": "YT", "33632": "QJ", "33636": "XH", "33637": "YX", "33694": "WG", "33705": "PF", "33728": "YW", "33882": "SR", "34067": "WM", "34074": "YW", "34121": "QJ", "34255": "ZC", "34259": "XL", "34425": "JH", "34430": "XH", "34485": "KH", "34503": "YS", "34532": "HG", "34552": "XS", "34558": "YE", "34593": "ZL", "34660": "YQ", "34892": "XH", "34928": "SC", "34999": "QJ", "35048": "PB", "35059": "SC", "35098": "ZC", "35203": "TQ", "35265": "JX", "35299": "JX", "35782": "SZ", "35828": "YS", "35830": "E", "35843": "TD", "35895": "YG", "35977": "MH", "36158": "JG", "36228": "QJ", "36426": "XQ", "36466": "DC", "36710": "JC", "36711": "ZYG", "36767": "PB", "36866": "SK", "36951": "YW", "37034": "YX", "37063": "XH", "37218": "ZC", "37325": "ZC", "38063": "PB", "38079": "TD", "38085": "QY", "38107": "DC", "38116": "TD", "38123": "YD", "38224": "HG", "38241": "XTC", "38271": "ZC", "38415": "YE", "38426": "KH", "38461": "YD", "38463": "AE", "38466": "PB", "38477": "XJ", "38518": "YT", "38551": "WK", "38585": "ZC", "38704": "XS", "38739": "LJ", "38761": "GJ", "38808": "SQ", "39048": "JG", "39049": "XJ", "39052": "HG", "39076": "CZ", "39271": "XT", "39534": "TD", "39552": "TD", "39584": "PB", "39647": "SB", "39730": "LG", "39748": "TPB", "40109": "ZQ", "40479": "ND", "40516": "HG", "40536": "HG", "40583": "QJ", "40765": "YQ", "40784": "QJ", "40840": "YK", "40863": "QJG"&#125;; //参数,中文字符串 //返回值:拼音首字母串数组 function getPy(str) &#123; if (typeof (str) != "string") &#123; throw new Error(-1, "函数getPy需要字符串类型参数!"); &#125; var arrResult = new Array(); //保存中间结果的数组 for (var i = 0, len = str.length; i &lt; len; i++) &#123; //获得unicode码 var ch = str.charAt(i); //检查该unicode码是否在处理范围之内,在则返回该码对映汉字的拼音首字母,不在则调用其它函数处理 arrResult.push(checkCh(ch)); &#125; //处理arrResult,返回所有可能的拼音首字母串数组 return mkRslt(arrResult); &#125; function checkCh(ch) &#123; var uni = ch.charCodeAt(0); //如果不在汉字处理范围之内,返回原字符,也可以调用自己的处理函数 if (uni &gt; 40869 || uni &lt; 19968) &#123; return ch; &#125; //dealWithOthers(ch); //检查是否是多音字,是按多音字处理,不是就直接在strChineseFirstPY字符串中找对应的首字母 return (oMultiDiff[uni] ? oMultiDiff[uni] : (strChineseFirstPY.charAt(uni - 19968))); &#125; function mkRslt(arr) &#123; var arrRslt = [""]; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; var str = arr[i]; var strlen = str.length; if (strlen == 1) &#123; for (var k = 0; k &lt; arrRslt.length; k++) &#123; arrRslt[k] += str; &#125; &#125; else &#123; var tmpArr = arrRslt.slice(0); arrRslt = []; for (k = 0; k &lt; strlen; k++) &#123; //复制一个相同的arrRslt var tmp = tmpArr.slice(0); //把当前字符str[k]添加到每个元素末尾 for (var j = 0; j &lt; tmp.length; j++) &#123; tmp[j] += str.charAt(k); &#125; //把复制并修改后的数组连接到arrRslt上 arrRslt = arrRslt.concat(tmp); &#125; &#125; &#125; return arrRslt; &#125; //两端去空格函数 String.prototype.trim = function () &#123; return this.replace(/(^\s*)|(\s*$)/g, ""); &#125; return getPy;&#125;)(); var names = ['张飞','关羽','刘备','曹操'] function sortName(names)&#123; var names_ = []; for(var i = 0;i&lt;names.length;i++)&#123; var a = getPy(names[i]); names_.push(a); &#125; return names_.sort(); &#125; console.log(sortName(names))]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>中文排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切换图标-总结方法]]></title>
    <url>%2F2018%2F07%2F21%2F%E5%88%87%E6%8D%A2%E5%9B%BE%E6%A0%87-%E6%80%BB%E7%BB%93%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 整体思路点击某个li 元素，替换其中img标签中的src属性，且要让其他的所有兄弟li元素变为默认的图片。由于每个li元素的默认图片和要替换的图片都不一样。难度就在此。 2. 需要注意的几个地方 每个li要使用的图片统一命名， 如：默认图片为： demo_d.png。点击切换图片为：demo_c.png 可以使用纯js来书写，因为如果使用jquery来遍历每个li元素的兄弟节点稍微有点麻烦。下面的代码使用纯为jquery，没有使用原生js，使用每个li元素的class来遍历兄弟节点，具体看代码注释。 如果各位看官有更好一点的方法，欢迎指正和分享。 3. 示例代码12345678910&lt;div class="personConLeft"&gt; &lt;ul&gt; &lt;li class="0"&gt;&lt;img src="../../static/img/personCenter/submit_d.png"/&gt; &lt;a &gt;我的发布&lt;/a&gt;&lt;/li&gt; &lt;li class="1"&gt;&lt;img src="../../static/img/personCenter/copro_d.png"/&gt;&lt;a&gt;我的合作&lt;/a&gt;&lt;/li&gt; &lt;li class="2"&gt;&lt;img src="../../static/img/personCenter/promote_d.png"/&gt;&lt;a&gt;我的推广&lt;/a&gt;&lt;/li&gt; &lt;li class="3"&gt;&lt;img src="../../static/img/personCenter/confirm_d.png"/&gt;&lt;a&gt;认证中心&lt;/a&gt;&lt;/li&gt; &lt;li class="4"&gt;&lt;img src="../../static/img/personCenter/money_d.png"/&gt;&lt;a&gt;钱包&lt;/a&gt;&lt;/li&gt; &lt;li class="5"&gt;&lt;img src="../../static/img/personCenter/set_d.png"/&gt;&lt;a&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344var index = 10;var flag = false;var oldIndex = 10;$('.personConLeft ul li').click(function()&#123;// 自己修改样式 $(this).css(&#123;'background':'#488eff','left':"-90px"&#125;);// 解除绑定的hover事件 $(this).unbind('mouseenter').unbind('mouseleave'); index = $(this).attr('class');// 修改字体颜色/图片src $(this).children('a').css(&#123;'color':'#fff'&#125;); var img_d = $(this).children('img').attr('src'); var img_c = img_d.replace(/_d/,'_c') $(this).children('img').attr('src',img_c); // 兄弟节点修改样式// 修改字体颜色/背景颜色 $(this).siblings().css(&#123;'background':'#fff'&#125;); $(this).siblings().children('a').css(&#123;'color':'#488eff'&#125;);// 将上一个保存的li,恢复鼠标移入移出动作 if(flag = true)&#123; $(this).siblings('.'+oldIndex).animate(&#123;left:"0"&#125;) $(this).siblings('.'+oldIndex).mouseenter(function()&#123; $(this).animate(&#123;left:"-90px"&#125;) &#125;) $(this).siblings('.'+oldIndex).mouseleave(function()&#123; $(this).animate(&#123;left:"0"&#125;) &#125;); &#125; flag = true; oldIndex = index; //拿到兄弟节点的个数 var len = $(this).siblings().length;// 根据class，循环修改每个兄弟节点中的图片src for(var i=0;i&lt;=len;i++)&#123; var img_d = $(this).siblings('.'+i).children('img').attr('src'); if(img_d)&#123; var img_c = img_d.replace(/_c/,'_d') $(this).siblings('.'+i).children('img').attr('src',img_c); &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>切换图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我爱上了一个姑娘]]></title>
    <url>%2F2018%2F02%2F14%2F%E6%88%91%E7%88%B1%E4%B8%8A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A7%91%E5%A8%98%2F</url>
    <content type="text"><![CDATA[我爱上了一个姑娘，姑娘的名字叫栾鑫，是我的高中同学。同窗两年，算到现在我们已经认识6年多了。她对我很重要，我们之间也发生了很多故事，这些故事都很令我难忘。想讲讲我和这个姑娘的故事。写给自己，也写给这位美丽的姑娘。 高中 我第一次看见她是在2012年，高二分了文理班之后，我们分到了一个班上。说实话，对她的第一印象还是挺模糊的。只是后面逐渐熟悉之后，我就一发不可收拾地被她吸引了。她的样子，她的声音，她的眉毛，她的手指，她的走路姿势，都吸引我（变态！青春期的傻小子观察还真仔细）可能从那时候开始，我的心里就隐隐觉着，我和她之间终究会发生些什么。 很多片段其实都没有多少印象了，下面几个在我脑中住了很久了，可能短时间内都是不会消失的，也可能这一辈子都不会消失。 高二: 第一次有目的的接触： 起初我们还不是很熟悉，只是知道名字的那种普通同学关系。但是我内心已经蠢蠢欲动了，总得想个办法来更好的认识吧。于是，在某节课间，我把自己的一本书偷偷地放在了她的课桌上。目的是让她把书给我送回来，也能多说几句话嘛，因为书上是有我的名字的。 果不其然，她看到一本陌生的书之后，便翻开书本找名字，然后叫我过去拿，嘿嘿嘿~当然拿书的过程中还是能多说几句话的，比如：“诶？我的书怎么跑你那儿去了？是不是你偷得!？”嘿嘿嘿~ 第一次表白 经过一段时间交流以及我不懈的努力，我们的关系也是越走越近啦！哈哈，那会儿可是还没有微信的，智能手机也是没有的。聊天还是用的功能机上的手机QQ。每天晚自习下了之后会聊一会儿，哈哈哈，别提有多开心了。 一天晚上，考虑良久，向她第一次表白，（人生第一次向女生表白）很遗憾，被拒绝了。具体的拒绝理由我是真忘了。不过好在是有进步啦，人家也知道了咱的心意啦。 闹别扭 经过第一次的表白失败，我当然是不会泄气的了（当时我的脸皮就这么厚了？），之后又接二连三地表达自己的心意，统统被拒绝。于是我们之间的关系降到了冰点，起初是她不和我说话，我一看这个情况，恶向胆边生，行，你不理我，我也不理你！（现在想想，真是有意思啊）。这个情况具体持续了多久，我也忘了，可能很短，但是对于当时的我来说却是很漫长的啊。（其实还是很想和她说话嘛，但又不想主动开口，哎，你说你就不能主动让让女生啊） 经过“很久”的“互相不理”，事情的发展终于迎来了转折——一次物理课后，她问我某道物理课后题。（那时我的物理成绩还是十分自信的）我怀着十分忐忑的心情帮她看完那道题，那道题的正确答案解开了，我们的别扭也解开了。 高二的在我脑海中的片段就是这些了，没有追求成功，但是对她的了解却是越来越深，她对我的了解也越来越深。而且放心，我是不会轻易放弃的，所以，高三的故事就更加精彩了。 高三：高三的前半段我没有很深的印象，好像也没发生什么值得记录的事情。最精彩的片段都发生在高三的后半段，也就是离高考最近的那段日子里。 那段日子，我一辈子都不会忘。 换座位（上） 进入高三，学业也重，压力也大，我也没有高二时得那样“疯狂”了，（以学业为重嘛！），但是你以为我和她就会这样平平淡淡地走完高中生活么？嘿嘿，有时候，生活比电视剧要精彩许多。 事情的导火索还是物理这门课。（大部分时候，学习好还是很有用的）。高三之后，就不换座位了，而她就坐在我的前面（她第一排，我第二排，她在我的左侧前方，我记得很清楚）。刚开始上物理课的时候，她有时候会扭回头来问我一些问题。久而久之，就会觉着有点麻烦，后来我索性在上物理课的时候，就和她旁边的那位同学换座位（那位同学应该是李娜，不是打网球的那个~）。 再久而久之，我还是觉着有点麻烦，就索性永久性地换了过去。就这样，我们成了同桌，嘿嘿。起初还担心班主任会找我谈话（我的班主任在高二的时候就知道了我对她的心思），想着能坐多久就坐多久吧，直到狠心的班主任将我俩拆散。 可是事情的发展并没有按照我的剧本走下去，班主任并没有“拆散”我俩，好像是默许了一样，哈哈哈。就这样，我们做起了同桌。（真的十分感谢刘晓燕老师） 换座位（下） 上面说了私自换座位成功后。之后又调换座位，事情具体发展过程忘记了，只记得结果是：我、她、王愿坚三个人做起来同桌（嗯，对，三个桌子一排）。我在中间，愿坚在我右边，她靠窗，在我左边。这个座位一直坐到我们毕业。 到这时候，我们之间的关系和高二时有了质的飞越，了解更深，对彼此也更加熟悉了。我每天早上会比她先到，因为她是跑校，而我住宿舍，我会比她来得稍微早点。（印象中是这样，可是我又记得我早上老迟到，啊呀，忘了忘了）来了之后会去打水，我就捎带着帮她把水打上。 中午，午休之后，往教学楼走的时候，有时候会碰上她，然后就一起上楼。这种情况出现过几次之后，每天中午往教学楼走的时候，我都掐着点，盼望着她也能准时到，这样就能一起上楼了。虽然在教室里也坐在一起。可是，那时候的我就是这样啊，（傻了吧唧的）。恨不得24小时都在一起。 坐在一起后，她会时不时得掐我，我记得有段时间我的左胳膊总是青一块紫一块的，（我到现在还不知道她为什么要掐我）。可是我当时只是觉得很开心，（傻了吧唧的）。 有一天，她突然发现我胳膊上的“水墨画”，便心疼地抱起我的胳膊揉啊揉，还问我疼不疼。（我的姑奶奶啊，这些都是您的作品啊，您竟然一直没发现？好了，看在你这么可爱又真心道歉的份上，就原谅你咯）。这之后，她好像也就不再掐我了。很怀念当初的水墨画啊~~也没个拍照留念什么的。 去高考的路上 不知不觉就要高考了，我们的同桌生涯也要结束了，同窗也要快结束了（幸福的日子总是过的飞快）。高考那天，我们是全班坐一辆大巴车去考场的。大巴的座位随便坐。我当然脸皮厚厚和已经坐在她旁边的王玲换了座位，而前面就站着我们的班主任。（班主任也只是看了一眼，嘿嘿）无论何时何地，都要坐在离她最近的地方。 在一起 高考完了，我们的高中生活就这样结束了。可是呢，我们的故事才算真正开始。 高考过后不超过一个礼拜的某个晚上，（原谅我，日子真忘了）我们照常在QQ上聊天，她突然和我说：“我们在一起吧”。哈哈，幸福来得太突然了。我坚持的东西不多，但是追她是我坚持最久的。于是我们便成为了各自的初恋。（甜蜜蜜 ~~ 你笑得甜蜜蜜 ~~ 好像花儿开在春风里~~ 开在春风里~~） 第一次约会 第一次约会应该在上面的那天的第二天，好像也没有去什么地方，就是去了汾河公园散散步，好像连饭都没吃。（哎，傻小子，以后要多请人家吃饭，还要让人家开心）。只是记得我坐公交到她家小区门口等她出来，心咚咚跳，哈哈。还记得那天她穿了一件白色的半袖，一件牛仔短裤，头发是批下来得。（记得还真清楚）然后坐车到某个桥，然后就一直散步。当然，手也拉了，嘴也亲了。二万五千里长征终于成功会师了！新中国终于成立了！我也终于可以牵着她的手漫漫散步了。 多年的心愿也终于实现了！中国共产党万岁！ 高中时期的事情就告一段落了，从刚开始的见面，到同学间得相处，再到表明心意，再到拒绝，（好几次），再到重归于好，再到相处慢慢融洽，直到最后终于走到一起。历时两年的时间，都是她和我最宝贵的青春。一切看起来都是那么完美，两个人手牵手结束美好的高中时期，携手走进18岁，终于可以正大光明的谈恋爱了~哦，妙不可语！ 可是，我们的故事到这里还没有完结~~就像前面说的，从我第一眼看到她，我就觉得我们之间肯定会发生些什么。好的事情水到渠成了，坏的事情也开始蠢蠢欲动。 （未完结）]]></content>
      <categories>
        <category>我的故事</category>
      </categories>
      <tags>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全屏事件]]></title>
    <url>%2F2018%2F01%2F10%2F%E5%85%A8%E5%B1%8F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前两天公司项目上需要用一下【进入全屏事件】，发现坑还是蛮多的，好在网上的资料也很多。在此做一个小小的总结吧。主要是几个Api。 1. 进入全屏123456789101112131415function fullScreen(element) &#123; if(element.requestFullScreen) &#123; element.requestFullScreen(); console.log("通用的进入全屏") &#125; else if(element.webkitRequestFullScreen) &#123; element.webkitRequestFullScreen(); console.log("webkit进入全屏") &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); console.log("火狐进入全屏") &#125; else if(element.msRequestFullscreen) &#123; element.msRequestFullscreen(); console.log("IE进入全屏") &#125; &#125; ​ 该方法需要制定一个element参数。比如：我的项目中是要让一个视频全屏播放，那么这个element参数就是我的video标签。以此类推。 ​ 当然也可以看到，不同的浏览器对该接口的支持标准也不一样。这也是做这个总结的主要原因。 2. 退出全屏123456789101112131415var exitFullScreen = function() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); console.log("通用的退出全屏") &#125; else if(document.msExitFullscreen) &#123; document.msExitFullscreen(); console.log("IE退出全屏") &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); console.log("火狐退出全屏") &#125; else if(document.webkitCancelFullScreen) &#123; document.webkitCancelFullScreen(); console.log("webkit退出全屏") &#125;&#125; 退出全屏的API和进入全屏差不多，也是各个浏览器“各自为战”，不尽相同。 与【进入全屏】不同的地方是：不需要传入参数，对象是document 监听进入或退出全屏 1234567891011121314var listenScreenChange = function() &#123;document.addEventListener("fullscreenchange", function() &#123; console.log("通用的全屏监听")&#125;, false); document.addEventListener("mozfullscreenchange", function() &#123; console.log("火狐全屏监听")&#125;, false); document.addEventListener("webkitfullscreenchange", function() &#123; console.log("webkit全屏监听")&#125;, false); document.addEventListener("MSFullscreenChange", function() &#123; console.log("IE全屏监听")&#125;, false);&#125; 此API需要注意： IE的全屏监听是MSFullscreenChange,其中的MS和Change的首字母都是需要大写的。 3. 全屏样式12345678910111213141516171819202122232425262728293031323334353637&lt;style type="text/css"&gt; div:-webkit-full-screen &#123; background: blue; &#125; div:-moz-full-screen &#123; background: blue; &#125; div:-ms-fullscreen &#123; background: blue; &#125; div:full-screen &#123; background: blue; &#125; div:fullscreen &#123; background: blue; &#125; /* deeper elements */ :-webkit-full-screen video &#123; width: 100%; height: 100%; &#125; /* styling the backdrop*/ ::backdrop &#123; /* properties */ &#125; ::-ms-backdrop &#123; /* properties */ &#125;&lt;/style&gt; 这是专门针对进入全屏后单独设置的样式。 4. 总结这些API使用起来还是很简单的，拿来就能用，只要注意不要将大小写写错就好。 还需要注意的几点： 这些方法只对IE11有用，低版本就算了。edge浏览器使用的是带webkit前缀的API。 进入全屏后，按esc键也可以退出全屏，但是不会触发上面的【退出全屏】事件。但是会触发【退出全屏】的监听事件。 在此处的【进入全屏】说的狭义上的全屏，即只是把你当作参数传入的某个节点以全屏显示。其余的element则不会显示在页面上。而我们广义上的全屏是：页面中的所有元素都以全屏显示，这时只要将html节点以参数传入即可。即： 12var html = document.querySelector('html');fullScreen(html);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>全屏事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo建好博客之后如何上传至Github]]></title>
    <url>%2F2017%2F12%2F21%2F%E4%BD%BF%E7%94%A8Hexo%E5%BB%BA%E5%A5%BD%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%87%B3Github%2F</url>
    <content type="text"><![CDATA[1. 问题描述之前就使用Hexo配合Github创建了一个个人博客，使用的还不错。但是最近突然出了一小问题，下面是问题描述： 创建新的博客之后，hexo g,hexo s之后，在本地的localhost:4000上可以看到新的文章生成，但是不能上传到我的Github仓库中。 我之前使用的上传方法是这样的： 自己写了一个脚本文件，文件内容如下： 123456hexo generatecp -R public/* .deploy/mpfly.github.iocd .deploy/mpfly.github.iogit add .git commit -m “update”git push origin master ​ 我很确定应该是我的上传方法出现了问题。 2. 解决问题发现了问题那就解决吧，换一种上传的方法。当然需要足够的简单和便利。 下面是新的方法： 在你的Hexo根目录下，执行npm install hexo-deployer-git --save 可以使用git的小黑框或者windows的。进行node组件安装。该组件是专门用来进行Github的上传。 打开Hexo的配置文件_config.yml，修改如下字段： 123456url: http://yourName.github.io/deploy: type: git repo: http://github.com/yourName/yourName.github.io.git branch: master 在此处需要注意几点： yml文件的字段名的冒号和后面的数据需要隔开一个空格，否则会报错。 此处的配置适用于你的Github仓库是没有分支的情况下，如果你的仓库有分支，需要将branch字段修改成你的分支名字。上面的url需要带上你的分支，并且还需要填写root字段，就在url下面。 上面的几个网址，其实是https协议的，但是我看到论坛上有人说会报错，所以就替换成http了。因为自己没有试，也不知道究竟是否会有影响。你们可以试试。 3. 总结以上就是配置了。现在将时间跳转至你已经写完了一篇新的文章，并且使用hexo g形成了静态页面，并且使用hexo s在本地浏览了一下。没问题之后就要把新的页面推到Github上了。你现在只需要在Hexo根目录执行hexo deploy就大功告成了。 好了，以上就是将Hexo博客推到Github上的一个小方法，配置起来还是比较简单，而且使用起来也很便利。]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次构建个人网站的记录]]></title>
    <url>%2F2017%2F12%2F04%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[很早之前就想构建一个属于自己的个人网站，自己设计样式，管理维护。但是一直没有进行相关的实践。 今天总算是成功了，也算是拥有了一个属于自己的“后花园了”。点击进入我的“后花园”下面我就来讲讲如何搭建一个属于自己的个人网站。 搭建个人网站需要两个东西：属于你自己的域名和一个虚拟主机。这两者都是要钱的。不过放心，都花不了很多。 首先来说说域名的注册我是在阿里云注册的域名，总共花费软妹币2元，期限是一年。步骤：进入阿里云，挑选你喜欢的域名。我就选了一个价格为2块钱的顶级域名为.top的域名。 域名注册之后，需要租用一个虚拟主机因为我之前也没有操作过，所以也是一步一步来。 打开浪点官网 注册账号，只需要你的一个常用邮箱进行注册。它随后将会把用户名和密码发送至你的邮箱，然后进行登录 登录成功之后会出现以下页面 4.点击【新购空间】，选择合适你的进行购买。我第一次搞这个，有点玩玩的心态，所以就买了第一个12元一个月的。先试试看。 5.购买之后，会出现下面的页面。将你之前注册的域名输入。点击【添加域名绑定】。（注意：添加域名绑定会有三分钟的延迟）。添加域名绑定，然后记住FTP主机FTP用户FTP端口和FTP密码 6.回到阿里云，进行下面的操作 在这里点击【添加解析】，随后跳出下面弹框。记录类型选择【A】；主机记录填写【www】；解析线路选择【默认】;记录值填写刚刚你的虚拟主机的FTP主机IP值。点击确认。 最后，下载FlashFXP并安装打开。进入FlashFXP主界面后点击站点→ 站点管理器→ 新建站点。输入名称（随便起一个名字）后出现如下页面，地址输入：浪点云FTP主机下的IP地址；用户名：FTP用户；密码：FTP的用户密码，然后点击连接保存。 设置完成之后就是这个页面 左边是你本地电脑上的文件。右边是你的空间（也就是你输入你的网址后能看到的页面）。这之后你就可以自己发挥自己的能力，做一个好的页面放到右边，然后在浏览器输入你的网址。可能第一次会访问失败，只要清理一下浏览器的缓存即可。 好了，以上就是一个简单的个人网站的搭建。总共花费14元。]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>建立个人网站</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CSS样式]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%B8%B8%E7%94%A8css%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[颜色渐变颜色渐变菜鸟教程 1background-image: linear-gradient(65deg, #3EB0BA 0%, #3692B8 100%); 修改placeholder样式123456789101112131415input::-webkit-input-placeholder&#123; color: #A9A9A9; font-size: 14px; letter-spacing: 1px;&#125;input::-moz-placeholder&#123; color: #A9A9A9; font-size: 14px; letter-spacing: 1px;&#125;input::-ms-input-placeholder&#123; color: #A9A9A9; font-size: 14px; letter-spacing: 1px;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>常用查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3的媒体查询]]></title>
    <url>%2F2017%2F11%2F21%2FCSS3%E7%9A%84%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[准备工作1：设置Meta标签首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 准备工作2：加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果： 1234&lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 准备工作3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加) 1&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge，chrome=1"&gt; 怎么这段代码后面加了一个chrome=1，这个Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，无比给力，不过如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。这段代码我还是建议你们用上，不过不用也是可以的。 进入CSS3 Media写法我们先来看下下面这段代码，估计很多人在响应式的网站CSS很经常看到类似下面的这段代码： 12345@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它下面的CSS.这个应该没有太大疑问。 应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写： 123456@media (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现等于960px尺寸的代码： 12345@media screen and (max-device-width:960px)&#123; body&#123; background:red; &#125;&#125; 然后就是当浏览器尺寸大于960px时候的代码了： 12345@media screen and (min-width:960px)&#123; body&#123; background:orange; &#125;&#125; 我们还可以混合使用上面的用法： 12345@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123; background:yellow; &#125;&#125; 上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。 在样式表链接中使用媒体查询 123&lt;link rel="stylesheet" href="styles/mainstyles.css"&gt;&lt;link rel="stylesheet" href="styles/widerscreen.css"media="only and (min-width:40em)"&gt; 视口宽度和高度（媒体查询中最常用到的设备属性） 视口宽度：width视口高度：height视口指的是浏览器窗口中实际包含网页的那部分区域。浏览器窗口减去页面边上的滚动条，以及顶部或底部的工具栏和菜单，剩下的区域就是视口。 屏幕宽度与高度 屏幕宽度：device-width屏幕高度：device-height 1@media only screen and (max-device-width:40em) &#123;...&#125; 方向：orientation值为：横排方向（ landscape）竖排方向（portrait） 1@media only screen and (orientation:landscape) &#123;...&#125; 宽高比 视口宽高比：aspect-ratio设备屏幕宽高比：device-aspect-ratio常见的显示器宽高比时16:9（如19201080或1366768像素）或者是16:10（1280800）。iphone 3和iphone 4s是3:2（480320和960640），而iPhone 5则是16:9（1136640）。安卓手机通常是4:3、3:2、16:10或16:9。 1@media only screen and (min-device-aspect-ratio:16/9) &#123;...&#125; 分辨率设备屏幕的分辨率：resolution 1@media only screen and (resolution:3oodpi) &#123;...&#125; 作者：味蕾里的青春链接：http://www.jianshu.com/p/2dfa5bab1ef1著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 链接2：转载自这里]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper_3 的使用]]></title>
    <url>%2F2017%2F11%2F21%2Fswiper_3%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[swiper在版本3和4之间的配置文件还是有所差异的，所以，写一下3的使用。大部分的配置文件3和4还是差不多的，用起来区分好就可以了。 HTML123456789101112131415161718192021222324252627&lt;div class="swiper-container" id="Pic"&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide swiper-slide-active swiper-slide-next" index="1" style="text-align: center;"&gt; &lt;div class="swiper-zoom-container"&gt; &lt;a&gt;&lt;img src="/static/css/img/code-wallpaper-8.jpg" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-slide swiper-slide-active swiper-slide-next" index="2" style="text-align: center;"&gt; &lt;div class="swiper-zoom-container"&gt; &lt;a&gt;&lt;img src="/static/css/img/code_by_rasmusir-d4a4dj2.jpg" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-slide swiper-slide-active swiper-slide-next" index="2" style="text-align: center;"&gt; &lt;div class="swiper-zoom-container"&gt; &lt;a&gt;&lt;img src="/static/css/img/code-wallpaper-18.png" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-slide swiper-slide-active swiper-slide-next" index="2" style="text-align: center;"&gt; &lt;div class="swiper-zoom-container"&gt; &lt;a&gt;&lt;img src="/static/css/img/code-wallpaper-16.jpg" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; 配置文件12345678910111213141516171819202122232425262728var mySwiper = new Swiper('.swiper-container', &#123; centeredSlides: true, loop: true, slidesPerView: '1', effect: 'slide', initialSlide: 0, observer: true, zoom:true, //自动播放 autoplay: 3000, //鼠标操作之后是否继续自动轮播 autoplayDisableOnInteraction : false, //分页 pagination: '.swiper-pagination', //分页样式，以下三种：// ‘bullets’ 圆点（默认）// ‘fraction’ 分式 // ‘progress’ 进度条 paginationType : 'progress', //前进后退按钮 nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', //滚动条 scrollbar:'.swiper-scrollbar', &#125;);]]></content>
      <categories>
        <category>JS插件</category>
      </categories>
      <tags>
        <tag>swiper.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper_4 的使用]]></title>
    <url>%2F2017%2F11%2F15%2Fswiper_4%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近使用了swiper，感觉还是很不错的，比较易用，而且拓展性和兼容性都很好。就是需要在使用的时候配置一些东西。下面是swiper_4版本中的一些常用的配置项。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/swiper.css"/&gt; &lt;style type="text/css"&gt; .swiper-container &#123; width: 800px; height:400px; &#125; img&#123; width: 100%; height:100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="swiper-container"&gt; &lt;!--&lt;div class="swiper-scrollbar"&gt;&lt;/div&gt;--&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt;&lt;div class="swiper-zoom-container"&gt;&lt;img src="img/code-wallpaper-16.jpg"/&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="swiper-slide"&gt;&lt;div class="swiper-zoom-container"&gt;&lt;img src="img/code-wallpaper-18.png" /&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class="swiper-slide"&gt;&lt;div class="swiper-zoom-container"&gt;&lt;img src="img/code-wallpaper-22.jpg" /&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="swiper-slide"&gt;&lt;div class="swiper-zoom-container"&gt;&lt;img src="img/code-wallpaper-8.jpg" /&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt;&lt;div class="swiper-zoom-container"&gt;&lt;img src="img/code_by_rasmusir-d4a4dj2.jpg"/&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt;&lt;div class="swiper-zoom-container"&gt;&lt;img src="img/maxresdefault.jpg" /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript" src="js/swiper.min.js"&gt;&lt;/script&gt; &lt;script&gt; var swiper = new Swiper(&#123; el: '.swiper-container', //slide的切换效果，默认为"slide"（位移切换），可设置为'slide'（普通切换、默认）,"fade"（淡入）"cube"（方块）"coverflow"（3d流）"flip"（3d翻转）。// effect: 'coverflow', //开启焦距功能 zoom:true, loop:true, //初始化显示哪个滑块，从0开始 initialSlide:0, //slide之间的距离（单位px） spaceBetween: 5, //每页显示多少个图片 slidesPerView: 3, //设定为true时，活动块会居中，而不是默认状态下的居左,(carousel模式) centeredSlides: false, //设置为true则点击slide会过渡到这个slide slideToClickedSlide: true, //变手 grabCursor: true, //多行布局里面每列的slide数量。// slidesPerColumn: 2, //默认为false，普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动且不会贴合// freeMode:true, //添加滚动条 scrollbar: &#123; el: '.swiper-scrollbar', &#125;, //开启鼠标滚轮翻页 mousewheel: &#123; enabled: true, &#125;, //开启键盘翻页 keyboard: &#123; enabled: true, &#125;, //添加分页导航 pagination: &#123; el: '.swiper-pagination', clickable: true, &#125;, //前进后退按钮 navigation: &#123; nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', &#125;, autoplay: &#123; delay: 3000, //用户操作swiper之后，是否禁止autoplay。默认为true：停止。 //如果设置为false，用户操作swiper之后自动切换不会停止，每次都会重新启动autoplay。 //操作包括触碰，拖动，点击pagination等。 disableOnInteraction: false, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JS插件</category>
      </categories>
      <tags>
        <tag>swiper.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中箭头函数的使用]]></title>
    <url>%2F2017%2F10%2F27%2FES6%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[作者：Allan要做活神仙链接：http://www.jianshu.com/p/4b101a763e85來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ES6标准新增了一种新的函数：Arrow Function（箭头函数）。箭头函数与传统的JavaScript函数主要区别在于以下几点：、 1、对 this 的关联。函数内置 this 的值，取决于箭头函数在哪儿定义，而非箭头函数执行的上下文环境。2 、new 不可用。箭头函数不能使用 new 关键字来实例化对象，不然会报错。3、this 不可变。函数内置 this 不可变，在函数体内整个执行环境中为常量。4、没有arguments对象。更不能通过arguments对象访问传入参数。只能使用显式命名或其他ES6新特性来完成。 这些差异的存在是有理可循的。首先，对this的绑定是JavaScript错误的常见来源之一。容易丢失函数内置数值，或得出意外结果。其次，将箭头函数限制为使用固定this引用，有利于JavaScript引擎优化处理。 语法 不引入参数 12345var sum = () =&gt; 1 + 2;// 等同于：var sum = function() &#123; return 1 + 2; &#125;; 引入单个参数 12345var reflect = value =&gt; value;// 等同于：var reflect = function(value) &#123; return value;&#125;; 引入多个参数 123456//要加上小括号var sum = (num1, num2) =&gt; num1 + num2;// 等同于：var sum = function(num1, num2) &#123; return num1 + num2; &#125;; 若你想使用标准的函数体，或者函数体内可能有更多的语句要执行，则要用大括号将函数体括起来，并明确定义返回值。 123456//大括号内的部分基本等同于传统函数var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;//等同于：var sum = function(num1, num2) &#123; return num1 + num2; &#125;; 箭头函数若要返回自定义对象的话，就必须用小括号把该对象括起来 123456789101112//用小括号包含大括号则是对象的定义，而非函数主体var getTempItem = id = &gt; (&#123; id: id, name: "Temp"&#125;);// 等同于:var getTempItem = function(id) &#123; return &#123; id: id, name: "Temp" &#125;;&#125;; 本文转载自：作者：Allan要做活神仙链接：http://www.jianshu.com/p/4b101a763e85來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常用缩写]]></title>
    <url>%2F2017%2F10%2F25%2FCSS%E5%B8%B8%E7%94%A8%E7%BC%A9%E5%86%99%2F</url>
    <content type="text"><![CDATA[border12345678910111213141516/*缩写前*/element&#123; border-top-width:1px; border-top-style:solid; border-top-color:#cccccc;&#125;element&#123; border-top:1px solid #cccccc; border-left:1px solid #cccccc; border-right:1px soli #cccccc; border-bottom:1px solid #cccccc;&#125;/*缩写后*/element&#123; border:1px solid #ccc;&#125; background12345678910111213/* 缩写前 */element&#123; background-color:#ccc; background-image:url(sample.gif); background-repeat:repeat-x; background-attachment:scroll;//scroll是背景图像随对象内容滚动为默认值，可以不写 background-position:top right;&#125;/* 缩写后 */element&#123; background:#ccc url(sample.gif) repeat-x top right; //属性依次为：颜色-背景图-X轴平铺-背景图像位置(背景图片路径不需要加引号)&#125; margin1234567891011element&#123; margin-top:15px; margin-right:20px; margin-bottom:12px; margin-left:24px; &#125;/*缩写后*/element&#123; margin:15px 20px 12px 24px; //上，右，下，左 &#125; padding1234567891011element&#123; padding-top:15px; padding-right:20px; padding-bottom:12px; padding-left:24px; &#125;/*缩写后*/element&#123; padding:15px 20px 12px 24px; //上，右，下，左 &#125; font123456789101112131415element&#123; font-style:italic //设置或检索对象中的字体样式 font-variant:normal //设置或检索对象中的文本是否为小型的大写字母 //前2项如果没有特殊设置，可以不写，用默认值即可 font-weight:bold; font-size:12px; line-height:20px; font-family:"宋体"; &#125;/*缩写后*/element&#123; font:bold 12px/20px "宋体"; //属性依次为：字体的粗细 - 字体大小/行高 - 文本的字体 &#125; list-style123456789101112element&#123; list-style-image:url(sample.gif); list-style-position:outside; list-style-type:circle; &#125;/*缩写后*/element&#123; list-style:circle inside url(sample.gif);&#125;/*属性依次为：预设标记 - 标记位置 - 标记图片(标记图片路径不需要加引号)，预设标记和标记图片可二选一，如果二者都定义，则标记图片覆盖预设标记，不过在项目中基本都是用背景图片进行定义；*/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>常用查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应和响应式的区别]]></title>
    <url>%2F2017%2F10%2F25%2F%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[自适应的目的是在不同分辨率的不同设备上面显示相同的页面。 手机的屏幕比较小，宽度通常在600像素以下，PC的像素一般在1000像素以上，部分配置高的笔记本在2000像素以上的也有，同样的页面要显示在不同的设备上面，还要呈现出满意的效果，不是一件容易的事情。因此就有人想出了一个办法，能不能”一次设计，普遍适用”，让同一张网页自动适应不同大小的屏幕，根据屏幕的宽度，自动调节网页的内容大小，但是无论怎么样子，他们的主体的内容和布局是没有变化的。 响应式的概念应该是覆盖了自适应，但是包括的东西更多了。响应式布局可以根据屏幕的大小自动的调整页面的展现方式，以及布局。 响应式布局的一些技术点纪录： 允许网页的宽度自动的调整 尽量少使用绝对的宽度，多点百分比 相对大小的字体:字体不要使用px写死，最好使用相对大小的em，或者高清方案rem，这个不限制与字体，别的属性也可以这么设置 流式布局，float等float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 选择加载css， &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (max-device-width: 400px)&quot; href=&quot;tinyScreen.css&quot; /&gt; 这个意思是如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session与cookie的区别？cookies，sessionStorage 和localStorage的区别？]]></title>
    <url>%2F2017%2F10%2F24%2Fsession%E4%B8%8Ecookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fcookies%EF%BC%8CsessionStorage%20%E5%92%8ClocalStorage%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[cookie和session的区别1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 cookies，sessionStorage和localStorage的区别 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp使用]]></title>
    <url>%2F2017%2F10%2F22%2Fgulp%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[为什么要使用gulp来说说为什么要使用gulp等类似的前端自动化工具吧，用它之前总得知道为什么要用吧。 我们在完成一个复杂项目的时候，可能会用到less或者sass。还会创建很多的js。当然还有很多的图片文件。如果这些文件很少，那问题不大。项目跑起来也没有什么性能的忧虑（浏览器的性能）。如果js、css、图片文件很多、很大时，浏览器渲染起来就有点吃力了。我们需要把这些“庞大的”文件进行压缩，去掉其中的无用的空格和回车。来减小他们的体积。并将他们合并–将多个文件合并成一个，这样也可以有效的提高浏览器的效率。 当然，我们可以选择手动来压缩和合并这些文件。可是上文也已经说了，文件很多，很大。你还愿意手动来干这些简单且重复的工作吗？ 所以，聪明的人总是很懒的。他们发明出了诸如grunt和gulp这样的自动化工具。让你只需要配置一遍，就可以让它来重复地完成这些“低级”的任务。 如何使用gulp下面是几个gulp中常用的例子。前提：windows系统，已装好nodeJS，已装好了gulp。 1. 编译less文件 在你的项目中安装相应的gulp插件。我这儿使用的是gulp-less. 在你的项目目录中，安装npm install gulp-less 创建gulpfile.js文件，这是gulp的配置文件。如果熟悉nodeJS的同学会很熟悉这样的语法。require相应的模块，下面的gulp.task()就是gulp特有的了。task翻译过来是任务的意思。该方法下两个参数： 第一个是该任务的名称，你可以在之后的小黑框中通过gulp [任务名称]来调用。 第二个参数是一个函数，用来放你要执行的方法。 1234567891011var gulp = require('gulp'); less = require('gulp-less');//编译lessgulp.task('testLess', function() &#123; gulp.src('less/index.less')//该任务针对的文件 .pipe(less())//该任务调用的模块 .pipe(gulp.dest('css'));//将会在src/css下生成index.css&#125;);//定义默认任务gulp.task('default', ['testLess']); 配置完成之后，在该项目下打开小黑框，输入gulp testless或者只输入gulp，如果只输入gulp将会执行配置文件中的默认任务，该默认任务名字为”default”。 2. 压缩css文件 安装插件npm install gulp-minify-css 创建gulpfile.js文件 123456789var gulp = require('gulp'); minifycss = require('gulp-minify-css'); gulp.task('minifycss', function() &#123; gulp.src('css/*.css') //要压缩的文件 .pipe(minifycss()) //执行压缩 .pipe(gulp.dest('min.css')); //输出文件夹&#125;);gulp.task('default', ['minifycss']); 执行：gulp minifycss或gulp 3. 合并压缩js文件 安装插件 合并：npm install gulp-concat 压缩js：npm install gulp-uglify 重命名：npm install gulp-rename 创建gulpfile.js文件 1234567891011121314151617var gulp = require('gulp'); uglify = require('gulp-uglify'); concat = require('gulp-concat'); rename = require('gulp-rename'); //合并压缩js文件gulp.task('minifyjs', function () &#123; gulp.src('js/*.js')//拿到该文件夹下的所有js文件 .pipe(concat('main.js'))//合并成main.js文件,还没有压缩 .pipe(gulp.dest('main'))//将main.js放入该文件夹下 .pipe(rename(&#123;suffix: '.min'&#125;)) //rename压缩后的文件名 .pipe(uglify())//进行压缩 .pipe(gulp.dest('min.js'));//将合并、压缩之后的文件保存在这个目录下&#125;);//定义默认任务gulp.task('default', ['minifyjs']); 执行：gulp minifyjs或gulp 总结​ 好了，以上就是gulp中比较常用的插件，写此总结。其实配置文件还有很多好玩的东西。比如： pipe()，pipe翻译过来是管道的意思。相信大家看gulp简介的时候会看到，gulp是基于管道流实现的。当然，我对这个“管道流”也实在是了解不深，但是可以从代码上看出一二。 ​ 配置文件中的task()方法中都是链式编程，从gulp.src()选择源头开始，一个pipe()方法链接着一个pipe()方法，直到最后进入gulp.dest()方法输出来。src()方法选择要操作的文件，每通过一个管道，进行一次处理，到最后dest()方法，完成所有操作后，指定一个文件夹输出出来。 ​ 像上面的合并压缩js任务，就需要好几条“管道”进行链接。第一个管道进行合并操作，第二个将上一个管道处理完成的输出出去并传递给的第三个，第三个将拿到后进行压缩，第四个重命名，知道最后将合并且压缩且重命名的文件输出出去。这就完成了一次“格式化”。 默认任务： ​ 配置文件中有一个默认任务，当你在小黑框中输入gulp时，默认执行该方法。该方法的第二个参数是一个数组，将你定义好的人物依次放入该数组中，你只需要在gulp一次，就会依次执行，得到最后的结果。 当然，要学习和研究的东西还有很多。Stay Hungry,Stay Foolish.]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改input的type属性的几种方法]]></title>
    <url>%2F2017%2F10%2F19%2F%E4%BF%AE%E6%94%B9input%E7%9A%84type%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[时隔两年，做了些许完善。以下是新的代码，html代码不变。12345678910111213141516171819202122232425262728293031323334&lt;script type="text/javascript"&gt; // 通过js修改 function change()&#123; let password = document.getElementById("password") if(password.type === "password")&#123; password.type = "text" &#125;else&#123; password.type = "password" &#125; &#125;; $(function()&#123; // 通过jqurey修改 $(".btn").click(function()&#123; let type = $("#demo2").attr('type') if(type === "password")&#123; $("#demo2").attr("type","text"); &#125;else&#123; $("#demo2").attr("type","password"); &#125; &#125;); // 通过replaceWith方法修改 $(".btn02").click(function()&#123; let type = $("#demo3").attr('type') let info = $("#demo3").val() if(type === "password")&#123; $("#demo3").replaceWith(`&lt;input value="$&#123;info&#125;" type="text" name="demo3" id="demo3"/&gt;`); &#125;else&#123; $("#demo3").replaceWith(`&lt;input value="$&#123;info&#125;" type="password" name="demo3" id="demo3"/&gt;`); &#125; &#125;) &#125;); &lt;/script&gt; —————————————- 以下是原答案—————————————————- 通过js直接改，在IE9以下是不行的。 通过jquery的attr方法修改，在IE9以下也是不行的。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;修改type属性&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function change()&#123; document.getElementById("password").type = "password"; &#125;; $(function()&#123; $(".btn").click(function()&#123; $("#demo2").attr("type","password"); &#125;); $(".btn02").click(function()&#123; $(".demo3").replaceWith('&lt;input type="password" name="demo3" id="demo3" value="" /&gt; &lt;button class="btn02"&gt;通过replace方法修改&lt;/button&gt;'); &#125;) &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="js"&gt; &lt;input type="text" name="password" id="password" value="" /&gt; &lt;button id="changeType" onclick="change()"&gt;通过js修改&lt;/button&gt; &lt;/div&gt; &lt;div class="jquery"&gt; &lt;input type="text" name="demo2" id="demo2" value="" /&gt; &lt;button class="btn"&gt;通过jqurey修改&lt;/button&gt; &lt;/div&gt; &lt;div class="demo3"&gt; &lt;input type="text" name="demo3" id="demo3" value="" /&gt; &lt;button class="btn02"&gt;通过replaceAll方法修改&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遮罩层的简单实现]]></title>
    <url>%2F2017%2F10%2F19%2F%E9%81%AE%E7%BD%A9%E5%B1%82%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[主要就是操作opacity这一属性。不透明度。IE9以上, Firefox, Chrome, Opera 和 Safari 使用属性 opacity 来设定透明度。opacity 属性能够设置的值从 0.0 到 1.0。值越小，越透明。IE8 以及更早的版本使用滤镜 filter:alpha(opacity=x)。x 能够取的值从 0 到 100。值越小，越透明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;遮罩层&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .mask&#123; width: 100%; height: 100%; display: none; position: absolute; top: 0px; left: 0px; background-color: #777; z-index: 100; /*透明度*/ /*ie9以下*/ filter:alpha(opacity=40); /*火狐*/ -moz-opacity: 0.4; opacity: 0.4; &#125; .hideMask&#123; position: absolute; top: 100px; left: 300px; z-index: 102; display: none; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; $(function()&#123; var mask = $(".mask"); var hideMask = $(".hideMask"); $('.showMask').click(function()&#123; mask.show(); hideMask.show(); &#125;); hideMask.click(function()&#123; mask.hide(); hideMask.hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="mask"&gt; &lt;/div&gt; &lt;button class="hideMask"&gt;关闭遮罩层&lt;/button&gt; &lt;button class="showMask"&gt;显示遮罩层&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>遮罩层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带有动态效果得返回顶部]]></title>
    <url>%2F2017%2F10%2F18%2F%E5%B8%A6%E6%9C%89%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C%E5%BE%97%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[之前做“返回顶部”，一直都是无动态效果的。瞬间就回到了顶部。这次写一个带有动态效果的。也就是利用animate方法来实现。下面是具体代码。 HTML:12345678&lt;body&gt; &lt;div class="content"&gt; &lt;p&gt;这是测试文档&lt;/p&gt; ... &lt;p&gt;这是测试文档&lt;/p&gt; &lt;/div&gt; &lt;button class="toTopBtn" &gt;回到顶部&lt;/button&gt;&lt;/body&gt; JS:12345678910111213141516171819202122&lt;script type="text/javascript"&gt; /*ie9以上(包括)*/ $(function()&#123; $(document).scroll(function()&#123; //页面滚动，按钮出现 $(".toTopBtn").show(); //如果滚动到最上面，按钮将会消失 if($(document).scrollTop() == 0) &#123; $(".toTopBtn").hide(); &#125; &#125;); $(".toTopBtn").click(function()&#123; //此处无动态效果，瞬间回到顶部 //$(document).scrollTop(0); //此处利用animate动画添加动态效果 $('html').animate(&#123;scrollTop:0&#125;,300); &#125;); &#125;);&lt;/script&gt; CSS:12345678910111213141516&lt;style type="text/css"&gt; .toTopBtn &#123; display: none; position: fixed; bottom: 30px; right: 20px; width: 50px; height: 50px; font-size: 12px; text-align: center; background-color: #0033FF; cursor: pointer; font-weight: 600; border-radius: 8px; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>返回顶部</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block，inline和inline-block概念和区别]]></title>
    <url>%2F2017%2F10%2F16%2Fblock%EF%BC%8Cinline%E5%92%8Cinline-block%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[总体概念 block和inline这两个概念是简略的说法，完整确切的说应该是 block-level elements (块级元素) 和 inline elements (内联元素)。block元素通常被现实为独立的一块，会单独换一行；inline元素则前后不会产生换行，一系列inline元素都在一行内显示，直到该行排满 大体来说HTML元素各有其自身的布局级别（block元素还是inline元素）： 常见的块级元素有 DIV, FORM, TABLE, P, PRE, H1~H6, DL, OL, UL 等。 常见的内联元素有 SPAN, A, STRONG, EM, LABEL, INPUT, SELECT, TEXTAREA, IMG, BR 等。 block元素可以包含block元素和inline元素；但inline元素只能包含inline元素。要注意的是这个是个大概的说法，每个特定的元素能包含的元素也是特定的，所以具体到个别元素上，这条规律是不适用的。比如 P 元素，只能包含inline元素，而不能包含block元素。 一般来说，可以通过display:inline和display:block的设置，改变元素的布局级别。 block，inline和inlinke-block细节对比 display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性 ​]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在input框之前添加图标]]></title>
    <url>%2F2017%2F10%2F16%2F%E5%9C%A8input%E6%A1%86%E4%B9%8B%E5%89%8D%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[在input框之前添加图片，想到了三种方法。 第一种，添加input背景图片，实现起来很简单，但是要求必须将图片放到输入框的右侧，否则会出现文字和图片重合的问题，现在自己暂时还不能解决此问题。下面是代码： 12345678910&lt;style&gt; #password&#123; width: 200px; height: 35px; outline: none; border: 1px solid blue; background: url(img/pass02.svg) no-repeat right ; &#125;&lt;/style&gt;&lt;input type="password" name="password" id="password" value="" /&gt;&lt;br /&gt; 第二种，在input框外部添加图片，再通过样式调整位置。比较麻烦。而且位置设置不灵活。详细设置点击 第三种是我自己想的，代码如下： 12345678910111213141516&lt;style&gt; #img&#123; width: 73px; height: 26px; background: url(img/pass02.svg) no-repeat right; display: inline-block; &#125;&lt;/style&gt;&lt;div id=""&gt; &lt;span id="img"&gt; 密码： &lt;/span&gt; &lt;input type="text" name="password" id="password" value="" /&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用sessionStorage实现返回上一页直接到离开时的位置]]></title>
    <url>%2F2017%2F10%2F13%2F%E4%BD%BF%E7%94%A8sessionStorage%E5%AE%9E%E7%8E%B0%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E9%A1%B5%E7%9B%B4%E6%8E%A5%E5%88%B0%E7%A6%BB%E5%BC%80%E6%97%B6%E7%9A%84%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[使用sessionStorage实现，在返回到之前浏览的页面时，直接将页面展示到用户刚刚浏览的位置，而不是重新刷新页面到了页面顶部。 代码1234567891011121314151617181920212223//page01.html&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(".btn").click(function() &#123; if($(document).scrollTop() != 0) &#123; sessionStorage.setItem("a", $(window).scrollTop()); &#125; &#125;); window.onload = function() &#123; var _offset = sessionStorage.getItem("a"); $(document).scrollTop(_offset); &#125;;&lt;/script&gt;&lt;body&gt; &lt;p&gt;这是一行的信息&lt;/p&gt; &lt;p&gt;这是一行的信息&lt;/p&gt; ... &lt;p&gt;这是一行的信息&lt;/p&gt; &lt;p&gt;这是一行的信息&lt;/p&gt; &lt;a href="page02.html" class="btn"&gt;跳转页面&lt;/a&gt;&lt;/body&gt; 12345//page02.html&lt;body&gt; &lt;h1&gt;这是页面2&lt;/h1&gt; &lt;a href="index.html"&gt;回到页面1&lt;/a&gt;&lt;/body&gt; 代码解释用户点击”跳转页面按钮“，拿到滚动位置，存入sessionStorage中。在页面onload()时，拿到存在sessionStorage中的滚动位置数据，滚动到相应的位置。 其他具体的sessionStorage和localStorage的解释和使用方法]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>sessionStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2017%2F10%2F10%2FTCP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IP 是不同的通信协议的大集合。协议族TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。 TCP - 传输控制协议TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。 IP - 网际协议（Internet Protocol）IP 负责计算机之间的通信。IP 负责在因特网上发送和接收数据包。 HTTP - 超文本传输协议(Hyper Text Transfer Protocol)HTTP 负责 web 服务器与 web 浏览器之间的通信。HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。 HTTPS - 安全的 HTTP（Secure HTTP）HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。 SSL - 安全套接字层（Secure Sockets Layer）SSL 协议用于为安全数据传输加密数据。 SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）SMTP 用于电子邮件的传输。 MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。 IMAP - 因特网消息访问协议（Internet Message Access Protocol）IMAP 用于存储和取回电子邮件。 POP - 邮局协议（Post Office Protocol）POP 用于从电子邮件服务器向个人电脑下载电子邮件。 FTP - 文件传输协议（File Transfer Protocol）FTP 负责计算机之间的文件传输。 NTP - 网络时间协议（Network Time Protocol）NTP 用于在计算机之间同步时间（钟）。 DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）DHCP 用于向网络中的计算机分配动态 IP 地址。 SNMP - 简单网络管理协议（Simple Network Management Protocol）SNMP 用于计算机网络的管理。 LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。 ICMP - 因特网消息控制协议（Internet Control Message Protocol）ICMP 负责网络中的错误处理。 ARP - 地址解析协议（Address Resolution Protocol）ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。 RARP - 反向地址转换协议（Reverse Address Resolution Protocol）RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。 BOOTP - 自举协议（Boot Protocol）BOOTP 用于从网络启动计算机。 PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）PPTP 用于私人网络之间的连接（隧道）。]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-10-07 周六]]></title>
    <url>%2F2017%2F10%2F07%2F%E6%97%A5%E8%AE%B0%20-%202017-10-07%20%E5%91%A8%E5%85%AD%2F</url>
    <content type="text"><![CDATA[10月7号 23:59 家里厕所算算今天在家待了七天。明天又得出来，去北京了。说实话，并没有想象中那么困难，有多么舍不得离开。反而稍微有一点点期待吧！对于在后半年的北京的工作和生活的一个小小的期待。这可能是一个成长吧~~ 还记得7月4号，也就是离开家去北京的前一天。心里还是有那种舍不得的。而今天就没有那么严重。更多的是对未来的一种计划和期待吧。想为这个家和父母做更多的一点事情。既然想做这些事情就不能总在家呆着吧~需要去外面闯一闯，见一见世面。挣些钱~ 回来的这些天还是很开心的。 1号回来就10点了，进门妈在包饺子。边吃饺子边和妈聊天，很晚才睡。 2号去医院看了爸，做了个小手术，第二天就出院。从医院回来3点多，躺在沙发上看了会儿电视就去张轩家干活~晚上和几个哥们一起吃了饭，回来就快10点了。还是躺在沙发上看了会儿电视就睡了。那天家里没人。 3号早上9点多坐姐夫的车去医院，接爸妈回来。回来就2点多。一家人吃了饭，和姐夫喝了酒。下午睡了一下午，到5点多。出发去长风街跟高中同学聚会。坐858到地点就7点了，嗨了一晚上，很高兴。 4号早上8点多在聚会地点起床，然后坐858回家，回来的路上就接到渠成的电话，让过去干活。回来9点多不到10点。在家简单吃了点饭，就去张轩家了。一早上给他干活，中午在大厅吃了饭，就回来休息了。和爸在沙发上看电视就睡着了，睡了一下午。很累啊~~晚上还得出去，因为第二天就得去娶了。晚上又在张轩家呆到2点多。然后回家。 5号，娶媳妇。早上8点起来，去大厅吃了饭就准备出发。不到10点坐车去饭店，娶回来玩了玩。去大厅吃饭。吃了饭也就1点多了。吃了饭回来还是在沙发上躺了一会儿就又睡着了。 6号，也就是昨天，起来就11点了，睡了个懒觉感觉这几天都很累因为妈去有根家事宴，所以中午自己做了面吃。下午去办高清盒子，办了很久。之后就骑车子回了趟村里，简单看5看。然后又去了蒙山大道。晚上回来吃饭。。 7号，也就是今天，起来也就快10点了。和爸聊天，早上一直下雨。10点多我出去到六味斋买杂酱，但是没有。取了3000，留在家里。等明天走了以后再给妈打个电话告诉一声吧。下午吃了饭我又睡了一觉，这两天一直在睡觉~~起来就4点了。赶紧和爸收拾行李。把被子乱七八糟的都塞进行李箱里面去了。晚上姐姐姐夫和任鑫烨过来了，吃了个团圆饭，和姐夫喝了点酒。就到现在了~]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各种文档集合]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%90%84%E7%A7%8D%E6%96%87%E6%A1%A3%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[## 目录 语言无关 IDE MySQL NoSQL PostgreSQL Web WEB服务器 其它 函数式概念 分布式系统 在线教育 大数据 操作系统 数据库 智能系统 正则表达式 版本控制 程序员杂谈 管理和监控 编程艺术 编译原理 编辑器 计算机图形学 设计模式 软件开发方法 项目相关 语言相关 Android AWK C C# C++ CoffeeScript Dart Elasticsearch Elixir Erlang Fortran Golang Haskell HTML / CSS HTTP iOS Java JavaScript LaTeX LISP Lua Markdown Node.js Perl PHP Python Django R reStructuredText Ruby Rust Scala Scheme Shell Swift Vim Visual Prolog 语言无关IDE IntelliJ IDEA 简体中文专题教程 MySQL 21分钟MySQL入门教程 MySQL索引背后的数据结构及算法原理 NoSQL Disque 使用教程 Redis 命令参考 Redis 设计与实现 The Little MongoDB Book The Little Redis Book 带有详细注释的 Redis 2.6 代码 带有详细注释的 Redis 3.0 代码 PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 PostgreSQL 9.4.4 中文文档 PostgreSQL 9.5.3 中文文档 PostgreSQL 9.6.0 中文文档 Web 3 Web Designs in 3 Weeks Chrome 开发者工具中文手册 Chrome扩展开发文档 Growth: 全栈增长工程师指南 Grunt中文文档 Gulp 入门指南 gulp中文文档 HTTP 接口设计指北 HTTP/2.0 中文翻译 http2讲解 JSON风格指南 Wireshark用户手册 一站式学习Wireshark 关于浏览器和网络的 20 项须知 前端代码规范 及 最佳实践 前端开发体系建设日记 前端资源分享（一） 前端资源分享（二） 正则表达式30分钟入门教程 浏览器开发工具的秘密 移动Web前端知识库 移动前端开发收藏夹 WEB服务器 Apache 中文手册 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通 (PDF版本，运维生存时间出品) 其它 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 函数式概念 傻瓜函数编程 分布式系统 走向分布式 (PDF) 在线教育 51CTO学院 Codecademy CodeSchool Coursera Learn X in Y minutes (数十种语言快速入门教程) shiyanlou TeamTreeHouse Udacity xuetangX 慕课网 (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源) 极客学院 汇智网 计蒜客 大数据 Spark 编程指南简体中文版 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 面向程序员的数据挖掘指南 操作系统 Debian 参考手册 Docker —— 从入门到实践 Docker中文指南 Docker入门实战 FreeBSD 使用手册 FreeRADIUS新手入门 Linux Documentation (中文版) Linux Guide for Complete Beginners Linux 构建指南 Linux 系统高级编程 Linux工具快速教程 Mac 开发配置手册 Operating Systems: Three Easy Pieces The Linux Command Line (中英文版) Ubuntu 参考手册 uCore Lab: Operating System Course in Tsinghua University UNIX TOOLBOX 命令行的艺术 嵌入式 Linux 知识库 (eLinux.org 中文版) 开源世界旅行手册 理解Linux进程 鸟哥的 Linux 私房菜 基础学习篇 鸟哥的 Linux 私房菜 服务器架设篇 数据库 Redis 设计与实现 The Little MongoDB Book 中文版 智能系统 一步步搭建物联网系统 正则表达式 正则表达式-菜鸟教程 正则表达式30分钟入门教程 版本控制 Git - 简易指南 Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） Git Community Book 中文版 git-flow 备忘清单 Git magic Git Magic Git 参考手册 Github帮助文档 GitHub秘籍 Git教程 （本文由 @廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） Got GitHub GotGitHub HgInit (中文版) Mercurial 使用教程 Pro Git Pro Git 中文版 (整理在gitbook上) svn 手册 学习 Git 分支 (点击右下角按钮可切换至简体及正体中文) 沉浸式学 Git 猴子都能懂的GIT入门 程序员杂谈 程序员的自我修养 管理和监控 ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） ELKstack 中文指南 Logstash 最佳实践 Mastering Elasticsearch(中文版) Puppet 2.7 Cookbook 中文版 编程艺术 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 每个程序员都应该了解的内存知识(译)【第一部分】 程序员编程艺术 编程入门指南 编译原理 《计算机程序的结构和解释》公开课 翻译项目 编辑器 exvim–vim 改良成IDE项目 Vim中文文档 所需即所获：像 IDE 一样使用 vim 笨方法学Vimscript 中译本 计算机图形学 LearnOpenGL CN OpenGL 教程 设计模式 史上最全设计模式导学目录 图说设计模式 软件开发方法 傻瓜函数编程 (《Functional Programming For The Rest of Us》中文版) 硝烟中的 Scrum 和 XP 项目相关 GNU make 指南 Gradle 2 用户指南 Gradle 中文使用文档 Joel谈软件) selenium 中文文档 开源软件架构 持续集成（第二版） (译言网) 約耳談軟體(Joel on Software) 编码规范 让开发自动化系列专栏 追求代码质量 语言相关Android Android Design(中文版) Android Note(开发过程中积累的知识点) Android6.0新特性详解 Android学习之路 Android开发技术前线(android-tech-frontier) Google Android官方培训课程中文版 Google Material Design 正體中文版 (译本一 译本二) Material Design 中文版 Point-of-Android Android 一些重要知识点解析整理 AWK awk中文指南 awk程序设计语言 C C 语言常见问题集 C/C++ 学习教程 Linux C 编程一站式学习 新概念 C 语言教程 C Sharp 精通C#(第6版) C++ 100个gcc小技巧 100个gdb小技巧 C 语言编程透视 C/C++ Primer - @andycai C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ Template 进阶指南 C++ 基础教程 C++ 并发编程(基于C++11) C++ 并发编程指南 CGDB中文手册 Cmake 实践 (PDF) GNU make 指南 Google C++ 风格指南 QT 教程 ZMQ 指南 像计算机科学家一样思考（C++版) (《How To Think Like a Computer Scientist: C++ Version》中文版) 简单易懂的C魔法 跟我一起写Makefile(PDF) (PDF) CoffeeScript CoffeeScript 中文 CoffeeScript 编程风格指南 Dart Dart 语言导览 Elasticsearch Elasticsearch 权威指南 （《Elasticsearch the definitive guide》中文版） ELKstack 中文指南 Mastering Elasticsearch(中文版) Elixir Elixir Getting Started 中文翻译 Elixir 编程语言教程 (Elixir School) Elixir元编程与DSL 中文翻译 Phoenix 框架中文文档 Erlang Erlang 并发编程 (《Concurrent Programming in Erlang (Part I)》中文版) Fortran Fortran77和90/95编程入门 Golang Go Web 编程 Go 入门指南 (《The Way to Go》中文版) Go 官方文档翻译 Go 指南 (《A Tour of Go》中文版) Go 简易教程 (《 The Little Go Book 》中文版) Go 编程基础 Go 语言标准库 Go命令教程 Go实战开发 Go语言博客实践 Java程序员的Golang入门指南 Network programming with Go 中文翻译版本 Revel 框架手册 学习Go语言 神奇的 Go 语言 Groovy 实战 Groovy 系列 Haskell Haskell 趣学指南 Real World Haskell 中文版 HTML / CSS CSS3 Tutorial 《CSS3 教程》 CSS参考手册 Emmet 文档 HTML5 教程 HTML和CSS编码规范 Sass Guidelines 中文 前端代码规范 (腾讯 AlloyTeam 团队) 学习CSS布局 通用 CSS 笔记、建议与指导 iOS Apple Watch开发初探 Google Objective-C Style Guide 中文版 iOS7人机界面指南 iOS开发60分钟入门 iPhone 6 屏幕揭秘 网易斯坦福大学公开课：iOS 7应用开发字幕文件 Java Activiti 5.x 用户指南 Apache MINA 2 用户指南 Apache Shiro 用户指南 Google Java编程风格指南 H2 Database 教程 Java Servlet 3.1 规范 Java 编码规范 Jersey 2.x 用户指南 JSSE 参考指南 MyBatis中文文档 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Spring Boot参考指南 (翻译中) Spring Framework 4.x参考文档 用jersey构建REST服务 Javascript Airbnb JavaScript 规范 AngularJS AngularJS中译本 AngularJS入门教程 AngularJS最佳实践和风格指南 在Windows环境下用Yeoman构建AngularJS项目 构建自己的AngularJS backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Chrome扩展及应用开发 CoffeeScript CoffeeScript 编码风格指南 D3.js Learning D3.JS (Created by 十二月咖啡馆) 官方API文档 张天旭的D3教程 楚狂人的D3教程 ECMAScript 6 入门 (作者：阮一峰) ExtJS Ext4.1.0 中文文档 Google JavaScript 代码风格指南 Google JSON 风格指南 impress.js impress.js的中文教程 JavaScript Promise迷你书 Javascript 原理 JavaScript 标准参考教程（alpha） 《JavaScript 模式》 “JavaScript patterns”中译本 javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) Javascript编程指南 (源码) jQuery How to write jQuery plugin 简单易懂的JQuery魔法 Meteor Discover Meteor Node.js express.js 中文文档 Express框架 koa 中文文档 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 Node.js Fullstack《從零到一的進撃》 Node.js 包教不包会 Nodejs Wiki Book (繁体中文) nodejs中文文档 Node入门 七天学会NodeJS 使用 Express + MongoDB 搭建多人博客 JavaScript全栈工程师培训材料 React.js Learn React &amp; Webpack by building the Hacker News front page React Native 中文文档(含最新Android内容) React webpack-cookbook React.js 中文文档 React.js 入门教程 Vue.js Vue.js中文文档 You-Dont-Know-JS (深入JavaScript语言核心机制的系列图书) Zepto.js Zepto.js 中文文档 命名函数表达式探秘 (注:原文由为之漫笔 翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 LaTeX LaTeX 笔记 一份不太简短的 LaTeX2ε 介绍 大家來學 LaTeX (PDF) LISP ANSI Common Lisp 中文翻译版 Common Lisp 高级编程技术 (《On Lisp》中文版) Lua Lua 5.3 参考手册 Markdown Markdown 快速入门 Markdown 简明教程 Markdown 语法说明 献给写作者的 Markdown 新手指南 Node.js Node 入门 The NodeJS 中文文档 （社区翻译） 七天学会NodeJS 阿里出品，很好的入门资料 Perl Master Perl Today 《Modern Perl》中文版 Perl 5 教程 Perl 教程 PHP Composer中文文档 Laravel5.4中文文档 Phalcon7中文文档 PHP 之道 PHP中文手册 PHP扩展开发及内核应用 PHP标准规范中文版 Symfony2 实例教程 Yii2中文文档 深入理解 PHP 内核 Python Django 1.8 中文文档 Django book 2.0 Python 3 文档(简体中文) 3.2.2 documentation Python Cookbook第三版 (作者：David Beazley, Brian K.Jones 翻译：熊能) Python 中文学习大本营 Python之旅 (作者：Ethan) Python教程 - 廖雪峰的官方网站 像计算机科学家一样思考Python (中英对照版 作者：Allen B. Downey 翻译：大胖哥) 深入 Python 3 笨办法学 Python 简明 Python 教程 (作者：Swaroop C H 译者：沈洁元、漠伦) Django Django Girls 教程 (1.11) (HTML) R 153分钟学会 R (PDF) R 导论 (《An Introduction to R》中文版) (PDF) 用 R 构建 Shiny 应用程序 (《Building ‘Shiny’ Applications with R》中文版) 统计学与 R 读书笔记 (PDF) reStructuredText reStructuredText 入门 reStructuredText 简明教程 Ruby Rails 风格指南 Ruby on Rails 实战圣经 Ruby on Rails 指南 Ruby 风格指南 Sinatra 笨方法学 Ruby Rust Rust 官方教程 Rust 语言学习笔记 RustPrimer 通过例子学习 Rust Scala Effective Scala Scala 初学者指南 (The Neophyte’s Guide to Scala) Scala 课堂 (Twitter的Scala中文教程) Scheme Scheme 入门教程 (《Yet Another Scheme Tutorial》中文版) Shell shell-book Shell 编程基础 Shell 脚本编程30分钟入门 The Linux Command Line 中文版 Swift 《The Swift Programming Language》中文版 Vim Vim Manual(中文版) 大家來學 VIM Visual Prolog Visual Prolog 7初学指南 Visual Prolog 7边练边学]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用express框架，如何在ejs文件中导入外部的js、css文件]]></title>
    <url>%2F2017%2F09%2F29%2F%E4%BD%BF%E7%94%A8express%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8ejs%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E7%9A%84js%E3%80%81css%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在用nodejs写一点东西，当然也用到了express框架和ejs模版了。在使用ejs模版的过程中遇到了这个问题：如何在ejs模版中导入外部的js、css文件。 我猜测，ejs和html导入外部文件的方式应该是不一样的。但是我还是决定试一试。按照之前在html文件中的方式导入，结果失败。 这也证明我之前的想法，这些静态文件一经过服务器，就不能直接进行导入了。那该如何导入呢？ 这是我的文件结构： 我现在需要在index.ejs文件中导入public文件夹下的table.css以及table.js两个文件。我为什么要将两个静态文件放到public文件夹下呢？ 大家应该都知道，在使用express框架时，在安装了express模块之后，在该项目下的命令行输入express -e 就会自动生成相应的文件目录。当然，上面的截图中的目录是我自己写的，下面是express自动生成的目录： 可以看到，其中的public文件夹是其自动生成的，也就是让你放静态文件的文件夹。（当然也不是必须是“public”） 好了，继续。那把包括了js、css以及图片的静态文件放到public文件夹下又该怎么使用呢？ 看图： 在servers.js中写上这句 12//获取放置在public文件夹下的静态文件,app.use(express.static(__dirname + '/public')); 关于app.use()这个方法具体的介绍，这里有篇文章，写的很好app.use(express.static)方法详解 这样，就可以在ejs文件中导入外部静态文件了。这里需要注意一点，在导入写URL时，只需要写public后面的路径就好，不需要再加上“public”了。如下： 12&lt;link rel="stylesheet" type="text/css" href="table.css"/&gt;&lt;script type="text/javascript" src="table.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于JSON数据的操作的方法]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%AF%B9%E4%BA%8EJSON%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JSON.parse()此方法是将普通的符合json数据格式的字符串转化为json数据。例如： 1234567//此处有一个符合json格式的字符串。var jsonStr = '&#123;"name":"mi","age":"23","phone":"154"&#125;';//使用该方法将字符串转化为json数据var obj1 = JSON.parse(jsonStr);//下面我们分别打印字符串和json数据，看两者有什么区别console.log(obj1);console.log(jsonStr); 以下是两者的打印结果，可以看到，json数据的没有引号，而字符串是有引号的。可以以这个来区分。 JSON.stringify()这个方法是将json对象转化为字符串 下面是测试： 1234567891011//这是json对象var test = &#123; "name":"mi", "age":"23", "phone":"154"&#125;var str = JSON.stringify(test);console.log(test);console.log(str); 这是结果{&quot;name&quot;:&quot;mi&quot;,&quot;age&quot;:&quot;23&quot;,&quot;phone&quot;:&quot;154&quot;}]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js中Mysql的使用]]></title>
    <url>%2F2017%2F09%2F28%2FNode.js%E4%B8%ADMysql%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先安装mysql模块， npm install sql，这条语句是安装mysql模块到你的项目中，而不是全局安装。 安装之后，就可以进行js代码的编写了。server.js123456789101112131415161718192021222324var mysql = require('mysql');//数据库连接var connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: 'root', database: 'nodejsdemo'&#125;);connection.connect();//数据库的CRUD语句var selectAllSql = "select * from userMag";var selectOneSql = "select * from userMag where uname like ? ";var insertSql = "insert into userMag (uname,uphone,age) values (?,?,?)";var delSql = "delete from userMag where uid = ?";var updateSql = "update userMag set uname = ?,uphone = ?,age = ? where uid = ?";//执行sql语句connection.query(selectAllSql, function(err, rows) &#123; if(err) &#123; console.log(err); return; &#125; //对查找到的数据进行操作，此处我将数据传递给了ejs模版。 res.render("index.ejs",&#123;data:rows&#125;);&#125;); 编写好js代码之后，就可以进行测试了，将你的mysql开启。在项目文件中，在命令行中输入node server.js。就将这个node服务开启，之后你就可以在你的mysql中看到数据的变化。connection.query(paramA,paramB[],callback()) 方法执行sql语句。第一个参数为要执行的sql语句，第二个参数（可选）是一个数组类型，为sql语句中要传入的参数，第三个参数为回调函数。例如: 1234567var updateSql = "update userMag set uname = ?,uphone = ?,age = ? where uid = ?";connection.query(updateSql, ["张三","155","23","05"],function(err, rows) &#123; if(err) &#123; console.log(err); return; &#125;&#125;);]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-20 周三]]></title>
    <url>%2F2017%2F09%2F20%2F%E6%97%A5%E8%AE%B0%20-%202017-09-20%20%E5%91%A8%E4%B8%89%2F</url>
    <content type="text"><![CDATA[2017-09-20 礼拜三 22:48 晴天 楼道阳台 开始今天的日记~~今天也没什么可写的，还是老样子，值得记录一下的是昨天晚上睡得很好，所以今天早上25就起来了，也很早吃早饭就出发了。到了朝阳门40，不慌不忙就到公司了。中午老地方，13块的盖饭。菜是酱茄子和豆腐。茄子很好吃，可是豆腐就没那么好吃了，有点苦。 下午回来6点45。顺道在运城人家买了一份蛋炒面，还是老样子，回来熬了小米粥。早早就吃了饭了。今天晚上有白夜追凶的更新，直接更新了5集，今天就看了3集，得攒着啊，要不一下就完了。 晚上9点多，去了趟大超市。本来就想买点蛋糕当早餐，结果买了不少~~5块的牙刷，之前的牙刷还是在毕业返校回太大的时候买得，还记得因为要住一晚上，但是啥都没带，也没枕头，也没盖的，也没牙刷和拖鞋。还记得借了南豆的一个床垫当垫子，自己带了一个床单当被子，也不知道拿了谁的一个枕头，还买了一个牙刷，把矿泉水瓶割开当牙缸~~哈哈，回忆满满啊。 好了，说回今天的超市之行，本来就想买蛋糕，结果买了牙刷，4块的挂面，12的牛栏山，当时想了想，光有酒，没杯子啊，就又买了个酒盅，3块。很切他。。。总共花了37，也算是满载而归。还有，一边挑东西，一边和姐姐姐夫聊天，姐夫今天加班，还在厂里，大概得通宵了哎，不容易啊，等国庆回去好好请他喝顿酒！！哈哈~~ 今天也就是这了。完毕。 这是今天在超市拍的~和买回来的东西。这个礼拜五晚上买点下酒的，走起~~ 哈哈，很美很美]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-19 周二]]></title>
    <url>%2F2017%2F09%2F19%2F%E6%97%A5%E8%AE%B0%20-%202017-09-19%20%E5%91%A8%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[2017~09~19 礼拜二 22：56 晴天 开始今天的日记吧~~今天发生了一件大事~~我又你个人霸占一张床了。。。说实话，我的睡眠质量真的是很感人，稍有一点风吹草动就睡不着了。如果睡着了就还好，一般不会被吵醒，就是入睡困难。 前两天买了一对耳塞，隔音效果还是不错的，奈何床垫太软，隔壁睡一张床的翻个身子，我就睡不着了。算了，不说了，希望今天能睡个好觉~~ 今天还是老样子，因为昨天太晚才睡着，今天起床很困难，快40才爬起来，还是老样子，边刷牙边热稀饭，然后吃昨天晚上买的那个芝麻饼。还真别说，味道真好~~里面有花生，味道很香，一盒5个，6块钱。以后可以多吃。吃完饭照例上了个厕所，出发的时候就8点05了，比正常情况下晚了一会儿。路上还好，8点50到了朝阳门，去了公司正好9点，不过管事的没来，所以也还好。 中午吃了份13块的盖饭，鸡块和茄子两个菜。这个鸡块是很好吃滴~~下午就不表了，老样子。可能是昨天没睡好的缘故，中午快吃饭的那会儿很困。快下班的时候也特别累，头也有点疼，但是不是很厉害。现在也好了。我5点55就下班走了，还是因为管事的不在~~哈哈哈哈 因为早走了一会儿，朝阳门A口都没人，连人都没有排起来，地铁上人也不是很多。宽宽裕裕得，回来物资学院路才6点40不到，但是天也已经黑了。天黑的越来越早了。前两天都还是7点左右才能黑了呢~ 回来在运城人家买了份蛋炒面带回来吃回来之后还是熬了点小米粥，先把早上吃完的锅洗了一下，因为早上走的匆忙，所以也只能晚上回来再洗了。熬上粥，开始吃饭。饭很香，是我喜欢的类型。把我昨天晚上买得两根火腿肠吃了一根。面吃完，稀饭也好了。因为没有了大米，只有小米，所以熬起来特别快。晚饭吃的很舒服啦~~ 晚上就没啥了，边看新闻联播，边看了王自如的iphone8的开箱，速度很快，不愧是“刘翔”。。。 看完天气预报，北京和太原明天都是晴天，温度也差不多，最低15度，最高也25左右。最近的天气很舒服，尤其是晚上下班刚出楼的时候，特舒服！早上也是，中午如果不在太阳底下，也很舒服~但是到太阳底下就有点晒了。最近的天气不错的~~ 好了，照例，我们的老话题，这个星期二也结束了。这个礼拜还剩3天，下个礼拜还剩6天。9天~~拭目以待吧~~迫不及待了！！！ 对了，今天找到了&lt;锤子便签&gt;的网页版，登录我的账号就能在PC端看到我每天的日记了，所以我也就不再往微信公众号上发了，怪麻烦的。我要的效果就是移动端和PC端都能看到就行了。并且是存放在云端的。等若干年后再拿出来看我这会儿写的东西，虽然词藻没有那么华丽，记录的东西也只是每天的日常，可能别人看起来都任何意义。但是对我来说，就很有意义了，只想给以后的我，或者我的后辈们一点可以记录我现在的东西。图片是一种，文字也挺好啊~~好了，今天的日记就这样吧~加一张图片吧，这是我单元门口的路灯~~]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-18 周一]]></title>
    <url>%2F2017%2F09%2F18%2F%E6%97%A5%E8%AE%B0%20-%202017-09-18%20%E5%91%A8%E4%B8%80%2F</url>
    <content type="text"><![CDATA[2017~9~18 礼拜一 晴天 22：29 开始今天的日记~~今天是礼拜一，早上早早的就起来了。因为昨天没有熬粥，所以今天早上的早饭也没有粥了，只好热了一点热水，再加两个面包。面包存货不多了，就剩一个了。所以刚刚去了6号楼2单元超市买了点吃的~~一盒芝麻饼，两根火腿肠，总8块。明天再去小区边上那家超市买点早点吧。吃了早饭55，又边抽烟边上了个厕所，8点准时出发。今天地铁上的人还是不算多的，能站开。到了朝阳门45，晃晃悠悠55到公司。开始一天的工作~~ 今天活儿不多，早上去了把压缩文件弄了一下，之后就11点多了，差不多就该准备吃午饭了。午饭去那家15块盖饭那家吃，今天吃了一份尖椒肉丝盖饭，16块，量还是很足，味道也不错，要是稍微有点淡。还送了份粥，午饭吃的很舒服。对了，等饭等了很久才等到~~ 吃了午饭上楼来就12点45了，躺椅子上看了会儿小说，之后就听相声，直到睡着。一觉醒来就两点半了，迷迷糊糊去厕所洗了把脸。总算是精神了。 下午也没任务，就自己做了一个记账的混合开发app，用了一个新技术。但是做到后面发现了一些问题，临走前也没有解决掉，明天如果还是没有什么任务的话，还是继续完成它吧。 晚上回来不到点7点，天已经完全黑了。晚饭吃的饼子，熬了些小米粥，还有明天的早饭~~边吃饭边看新闻，之后又看了看电影，布拉德皮特演的，名字叫什么忘了，讲爱情的，我也好久没爱情了啊~~ 烟又没了，抽了3天~~印象中大学那会儿也就是这个速度，差不多34天一盒烟。现在就剩一根了，一会儿得去买盒烟，明天抽。 感觉在公司抽的不多，早上吃了饭抽一根，中午吃了饭抽一根，下午去放风抽一根，再然后就是回了家抽好几根，34根吧。今天回来抽了3根，晚饭吃完一根，苹果吃完一根，现在一根。一天6到7根烟，3天左右一盒。 快了，快到国庆了，这个礼拜还剩4天，下个礼拜还有6天，也就是10天，数着吧。哈哈，每天必谈的话题，国庆回家哈哈。盼望着，盼望着 好了，今天的日记就是这些了，我得去买盒烟了，要不人家关门了~~~]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-17 周日]]></title>
    <url>%2F2017%2F09%2F17%2F%E6%97%A5%E8%AE%B0%20-%202017-09-17%20%E5%91%A8%E6%97%A5%2F</url>
    <content type="text"><![CDATA[都说李白斗酒诗百篇，晚上我也喝了两瓶啤酒。不知道今天的日记能不能写的优美一点~~今天周日，还是在家窝了一天，并没有出去玩。早上起来就11点了，我也不想啊，可是一觉睡起来就快到中午了~~起来把冰箱里的小米粥喝了，这个粥是礼拜五晚上熬的，所以放了好久了，赶紧喝掉。 吃了早饭打了两把LOL，就到了12点半了，也不饿，但是也得吃午饭啊，还是到运城饭店吃了一份炒饼，再加一瓶北冰洋，15块钱。 下午也是什么都没干，在电脑跟前坐着，坐累了就躺会儿。感觉以后得周末我不能再这么过了，太无聊，而且也太没有意义了。得找点事情做啊。 下午6点多，下楼到6号楼超市买了3瓶勇闯天涯，13块5。再加一根肠，8块。昨天晚上记日记的时候就想着今天喝一顿，哈哈。因为昨天想到了和姐夫喝酒的场景，所以很想喝一点。 回来以后把场子切了，下酒菜有点少，下回再来点花生豆吧。有条件的话还能自个儿炒个菜，哈哈。也就炒鸡蛋了吧~~这就是晚上的酒桌，虽然条件不是很好吧，又是一个人，但是还是喝的挺高兴的。一边看电视一边喝酒，哈哈，其实这就是生活啊~要是能再来个喝酒的人就好了~哎。 抽根烟吧~~还是在小区花园里面，很安静，很凉快。独自点上一根烟，和自己对话，感觉很惬意。 对了，从今天开始，我开始用锤子便签来记日记，功能很简单，界面也很干净。主要是可以加图片，这个功能是小米自带的便签没有的，我还用了锤子桌面，很不错，先用一段时间。之前的都审美疲劳了。换着用用。 就剩整整两个礼拜了，回家的倒计时几乎成为了我每天日记中必须要谈到的话题。每次想想都觉着很开心，很舒服。这个感觉真的是无与伦比的~~ 再搞两个礼拜！想想都觉得美的慌~~ 想回去的时候买点东西带回去，但是不知道该买点什么~~吃的？用的？不知道了。 拍一张，以后看到会有很多回忆的~~不知道该再写些什么了。对了，说说我喝酒的时候发的朋友圈吧，我拍了张喝酒的照片发到了朋友圈，也就是上面的那张照片。有很多人评论： 上面的就是，姐看我下酒菜不多，旭峰看我酒有点少。箱子看我小日子过得挺滋润~哎~ 叫我国庆过去一起喝。是啊，我多想啊~~ 行了，这就是今天了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-16 周六]]></title>
    <url>%2F2017%2F09%2F16%2F%E6%97%A5%E8%AE%B0%20-%202017-09-16%20%E5%91%A8%E5%85%AD%2F</url>
    <content type="text"><![CDATA[2017年9月16号晚上11:44 今天是礼拜六，在家窝了一天。早上起来就十点了，热了点昨天晚上的粥当做早餐。然后就开始看《火星情报局》。看到中午吃午饭，煮了顿饺子把剩下的饺子全煮了，大概30多个吧。这一袋饺子吃了四顿，量还是很足的。 边吃饭边看到姐的朋友圈里发了。关于高兴的婚礼的视频。现场很红火，挺热闹。从视频里看好像下次一点小雨。都希望我也能回去参加呀。 他们应该是下午六点左右往回走的。赖晓今天中午回了回去了。昨天还跟他在微信上聊，说他可能今天去不了。所以正好坐姐夫的车顺路捎回去。 我吃完饭看了会视频，应该是8:15左右。给姐发去了视频通话，一家三口正在家里吃饭呢。回去了也就八点多了。 突然想到好久没有喝酒了。想想有点儿香，要不明天喝顿酒吧。买点儿啤酒带回家喝，可以，明天走起！ 看来回家要和姐夫好好喝一顿。好久不见，甚是想念。想念那顿酒，想念那些人。 像今天这个点就有点晚了，都快12点了。明天的话早点儿下来。现在不知道该再写点什么了。踱步回单元楼门口。现在真的是夜深人静呀。只能听见蛤蟆的叫声。 昨天买的耳塞到了，所以晚上试了一下，很牛逼。如果当时在西山的时候买到这个玩意儿的话。就没有那么多的血泪史了。隔音效果贼棒。而且带上也很舒服，这是居家旅行必备良器。20块钱，两对，看他说明书上写的是一对耳塞，最多用一月到两月。嗨，再说吧~~ 下午玩儿了一下午游戏。到了6点半的时候，出去理了个发，还是那家，还是25块钱，手艺还行。而且理发小哥也很擅谈，理发的时候一直在跟他聊。这也是来了北京的第二次理发。算算时间，这次理发到回家差不多有两个礼拜。应该也长不到哪儿去，如果觉得热的话，还是在家里一次吧。 这次国庆回家，有几个地方需要去和几个事情需要做： 在自己家的沙发上看新闻联播和天气预报，然后再看并州之剑~~ 检查一下家里的各个用电设备，如果有坏的就修一下。 在家简单做个饭 跟爸妈聊很多很多事情 跟任鑫烨讲故事 记日记啦！每天必须 在家看《白夜追凶》和《无证之罪》 回一趟村里，看看变成什么样子了。来北京之前就一直想去看一下，结果始终没去~~ 跟高中那群老鬼们吃顿饭，玩儿一天。应该会花费一天时间。 和村儿里的老鬼们吃顿饭。应该也就花费一晚上时间。而且有可能就是在张轩的婚礼上实现了。 去打会篮球，来了北京一次篮球都没打。 可能还会去见一次栾鑫，因为之前他让我捎一点儿点心给他带回去。所以可能还会给他送过去。在吃顿饭？哈哈。 现在暂时就能想到这些了。 好了，今天的日记就这些了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-14 周四]]></title>
    <url>%2F2017%2F09%2F14%2F%E6%97%A5%E8%AE%B0%20-%202017-09-14%20%E5%91%A8%E5%9B%9B(2)%2F</url>
    <content type="text"><![CDATA[9月14号晚上十点半。我坐在楼下的花园里思考。刚刚绕了一大圈儿回来歇一歇。突然想到之前一直在备忘录中记得关于我儿时的记忆。是时候把这些素材写出一些东西来了。 初中时的方便面 这个是我上个礼拜记到备忘录中的。因为我前两天吃了两天。方便面当做早饭。就突然想起来初中那时候我几乎天天的早饭都是方便面。我记得那会儿早上得七点半左右到学校。我一般都是七点左右在家吃饭。几点起床？我已经记不清了。我记得一个情景是：我早上起床之后再刷牙洗脸的时候。爸已经开始给我做早饭了。也就是在给我煮方便面。我记得好像都会打一颗荷包蛋。然后因为刚煮下会很烫。所以就放到东边儿房间的窗台上晾着。我洗漱完毕之后就会站在窗台边上，就着锅吃方便面。我现在还能清楚的记起来当时的这个场景。印象颇为深刻。吃完早饭，我肯定是不会把碗洗了的。把锅放到厨房，然后骑车去上学。 这只是在我无数个初中的早上的某一个情景。我依稀记得那时候早上我吃的最多的就是方便面。我觉得应该大部分的像我这个年龄的人在小时候都特别爱吃方便面。恨不得每天都吃，这也是为什么我现在极其不愿意吃方便面的原因了。可能是吃败了吧。 到现在我不到万不得已或者实在是懒得动的情况下才会煮一袋方便面。可能就一个礼拜一次吧。还是来了北京之后。现在想想初中那会儿还是很怀念的。让我我觉得搞笑的是，我一般都会站着把方便面吃吧。现在想想这个场景特别好，真的是特别怀念。 第二件事情，偷钢笔。这件事情应该是在小学的时候所发生的。事情的经过是这样我们几个老同学起车去玩，然后就起到了我的小学。因为放假，时间应该是暑假或者是某一个周末。整个学校都没有人，我也不知道我们是怎么进到学校里面的。然后就去办公室里面逛了一圈儿。你懂的不是从门进去的，然后我就发现窗台上有一只钢笔。我还记得那只钢笔很粗。钢笔头也很粗。我好像从小手就不干净吧。然后歹念就升起来了。不出所料，我把这个钢笔顺走了。还拿回来家里。事后发现这支笔是办公室的老师批改作业的时候用的。因为里边儿灌的水是红色的墨水儿。而且因为笔头很粗，所以用来判作业对购物会很粗。重点是接下来所发生的事情。因为当时我姐刚从幼师毕业。就在村里的学校当小学老师。我依稀记得他应该当了两到三年左右。还教过我一年。年轻的我没有太注意，把那只顺过来的钢笔有关上了蓝色的墨水儿。继续用。我姐肯定会发现啦，问我钢笔怎么来的。我当然不能承认了，就说捡来的，我还记得我当时的说辞是：我们几个同学出去骑车玩。骑着，就压到了这支钢笔。还把这支钢笔在外面内存塑料压破了。很可笑！而且钢笔的主人就在那个办公室里。我姐当然也认识这只钢笔。只是她没有戳穿我。哎，年轻啊~~ 好了，今天就先写这么多。还有好几件以前的事，需要我记一下。明天再说。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-14 周四]]></title>
    <url>%2F2017%2F09%2F14%2F%E6%97%A5%E8%AE%B0%20-%202017-09-14%20%E5%91%A8%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[2017年9月14号礼拜四，天气阴。现在是10:04好了，开始今天的日记我刚刚洗漱完毕，正在楼下散步。入秋之后的北京还是很凉快的。就像现在，微风习习。很是凉爽。说说白天的事情吧。早上起来就已经7:35了。匆匆忙忙洗漱完，吃完早饭也就八点了。是，然后在厕所蹲了一会儿。出门儿的时候已经8.05左右了。去到地铁人是超级多。好久没有感受到像今天这么挤的地铁了。 去到朝阳门是8:50，往公司走的路上，紧紧张张。去了也正好，九点左右。 早上去了，把昨天遗留的问题解决了一下。其实很简单，只是缺一个方法。 下午下午新学了一个技术，叫做 jquery mobile ,简单的用了一下觉得豁然开朗了。特别好用，明天去了之后还需要巩固一下，以及把新的用下。 晚上回来七天左右，但是并不像往常一样一点儿都不饿。中午吃了一份大份的盖饭。量是超多。 主要是太辣了，我长了几个辣椒，以前辣的不行了。只好只吃千页豆腐。 晚上回来没有个想吃的东西，回的路上去了趟超市，买了一大袋山楂和一袋儿面包。回到家之后，煮了点粥。这就是晚饭。 吃了饭，看了两集《白夜追凶》，已经追了一个礼拜了，很是好看。然后给m打了个电话，因为明天他们要去姥姥家参加高兴的婚礼。和你是后天，所以他明天就得出发。 听他们的计划是下午姐夫下班之后。大概是六点左右出发，因为姐下班得五点半。明天是周五，所以任鑫烨四点左右就下课了。爸妈明天在家里没什么事。静等姐夫下班儿送他们去姥姥家。 很想回去参加，高兴的婚礼呀。但是回不去呀只能在北京远远的看他们了。 算算日子，也就剩两个礼拜多一点儿了。今天是14号，明天是五号，后天高兴的婚礼。下下个礼拜就是回家的日子。很期待。 对了晚上九点多姐，给我发了一张照片儿。是他驾驶镜的照片儿，历经千辛万苦，总算是把字靠下来了。也算是聊了他的一桩心愿。因为之前科三挂了一下。所以他心里很不平衡~功夫不负有心人嘛，总算是手到擒来了。 也正好，误不了这个周末去参加婚礼。时间正好。好了，先记到这儿吧。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-09 周五]]></title>
    <url>%2F2017%2F09%2F09%2F%E6%97%A5%E8%AE%B0%20-%202017-09-09%20%E5%91%A8%E4%BA%94%2F</url>
    <content type="text"><![CDATA[2017年九月九日凌晨1:50，我一个人站在阳台上抽烟。明天是礼拜六，所以我可以放心大胆的玩点睡。其实刚睡下，已经睡意朦胧了，可是突然想到一件事情，让我瞬间睡一圈舞。晚上的时候，房东来要房租。这就是让我心里烦意乱的事情。 其实仔细想想也没什么太大的问题。继续交纳剩下的三个月的房租，也就没什么了。再加上今天又拉来一个合租的人，其实摊到每个人身上。也就700块钱一个月所以也是还好，想想也就想开了。 促使我这么晚了还出来抽烟。是我通过这件事情，又想到了一些其他的。 我突然想到了我刚上高中的时候。第一个礼拜，就笑的时候。那种心烦意乱的心情跟现在是一模一样。 那种自己掌握不了一切的时候是最心烦意乱的时候。 记得高一呢年刚开学。自己适应不了，每天睡不好。当时甚至想换学校换到你自己家很近的一所学校。但是那所学校跟我的高中比起来差得很远。我甚至想退而求其次的。去上那所学校只因为他离家比较近。因为那样我就可以每天跟自己。父母见面在家吃饭，在家睡觉过自己习惯了很久的生活。 可是我现在在回过头来想这件事情，就觉得自己很可笑。所以我刚刚在床上又想到。人生所有的不如意其实都是。对自己的一个考验。当你再回头看的时候，你就会觉得。这是你的一个人生财富。你可以把这些事情讲给你的后背听。 现在的情况也是这样，我刚刚大学毕业，来到一个人生地不熟的地方。而且还是竞争相当激烈的北京。无论是生活还是工作都没有那么的如意。甚至有一点感觉到自己很无助。就拿租房这件事来说，之前就已经听过来北漂的人租房是自己必须要经历的事情。无论是遇到黑中介黑了自己多少钱，还是遇到了不好的室友。这些都是需要经历的。 我还是很幸运的，最起码我的几个舍友还是比较可以的。没有那么多不堪。租房的话也是比较顺利的。只是没有自己想象中那么的便宜，或者可靠。但是人生不就是这样吗？经历吧这也是一种财富。你只有经历了这一些你不如意的事情，经历的那些你觉得很难的事情。经历的那些让你半夜睡不着觉的事情。你才会成长你才会学到一些。 现在回过头来看我高中的时候觉得自己很可笑。那是那是，现在22岁的我看16岁的我。那如果30岁的我在看我如今22岁的我。是不是也会同样发出如此感叹呢？ 刚刚在床上还想到了另一件事情，也是我人生中比较印象深刻的不如意的事情吧。那就是我第一次的失恋。我记得那天晚上我跟我的初恋女友分手了，我真宿都没睡着，我记得那会儿也开始抽烟了。就一根儿烟一根烟的接着抽。可能那会儿也不太懂得伤心难过吧，只是觉得应该抽烟。事后也没感觉抽烟，为我的。伤心难过，缓解了多少。可这会在想，那时的我。也是觉得有些可笑吧。 那也是我人生中的第一次失恋。后来又经历过一次试炼。就没有那么的难过了。这就是一种成长吧。 现在是凌晨2:03，睡意全无的我站在阳台上。一边喝水，一边抽烟，并且在用语音记录我的心路历程。看着阳台外的高楼还有好几家亮着灯，不知道他们在干什么都这么晚了还不睡觉吗？难道和我一样，也有发愁的事情吗？这可能就是北京吧，一个充满了开心，难过，伤心的地方。至少我对北京现在的人事是这样。 又想起了另一个话题，我们来聊一聊。我比较信奉的做事的宗旨就是跟随自己的内心。就像当初自己决定来北京，开始我的第一份工作的时候。我就是跟随自己的内心。我知道来了北京，之后会有很多很难的地方。需要自己面对很多未知的东西。我现在想想的话，其实我没有做好很多的心理准备。我没想到现实中的北京，以及现实中的社会是这么的现实。这么的残酷。希望你用尽全力去拼搏。去成长。 说实话，我现在很想回到太原发展。因为现在的我没有那么过的如意。就像那年刚上高一的我。心里充满着困惑无助。还是会有相当年那样的念头出现在我的脑海中。回到你自己家近的中学念高中。就像现在我想回到你自己家比较近的公司上班。真的是一模一样。 但是我当年并没有回到离自己家近的那所高中上学。我也证明，那样是正确的。我慢慢的适应了住校的高中生活。也在那所高中过得很快活认识了一群值得一生交往的朋友。如果当年我真的回到了离家比较近的那所中学上学的话。可能也就没有现在来到北京的我了。 这是一个我并没有随着自己的心而做的事情。事后证明我没有随着自己的心去做这件事情是正确的。但是也有我随自己的心而所做的决定是正确的。那就是高三毕业之后。 高三毕业之后，高考生数下来以后。我离二本线差六分。这也说明我不能按时的报考志愿报考自己理想的大学。那时我也不知道会有补录这一方法。只想着自己与大学失之交臂了。家人们也在为我想复读一年的准备。 也就是在我与我的初恋分手的那个月。我的一个表姑为我联系了。清徐中学，这所中学是很有名的，但是地方是很偏僻的。我在前一天跟着我这个姑姑去了那个学校之后。对他的印象并不是很好。出门就是一片荒地，内心深处的我是很排斥的我并不想去这所中学念书，更别说是高四了。也可以这样说我内心是排斥再读一遍高三的。因为我真实的知道高三是怎么样的苦。我并不想在经历一遍那样的苦。 但是我最后还是决定去这所中学复读。为了自己的前途，为了父母的希望。当时我的这个姑姑也为我联系好了，在所学校。我去，随时可以去这所学校。并且已经准备好了车第二天把我送到学校去。 我还记得出发前的那天早上。下着特别大的雨，应该是大到暴雨之类的雨。我早早的起床之后并没有着急收拾行李，收拾书包。因为我决定跟是我内心的想法，不去那个学校。继续复读。而我也很幸运，我的父母听从了我的意见。他们并没有强迫着我去那所学校，而是打电话告诉我那个姑姑说。暂时不去了。 事情的发展就这样跟随我内心的想法儿走了下来。而事后我也被一所大学。补录成功。也避免了再读一年高三。所以我的决定还是正确的。 好了，回忆结束，回到了现实。来北京发展，也是我内心的意愿。而我又没有充分考虑到现实的情况，被现实狠狠的拍了一巴掌之后。我可以说我后悔了，但是现在有想的话这个后悔的意愿，又没有那么强烈了。因为这条路是我自己选择的。而我也因为长大了很多，懂得了很多。知道这条路我应该走下去。而且我也能预见到，如果我在北京呆上一年或者更长的时间会有很大的成长。会有更多的比在太原发展的成长。所以我不后悔！我要把我当初的决定坚持下来。只是没有那么轻松罢了。 所以我现在又认识到一点。，我说从上的还是遵从自己的内心去决定事情。但是我现在又多加了一条。我需要多坚持，而不是马上就放弃了。 我很希望现在的我可以和高中的我一样。经历过，刚开始的困惑之后。可以发展的很好，可以在结束的时候得到很多 家还是要回的，我只是不想这么快的就回。我想学到一些，不让自己的朋友看轻自己。也不让父母为自己担心。 我需要快快的成长，不论是工作上还是生活上。让自己的臂膀更加的健壮，让自己的内心更加的强大。支撑起自己、支撑起朋友、支撑起父母、支撑起爱我的人。支撑起我爱的人。 在大半夜跟自己对话，这就是一种经历，这就是一种成长吧。只是希望自己在多年后，再回过头来想，我现在的事情。看我现在所写的这篇文章，可以淡淡的发自内心的笑一笑。把自己的经历讲给身边的爱人或者朋友或者子女。这样就很好了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS按月递增算法]]></title>
    <url>%2F2017%2F09%2F06%2FJS%E6%8C%89%E6%9C%88%E9%80%92%E5%A2%9E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近业务上遇到一个问题：已知格式为 xxxx/xx/xx的起始日期和结束日期，要得到一个数组，数组中存放从起始日期开始到结束日期间的若干个日期，每一个日期元素都比之前的日期大一个月。 以上是问题。 下面是代码： 1234567891011121314151617181920212223242526272829303132repayPlan = function(start,stop)&#123;// 拿到从页面传来的 开始和结束的日期 var date = []; /*将日期 字符串分割*/ var start_ = start.split("/"); var stop_ = stop.split("/"); /*重新组合成一个新的字符串*/ var d1 = start_[0] + start_[1] + start_[2]; var d2 = stop_[0] + stop_[1] + stop_[2]; /*转换成数字类型*/ var dd1 = parseInt(d1); var dd2 = parseInt(d2); /*设置一个index */ var index = dd1; /*进行循环 往date数组中push新的元素*/ while(index &lt; dd2)&#123; if(index%10000 &lt; 1200)&#123; index += 100; &#125;else&#123; index += 10000-1100; &#125; /*将数字类型的index转换为字符串类型,并重新用"/"连接*/ index = index.toString().substring(0,4) +"/"+ index.toString().substring(4,6) +"/"+ index.toString().substring(6) /*将处理好的日期数据放入date数组中*/ date.push(index);// 再次拆分日期数据并转化为数字格式，用来下一次的比较 index = index.split("/")[0] + index.split("/")[1] + index.split("/")[2] index = parseInt(index); &#125; //返回一个新的数组 return date; &#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-05 周三]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%97%A5%E8%AE%B0%20-%202017-09-05%20%E5%91%A8%E4%B8%89%2F</url>
    <content type="text"><![CDATA[2017年9月3号现在我在楼底下，一边抽烟，一边用手机记日记。刚刚去超市买了点蛋糕和点心，当之后几天的早饭。刚刚尝了一个类似太谷饼的点心，味道还是不错的。突然想起来Ma总是会在冰箱顶上的篮子里面放一点点心啊饼干之类的吃的。我也经常早上起来自己对付的吃点。今天买这些，也算是继承优良传统吧~称了5袋太谷饼，4袋红枣糕，12块一斤，总共14块。应该够我吃完这个周末了吧。 早上7点35起床，因为昨天晚上没有熬粥，所以早饭我自己住了一包方便面，速度还是很快的，一边听相声，一边就吃了早饭了。7点50就吃完了，然后花了5分钟抽了根烟，穿鞋。不到8点就出发了。 到了朝阳门，一看表才8点40，这比我平常的时间要早5分钟。所以，去公司的步行还是很悠闲的。晃悠到公司也才8点50多一点。 昨天的项目检查没有检查完，所以今天继续，没想到还是费了整整一天的时间，到了下午6点下班的时间，正好都检查完。 看来我们还是要在北京呆大约一个月，得呆完9月份了。 前天，我买了10月1号的火车票，国庆节的火车票是真难买啊，只能抢到1号下午6点的票，到了太原也就得晚上9点了。不过还是可以了，最起码能在1号回去了。想想回去的那天还是很激动的，我现在已经迫不及待了。今天5号，我需要倒计时了，这样每天就有盼头了，这可比盼周末有意思多了，哈哈。希望早早到来吧，让我“衣锦还乡”，哈哈。 高兴的婚礼，我就去不了了，是9月16号，也就是下个礼拜六，距离国庆正好两个礼拜。我还是不回了。虽然很想回去，但是仔细想想，还是算了。虽然不用请假，但是时间太紧了，周五回去，周日就又得出发赶过来。最主要的是，过两个礼拜就是国庆，不如直接留到国庆再回去。 现在需要想想国庆回去的时候需要准备些什么了，我还是打算把我的行李箱带回去吧。当然是不带什么东西回去了，但是需要从家里带一些衣服过来。 需要带回去的，也没什么，笔记本电脑，几件衣服，带条裤子，带个半袖，带个外套就行。所以也不用背书包了，拎个行李箱就行了，因为回去就晚上9点了，还是得穿个外套的。下火车，姐夫应该会过来接我，回去不到10点，简单洗漱行一下，跟老爸老妈聊会儿天，正好休息。哈哈，想想可是真美啊~~ 想想国庆休息的几天都要干嘛，应该会花一天和高中同学聚一下。参加一下张轩的婚礼，剩下的时间应该就是陪家人了。嗯嗯，如果没有什么大的变化，我的假期就是这样度过了。越离开家人，越觉得家人的重要性是那么大。 刚刚看了日历，9月30号是个礼拜六。也就是说9月的最后一个礼拜需要上6天班，然后就是10月1号休息放假。 30号下班之后吃了晚饭，打两把游戏，跟高中的哥几个通知一下我老米第二天就回去了，到时候约起来。晚上会很兴奋的很晚才睡，第二天也可能会很晚才起。也可能早早的就睡不着了，期待着马上收拾东西，走上回家的路程~~~ 对了，30号那天晚上，我需要把行李箱的“外套”清洗一下，因为在7月5号来北京的那天，拖着行李箱转了一天，那个外套早已经很脏了，再加上在窗台边上放了快3个月，是脏的可以了。因为第二天就要用，所以需要前一天清洗一下，也就是来点洗衣粉在水里泡一下，再揉两下就行了。没那么脏就行了。还有，需要把那个礼拜穿的衣服洗一下，也可以把第二天要穿的衣服一下，因为第二天晚上6点的火车，所以到下午衣服也就都干了。 6点的火车，我觉得我得吃了午饭休息一会儿就该出发了。国庆节火车站人应该会特别多，而且是北京的火车站。坐地铁到北京西站怎么也得两个钟头，所以赶早不赶晚，我可不想半路出什么问题。打算下午2点出发，去了火车站4点左右。然后赶紧取票，静候发车。 因为我不是在12306官方网站上买得票，现在也在官网上查不到我的火车票。这位之前没有经历过，心里还是有一点忐忑的。希望不要出什么问题。 国庆整整休息8天，也就是一个礼拜天加上整整一个礼拜。上班那天正好是星期一。我还得赶紧买8号从太原来北京的火车票。前提是我10月份还在北京呆着的话。 今天是能买到10月4号的票，也就是中秋节当天的票，也就是说4天后才能买8号的票。也就是这个星期六。我需要将支付宝的钱赶紧往我的工商卡里转一点，转500吧，一个是为火车票钱准备200，一个是我得地铁卡也没钱了，明天中午需要取100出来充值。我需要设置一下闹钟提醒了，星期六晚上12点去官网上抢票。 对了，突然想到一件事。我还是需要在30号晚上做好第二天出发的一切准备，因为还有可能会有1号的票剩下，在30号我需要时刻关注火车票的信息，如果有退票的或者改签的，我就可以在1号的早些时候回家了。所以30号晚上不能洗第二天要穿的衣服了，还是保险一点。 又想到一点，如果星期六抢不到太原到北京的票，那只能在国庆休息期间再买了，能不能买到还不一定。如果买不到8号的票，那只能买第二天或者更晚的了。这也没办法啊，到时候如果真的出现这种情况，也只能跟公司请假了。 好了，今天就记这么多吧。上楼。 很期待，还有20天！！！]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-09-01 周五]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%97%A5%E8%AE%B0%20-%202017-09-01%20%E5%91%A8%E4%BA%94%2F</url>
    <content type="text"><![CDATA[好了，开始今天的日记吧。 ​ 今天是星期五，我越来越认为我最喜欢的日子是星期五了。他是最让人放松的日子了。刚刚忙碌完一个星期的工作或学习，就要迎来闲适周末，感觉比过周末本身还要放松。 ​ 之前跟很多人讨论过一个问题，就是是过周末本身让人放松，还是期待过周末的那种心情让人放松。我个人是比较倾向于后一种的。周末本身并没有给我带来很多快乐，但是想过周末的就那种心情却是我朝朝暮暮的。不知道有没有和我有相同心情的人。 ​ ​ 来聊一聊白天事情吧。由于这两天上班的路上并没有卖早点的了，所以我从昨天开始，自己买了点面包，早上起来将昨天的稀饭热一下，当早饭。今天照例，吃过早饭之后，再来根烟，哈哈现在想想都很爽啊。 ​ 上班路上没有很挤，到了朝阳门是8点45左右。在走到公司是55。这也是我每天的时间点。去了之后进行一天的工作。还是一样，工作就不聊了。。。 ​ 中午老地方吃午饭，要了两个荤菜，15元。一个茄子，一个炸鸡块。这个炸鸡块是我最爱吃的菜了。所以见面率很高。而今天的另一份茄子，则是我今天第一回碰见，于是就尝尝鲜。没有让我失望，很是好吃，稍微有一点咸，很下饭，是我喜欢的菜。 ​ 下午依旧完成持续了两个礼拜的项目，不过已经进入了尾声。在下班前也完成的差不多了。需要做一个PPT，下周一要进行“评审”。 ​ 还是6点下班，地铁站依旧是那样的人山人海。习以为常了。 ​ 回到家就已经7点了，出地铁站的时候，天已经蒙了一层黑纱， 路灯也亮了起来。等走回公寓，天也就完全的黑了下来。 ​ 晚上吃的是昨天买来的速冻饺子。先把早上走之前吃完的锅洗了之后，就开始热水煮饺子。这是我来了北京吃过的第三顿饺子，前两顿，一顿是在饭店吃的，18块钱一份，好像是30个左右。第二顿是上个周末，我们在饭店吃过中午饭之后，买了一斤饺子，晚上回来自己煮着吃。28一斤。总数没超过50个。 ​ 今天的饺子味道还是不错的，虽然是速冻的，但是不得不说，味道很是可以的。35元5斤饺子，分量还是很足的。今天煮了33个。煮了很长时间，速冻的嘛，煮的时间长点更卫生一点。 ​ 吃的是汤饺，在汤里再加一点醋，还是很不错的。晚上吃了28个饺子，因为还剩下5个，明天早上打算煮一袋方便面，然后把饺子放进去热一下，想想还是很不错的。哈哈。 ​ 晚饭过后，就等BaMa和我视频，每周一次，每周五会视频一次，看着二老坐在屏幕对面还是很亲切的，许久未见，甚是想念啊。有点想家了。 ​ 8点40开始的视频，到了9点50左右结束的，持续了大概一个小时，可以说是算比较短的。之前的几回时间都比较长。看着二老都挺好的，Ba面色也不错，还穿着短袖，聊起来也很高兴。 ​ 一晚上聊了很多：我的工作、高兴的婚事、天气的变化。看到我还光着膀子，连忙催我穿上衣服，啊哈哈。 ​ 一天的时间就这样过去了，简单记录一下。 ​ 我很爱我的父母。谢谢他们。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6的class的使用]]></title>
    <url>%2F2017%2F09%2F01%2FES6_Class%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ES6——ClassES5如何编写类以及类的继承123456789101112131415161718function Person(name,sex,type)&#123; this.name = name; this.sex = sex; this.type = type this.showName = function()&#123; alert(this.name); &#125;; this.showSex = function ()&#123; alert(this.sex); &#125;;&#125;;//继承Person类function Teacher(name,sex,tall,type)&#123; Person.call(this,name,sex,type); this.tall = tall;&#125; ES6如何编写类以及类的继承123456789101112131415161718192021222324252627class Person&#123; constructor(name,sex)&#123; this.name = name; this.sex = sex; &#125;; showName()&#123; alert(this.name); &#125; //静态方法 static demoFunc()&#123; alert("我是静态方法"); &#125;&#125;//继承Person类class Teacher extends Person&#123; constructor(name,sex,tall)&#123; super(name,sex); this.tall = tall; &#125; showTall()&#123; alert(this.tall); &#125; //覆写父类中的方法 showName()&#123; alert("我的名字是："+this.name); &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-08-30 周三]]></title>
    <url>%2F2017%2F08%2F30%2F%E6%97%A5%E8%AE%B0%20-%202017-08-30%20%E5%91%A8%E4%B8%89%2F</url>
    <content type="text"><![CDATA[好了，开始今天的日记吧。 今天周三，昨天新买的鞋到了。晚上下班后，顺路去6号楼的超市取上快递，还是很高兴的，这就是我的又一个兴奋点。哈哈。 回来试穿了一下，还是不错的。大小合适。只是颜色的话，它说的是灰色，其实实际上的颜色要差一些。有点像军绿色。因为之前，应该是初中的时候，过年的时候买过一件外套，也是头一回认识军绿色这个颜色。总体来说还是可以的。今天穿了一天，也踩开了一点，还是挺好看的，是我喜欢的类型。 ​ 刚刚和高兴大大聊天，他这两天正和新晋的嫂夫人在云南玩，还是不错的。看的出来很幸福。 边和高兴这边聊，也在和姐姐这边聊。一开始问我姐，面包能不能放进冰箱里面，因为我今天下班，买了一袋面包，打算明天早饭吃。聊到后面，外甥小任粉墨登场，现在还在和我聊。 晚上和家人聊天还是很亲切的，感觉棒极了。 好吧，我在一边写日记一边和他聊，没有什么心思仔细的写日记了。。。 想想今天也没有什么值得写一下的事情了，大都是平淡无奇且又没有引起我想法的。今天的日记就当是例行公事吧，草草了事啊，哈哈。 对了，最后抱怨一个，和我的鞋子同时买的外套，今天还没到，我实在是无力抱怨。。。看物流消息，应该明天就到了，希望不要出什么差错的好。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-08-28 周一]]></title>
    <url>%2F2017%2F08%2F28%2F%E6%97%A5%E8%AE%B0%20-%202017-08-28%20%E5%91%A8%E4%B8%80%2F</url>
    <content type="text"><![CDATA[今天是礼拜一，又是一个星期的开始，说说今天吧。 早上醒的很早，差不多7点就自然醒了。看了看表，就继续躺着，但是也没有睡着。躺倒大概7点四十，就起来了。 起床照例还是到厨房，作点开水来喝，这个习惯已经持续了有大概三个礼拜左右了。还是很好的。一大早起来很一杯热开水，比喝一杯凉水好多了。肚子也很舒服。 然后一边等水开，一边在厨房刷牙。因为我作的不多，所以不用很长时间水就会开，然后将水倒进杯子里，我继续洗脸。等到洗完脸，在上个厕所，杯子里的水也就差不多凉下来了。然后在出发前喝一杯热水，不只是肚子暖和，心里也很舒服。 然后就是奔向地铁的路了。小区离着六号线不是很远，大概走7~10分钟就能走到。最费时间的是进站前的排队，人多的时候，可能会排5分钟左右才能进站。进去之后又是过安检的队伍，所以，在上班高峰期坐地铁，最费时间的不是等地铁，而是进地铁站。 今天早上地铁站的人还是往常一样的多。我看到B口的队都排到马路上来了，而且队伍的前面还一直没动，于是决定换一个地铁站进。 在离B口大概不到300米的距离是另一个地铁口，哪个口我具体叫不上来了，好像是A口吧。之前也没有进过，今天是头一回。你别说，人还是真少，都不用排队的，只是进去之后的安检需要排队，但是还是很快了。所以，以后如果B口排了很多人的话，就去那个口。 来到朝阳门，下地铁，出地铁口，往公司走。照例是8点40。这回我还是从E口往外走。人真的很少，完全不用排队。 我的早饭一般都是路上的大妈做的。可是，从上个礼拜开始，连续好几天了，都没有出来，应该是城管最近管的比较严吧。可是我已经很饿了，看了看表，八点四十五，时间还早，就去了人寿楼里面的早餐店。人寿大厦离我们上班的地点不是很远，唯一的不好的地方就是那家的早饭比较起路上的早点，还是会要贵一点的。我买了一杯豆浆，两个肉包子，带走，总共是9快。但是有支付宝的奖励金，好像是8块左右。吃路上的早饭，我一般花4块5买一杯粥，再加一个鸡蛋。早饭不用吃很多，主要是需要给嘴巴里面换换味道，也补充一点能量。 买到早餐之后就马不停蹄的往丰联走，到了办公室也就是八点55左右，很准时的。签到之后，将自己的电脑、键盘、鼠标、电源线统统拿出来。开始一天的工作。 关于工作的事情，我就不想在日记里面提了，写日记还是想让自己放松一下，就不想提工作的事情了，主要记录我一天中，除了工作之外的其他事情。 中午，还是去了老地方吃的盖饭。美食广场。我们已经连续在那儿吃了两三个礼拜了。我在那边只吃一家，那家的饭还是很好吃的，主要还实惠。13块一荤一素。15两荤。应该也就是2块一份素菜，三块一份荤菜。最多两个菜就足够我吃了，所以，我最多花15就能吃到一顿很好吃的饭了。 好久没吃面了，我上个礼拜连续吃了四天的大米，只吃了一顿面，晚上也吃过面。 下午依旧是工作，就不谈了。 到了六点，下班的时候了。我大概到了六点一刻才下班。到了地铁口，满满的人啊，于是一步一步挪进了地铁站里面。 等到回来，出地铁站的时候，天已经黑了。这还是我第一次天黑了才下班回家。 晚上去了运城美食，买了一份蛋炒饭带了回来。然后熬了点稀饭，等吃完米饭，稀饭正好ok了，再喝一碗粥，别提有多美了。 今天的晚饭就是一顿教科书般的晚饭。哈哈，我很享受！ 再说说最近的天气，入秋了，天气渐渐转凉，早上出发的时候，还是有一点冷的。瞬间就感觉今年的夏天过的好快啊。转眼就到了秋天了。 昨天周日，北京下了一天的雨。我于是想起了M一直催我买衣服。想想这天气也真的是一天天凉了起来，就开始在淘宝上找了起来。最后在昨天下午五点多的时候，成功下单一件78的外套，和一双119的鞋子。静等收货。 今天回来，正好7点半左右，就打开中央一台看天气预报。让人想笑的是，在看具体的城市天气预报时，虽然第一个城市就是北京，但是我还是习惯性的忽视它，而是等着昆明过后的太原，哈哈。等到太原过了之后，我才反应过来，北京什么天气啊？实在是让我想笑。 太原明天小雨转大雨，好像上个周末就一直在下雨，看来得下几天了。 北京的天气还好，除了昨天下了一天之外，今天的天气还是很好的。除了早上一出门有一点微微的凉，其他时候还是很舒服的。不冷不热，刚刚好。 应该时从上周开始吧，每天晚上需要盖好夏被了。要不就会被冻醒。昨天晚上也关了窗户才睡的。天气真的是开始变冷了。 我的这个夏天，好像也快要过去了。 在我的记忆中，有两个夏天让我记忆尤深：一个是初三毕业之后；另一个就是高三毕业之后。那两个夏天都发生了改变我命运的事情，所以我可能一辈子都忘不了。 今年的这个夏天，也是我的又一个新的起点，它依然让我印象深刻。 在多年后，再想起2017年的这个夏天，我和另外两个同学，从太原坐高铁到北京。然后拖着很重的行李箱，满小区的找房子。然后再在人山人海的地铁中玩手机。人一辈子还要什么，这就是生活。 好了，也不早了，今天的日记就先到这儿吧。 我在用AUSU的那台旧笔记本来写的这篇日记，让我没想到的是，我对他的键盘还是那样的熟悉，虽然很旧，但是打起字来还是那样的让我舒服，甚至都快超过了我新买的机械键盘，这是让我意想不到的。我特别欣慰。 所以，我又想起来一句，那就是：不要轻易忘记自己的老物件，它会给你带来很熟悉，很温暖、很安心的感觉。 我喜欢这个旧键盘！我喜欢这个旧电脑！ 因为，这是我的回忆。。。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日记 - 2017-08-27 周日]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%97%A5%E8%AE%B0%20-%202017-08-27%20%E5%91%A8%E6%97%A5%2F</url>
    <content type="text"><![CDATA[刚刚在洗漱，突然想起来自己的公众号好久都没有打理了。申请之后就没有再理会过了。所以计上心来，想要每天，也不能说每天。因为我都不知道自己能不能有时间和精力来写一些东西。 在大三和大四的某些时间段里面，我一个礼拜至少会写5~6篇日记，还是纯手写，那时的日记本还在家里的抽屉里面放着。后来不知道因为什么，就又断了。我就是这样，我应该从初中那时候就开始自觉的记日记，但是都没有坚持下来。总是突发奇想，捡起来之前的日记，可是时间不长，就又会放下一段时间。直到下一次再想起来。 今天也是一样，心里有一些想法会突兀的出现，于是就想把他们都写下来。可是也不是每天都会有这些想法，毕竟咱也不是专业些小说的。权当是对自己心路历程的记录吧。 好了，BB了半天，就开始今天的日记吧。 刚刚洗漱的时候，突然想到一个问题，可能有一些“作”啊。但是的确是自己真真实实的宪法，但就是，人活着，究竟是为了什么啊。 应该在高中的时候，我就发现了一个东西。我就姑且叫做它为“兴奋点”吧。我举几个例子，你们就应该会了解这个我说的这个词的意思。 比如说，现在是周五的中午十二点半，你刚吃过了午饭，准备简单休息一下，然后开始下午的工作或者学习。这时你突然想到，明天就是周末了，你就会兴奋一下，我所讲的 “兴奋点”就是这个。 你们觉得生活中，这样的兴奋点多吗？我认为不是很多，因为什么呢。我甚至都记得我初中甚至更早的兴奋点，但是到现在，那些却已经不再是了。 比如，初中的时候喜欢在周六晚上看《快乐大本营》，那会儿家里还没有电脑手机，我全部的娱乐资源都来自于电视。所以在周六晚上，都会守在电视前面看《快乐大本营》。记得有一回，在周六下午想到今天晚上就可以看到《快乐大本营》了，就会很兴奋，很开心。我现在都能记起那时候的心情。 再比如，等我大了一点了，到高中的时候是住校，每周就会特别期待周末。想到周末快到了，成为了我的新的兴奋点。期待周末这个想法也是我到了高中的时候才开始有的。初中甚至是小学，这个想法都不是很强烈。直到高中，直到现在。可能以后的很多时间，这个兴奋点都会陪伴着我。 在此处，列举一些我现在能想起来的兴奋点吧，由时间的倒序排序。 下班，周末，和父母视频，和大学、高中的舍友聊天、开黑。这应该是我目前最大的兴奋点，现在我能想到这些。 上大学的时候的兴奋点：周末，和舍友开黑，第二天早上第一节没课，和女朋友出去玩（可能晚上不回来），和三五好友聚餐，周末回家，姐姐、姐夫、外甥来我家。 对，现在我也只能想到这些了，应该还是有其他的点的，但是我实在是想不到了。 好了，回到之前的话题，人活着，究竟是为了什么啊？我想，可能就是为了让自己有更多的兴奋点，以及让自己有能力去享受哪些兴奋点。这就是我目前能想到的关于【人活着究竟为什么？】的答案了。可能再过几年，回过头来再看，就会有新的想法了。 好了，今天的日记就先到这儿了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[App server和Web server的区别]]></title>
    <url>%2F2017%2F08%2F02%2FApp%20server%E5%92%8CWeb%20server%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[点击阅读原文(14年的文章)简单来说,web服务器提供页面给浏览器,而app服务器提供客户端可以调用的接口.web服务器处理HTTP请求,而app服务器基于多种不同的协议,处理应用程序的逻辑问题. ##Web服务器##web服务器处理HTTP协议。当收到一个HTTP请求之后，web服务器会返回一个HTTP响应，比如一个HTML页面。为了处理请求，它可能响应一个静态的HTML页面、图片、重定向，或者代理（delegate）其他动态响应。这些动态响应可以由其他程序生成，包括CGI脚本，JSPs，servlets，ASPs，服务器端的Javascript，或者其他服务器端技术。而这些服务器端程序响应，大多数时候都表现为HTML页面，供浏览器访问。 理解一个web服务器的代理模型(delegate model)相对比较简单。当web服务器接收到一个请求，它只是简单的将请求交给处理该请求的最优程序。除了为服务器程序简单的提供一个运行环境（服务器程序可以在其中运行，并且返回生成的响应）之外，web服务器不提供任何功能。服务器程序一般自己处理交换(transaction)、数据库连接、消息分发等。 虽然web服务器不提供以上的服务，但是它一般会提供诸如容错机制，负载均衡、缓存、集群等的可扩展性。而后者，一般来说不应该部署在web服务器上，而应该在app服务器上！ App服务器根据我们的定义，app服务器可以基于各种不同的协议（可能包含HTTP协议），为客户端程序提供应用逻辑的处理。不同于web服务器主要发送用来展示在浏览器上的HTML页面，app服务器为客户端程序处理应用逻辑方面问题。应用程序使用这些逻辑，就如同调用一个对象的方法（或者面向过程编程中的函数）一样简单。 这些应用程序可能包含PC机上运行的GUI进程，web服务器，甚至其他的app服务器。app服务器和客户端之间的通信并不局限于简单的显示标记，而是可以由程序逻辑，比如数据表单、方法调用，而非静态的HTML，这样，客户端程序就可以按需去用了！ 在大多数情况下，app服务器通过元件API，比如基于j2ee app服务器的EJB，来提供应用逻辑。而更多的情况下，app服务器自己管理自己的资源。这些责任（gate-keeping）包括安全、进程交互、资源池、消息分发等。同web服务器一样，app服务器也可能需要各种可扩展性和容错机制。 举例以一个提供实时价格和相关信息的在线商店为例，它极有可能提供了一个表单，用户可以选择不同的产品并查询。它会查找，并通过HTML网页展示结果。这个网站可能有多种方式来实现这个功能，下面我们将举两个相反的例子，一个不使用app服务器，而另一个使用。通过这两个例子，可以帮助你理解app服务器的功能。 场景1：web服务器，而非app服务器 在这个场景里，web服务器独自提供在线商店的功能。它接受用户的请求，交给服务器端程序处理。该服务器端程序通过数据库，或者纯文本，查找到价格信息，然后生成HTML响应，通过web服务器返回给用户的浏览器。 总结来说，web服务器仅需要接受HTTP请求，并响应HTML网页。 场景2： web服务器 + app服务器 同场景1一样，web服务器仍然代理脚本生成的响应。但是你可以把业务逻辑部署在app服务器上。这样，脚本就不需要去关注怎样查询和生成响应，而仅需要调用app服务器提供查询服务，从而利用其生成它的HTML响应。 在这个例子中，app服务器提供了价格查询的业务逻辑。这个逻辑不应该包含怎样去展示，或者强迫客户端使用这些数据。相反的是，客户端和app服务器进行交互，只有当客户端调用了app服务器的价格查询服务的时候，该服务才查找到信息并返回。 同HTML代码生成分离开后，价格查询逻辑的复用性提高了。另外一个客户端，比如收银机，同样可以调用这个接口。而场景1里，价格查询服务就很难被重用，因为它和HTML页面紧密联系。 总结来说，第二个场景中，web服务器处理HTTP请求，并返回HTML页面，而app服务器处理业务逻辑。 注意近来，XML web服务器模糊了app服务器和web服务器的界限。发送一个XML请求给web服务器，web服务器可以像过去的app服务器一样，处理数据并返回响应。 另外，很多app服务器包含web服务器，这就意味着你可以把web服务器看做app服务器的一个子集。虽然app服务器包含web服务器的功能，但是开发者还是很少以此身份发布app服务器。如果需要的话，他们通常将web服务器和app服务器分离开。这样的目的是，性能（简单的web请求不会影响到app服务器的性能）、发布配置（专用的web服务器，集群等）、更好的厂商选择. 点击阅读原文]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat和Nginx的区别]]></title>
    <url>%2F2017%2F08%2F02%2FTomcat%E5%92%8CNginx%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[nginx在负载均衡里是前端服务器，用来处理请求的转发（反向代理等）；是静态页面服务器.绝大部分时候他们本身并不会运行项目。 Tomcat是后端服务器，属于Java Servlet容器.用来生成动态页面.是直接用来运行项目的容器。简单来说就是你发出一个请求,先经过nginx，它们会合理地把请求分配到后台比较不忙的Tomcat。Tomcat会把请求处理好返回给Nginx,然后Nginx会把最终的结果传送给浏览器.当然,如果是一些静态的数据,Nginx就可以直接处理了。 Tomcat/Jetty 等等这一类叫Web Container,也就是Web容器，所谓容器，是和他负责的东西管理整个的生命周期的。所以Web Container会管理整个Servlet的生命周期。类似的Spring的Ioc容器则会管理整个Bean的生命周期。而GlassFish/Weblogic这一类的 application Server，则会管理更多，包含命名服务器，EJB等资源。 Nginx/apache 可以说是web server，也就是他们可以处理静态资源，比如html、图片等，但如果把Servlet交给它则处理不了。所以，一般把Nginx放在前端处理静态资源，如果有对应的Servlet请求，则通过AJP转给后面的Tomcat、Jetty进行处理。 tomcat用在java后台程序上，java后台程序难道不能用apache和nginx吗？”不能。apache和nginx不是servlet容器。什么是servlet容器呢？即实现HttpServletRequest、HttpServletResponse、HttpSession等等接口，解析http请求，通过类加载器加载对应的servlet实现类并调用。也就是说servlet容器必须由java或者基于jvm的语言实现。]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级元素和行内元素的区别]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[块级：display:block行内：display:inline可以通过修改display属性来切换块级元素和行内元素 块级元素 block element每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如&lt;form&gt;只能包含块级元素。其他的块级元素则可以包含 行级元素如&lt;P&gt;.也有一些则既可以包含块级，也可以包含行级元素。&lt;div&gt;是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 行内元素：inline element也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 &lt;a&gt;。比如 &lt;span&gt;元素，iframe元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 块元素的特点 总是在新的一行开始 高度/行高/内外边距都可以设置 宽度默认是他容器的100% 可以容纳块元素和行内元素 行内元素的特点 和其他元素在一行上 宽/高/内外边距不可设置，默认就是文字或者图片的高度和宽度 只能容纳行内元素和文本 设置行内元素时，需要注意： 设置宽度width 无效。 设置高度height 无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 常见的块级元素address – 地址blockquote – 块引用center – 举中对齐块dir – 目录列表div – 常用块级容易，也是CSS layout的主要标签dl – 定义列表fieldset – form控制组form – 交互表单h1 – 大标题h2 – 副标题h3 – 3级标题h4 – 4级标题h5 – 5级标题h6 – 6级标题hr – 水平分隔线isindex – input promptmenu – 菜单列表noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容noscript – 可选脚本内容（对于不支持script的浏览器显示此内容）ol – 有序表单p – 段落pre – 格式化文本table – 表格ul – 无序列表 常见行内元素a – 锚点abbr – 缩写acronym – 首字b – 粗体(不推荐)bdo – bidi overridebig – 大字体br – 换行cite – 引用code – 计算机代码(在引用源码的时候需要)dfn – 定义字段em – 强调font – 字体设定(不推荐)i – 斜体img – 图片input – 输入框kbd – 定义键盘文本label – 表格标签q – 短引用s – 中划线(不推荐)samp – 定义范例计算机代码select – 项目选择small – 小字体文本span – 常用内联容器，定义文本内区块strike – 中划线strong – 粗体强调sub – 下标sup – 上标textarea – 多行文本输入框tt – 电传文本u – 下划线 参考文献（侵删）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于2017上半年的总结及对下半年的计划]]></title>
    <url>%2F2017%2F07%2F02%2F%E5%85%B3%E4%BA%8E2017%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%8A%E5%AF%B9%E4%B8%8B%E5%8D%8A%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[​ 从今年一月份底到六月份初，我可以说是兢兢业业，为了想得到一份心仪的IT工作勤勤恳恳。功夫不负有心人吧，在6月初，我得到了一份Java开发的工作，工作地点是北京。 ​ 记得在今年过年的时候，我自己给自己定了一个小的目标：就是在今年夏天的早些时候，可以得到一份稳定的工作。然后在下半年把这份工作经营好。不说能挣多少，至少自己可以养活自己，实现经济上的自由吧。 ​ 今天是7月2号，上半年也就算是过去了。也看到很多我关注的行业大佬写了一些自己上半年的感悟，以及对自己下半年的希望。在此我也想对自己的上半年进行一个简单的总结： ​ 自己的这上半年学到了很多东西，无论是专业知识上的，还是自己在做人做事方面的。尤其是自己的专业知识吧，有了质的飞跃。要不也不会如此顺利的找到自己心仪的工作。总结一下就是自己对于一直想从事的IT行业有了很多的了解。包括一些专业上的技能，以及日常的生活状态。自己关注了很多行业的大佬的微信公众号，他们会每天发一些包括：技能、经验、感想等方面的文章，对自己的帮助很大。也很羡慕他们。也是因为他们，我才真正地想去北京发展。 ​ 自己上半年的状态有点像高考的自己，我很庆幸，还能把自己激活。像一个黑洞一样，时时刻刻在吸收新的知识。我给这半年的我打95分。 ​ 再说说这个下半年吧，自己即将真正的步入社会，开始自己养活自己的日子了。目前我能想到两个可以算是问题的问题吧：1.进入真正的职场，是否能很快的适应2.第一次出外地生活及工作，是否能很快的适应。 ​ 可以预见，一旦踏入这个行业，保持对技术的实时更新是至关重要的。活到老，学到老需要真正的用到了。 ​ 希望自己的下半年可以保持像上半年一样对技术的热爱，无时无刻要进步，保持总结，保持运动。 ​ stay hungry,stay foolish.]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>年中总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS刷新页面方法]]></title>
    <url>%2F2017%2F06%2F10%2FJS%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. reload 方法该方法强迫浏览器刷新当前页面。 语法：location.reload([bForceGet]) 参数：bForceGet可选参数， 默认为 false，从客户端缓存里取当前页。true, 则以 GET 方式，从服务端取最新的页面, 相当于客户端点击 F5(“刷新”) 2. replace 方法该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。 语法： location.replace(URL)通常使用： location.reload()或者是 history.go(0) 来做。此方法类似客户端点F5刷新页面，所以页面method=&quot;post&quot;时，会出现”网页过期”的提示。因为Session的安全保护机制。当调用 location.reload()方法时， aspx页面此时在服务端内存里已经存在， 因此必定是 IsPostback 的。如果有这种应用： 需要重新加载该页面，也就是说期望页面能够在服务端重新被创建，期望是 Not IsPostback 的。这里，location.replace() 就可以完成此任务。被replace的页面每次都在服务端重新生成。代码：location.replace(location.href) 3. 返回并刷新 语法：location.replace(url) 参数url指的是前一个页面的URL 不要用 history.go(-1)，或 history.back();来返回并刷新页面，这两种方法不会刷新页面。 4. 页面自动每隔20秒刷新一次页面&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt; 5. 页面在20秒后跳转到指定网址&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=someUrl&quot;&gt; 6. 列举几种页面刷新常用的几种方法12345678history.go(0) location.reload() location=location location.assign(location) document.execCommand('Refresh') window.navigate(location) location.replace(location) document.URL=location.href]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java中反射的认识]]></title>
    <url>%2F2017%2F05%2F29%2F%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先讲一下,以下的内容,源自下面的连接,关于反射,讲得很清楚,我也只是根据链接中的内容,加一点自己的理解.写一下。java反射 引出反射先给一个Hello类: 12345678910111213package com.mi.beans;public class Hello &#123; private String name; public Hello() &#123; // TODO Auto-generated constructor stub &#125; public void sayHello() &#123; System.out.println("hello"); &#125;&#125; 下面是要求: 实例化Hello类，但是不能使用Hello hello = new Hello()来实例化。 调用Hello类中的sayHello()方法，但是不能直接使用Hello的实例来调用。 在这里,就用到了反射了，下面是代码: 1234567891011121314151617package com.mi.test;import java.lang.reflect.Method;public class ReflectTest &#123; public static void main(String[] args) &#123; try &#123; Class claz = Class.forName("com.mi.beans.Hello"); Object obj = claz.newInstance(); Method method = claz.getDeclaredMethod("sayHello"); method.invoke(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 说一下代码里涉及到的几个方法和类: 1. Class类 Class类也是java中的一个类,隶属于lang包下。只是和关键字class长相相似。而java是大小写敏感的。 Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象 Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。所以不能像普通类一样，通过New来创建对象。 2. forName() 参数：className - 所需类的完全限定名。 返回值：具有指定名的类的 Class 对象。 3. newInstance() 返回值:此对象所表示的类的一个新分配的实例。Object类型 也就是创建一个对象。 4.getDeclaredMethod() 参数：name - 方法名parameterTypes - 参数数组 返回值：该类与指定名和参数相匹配的方法的 Method 对象，需要Method对象来接收。 也就是拿到该对象的某个方法，方法的参数用来找到这个方法，包括方法名，和方法参数。找到唯一的一个方法。 5. Method类存放方法的类，方法也是对象。所以需要对方法进行操作。 6. invoke(); 参数：obj - 从中调用底层方法的对象args - 用于方法调用的参数 返回值：使用参数 args 在 obj 上指派该对象所表示方法的结果 也就是执行某个方法，注意是Method对象调用该方法.该方法的参数中有被执行方法的方法名以及参数列表。用以执行某一个具体的方法。 实例上面是使用反射所需要到的最基本的东西，下面举一个应用中的实例：【spring】中的反射。前两天在学spring框架，只是会一点使用而已，对一些原理性的东西还不是很懂.借此机会,也深入的了解一下底层的东西。下面是具体的代码： 1. 创建一个Bean： 12345678910public class Hello&#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println("My Message : "+ message); &#125;&#125; 2. 配置信息下面是在spring的配置文件中,通过set注入的方式对Hello类中的字段进行赋值.前提是你的实体类中的字段有get/set方法. 123&lt;bean id="hello"class="com.mi.beans.Hello"&gt; &lt;propertyname="message"value="Hello World!"/&gt;&lt;/bean&gt; 3.调用 123ApplicationContext context =newClassPathXmlApplicationContext("Beans.xml");Hello hello = (Hello) context.getBean("hello");hello.getMessage(); 上面的代码,可以想到它的底层应该是这样实现的:1.通过参数中的Beans.xml文件,解析xml文件中的信息.2.根据xml文件中的信息,包括类名/字段/,通过反射创建对象.3.再通过反射,调用set方法或者get方法,这样你就能拿到最后的结果了.newClassPathXmlApplicationContext()源代码 总结反射最大的作用就是：以申明式的方式(xml或注解)来描述应用的行为。也就是不用把一切的东西写死，而是可以变化地来操作，极大的增强了编程时的灵活性。 简单的来讲， 反射能让你在运行时而不是编程时做下面的事情：(1) 获取一个类的内部结构信息（或者称为元数据）， 包括包名，类名， 类所有的方法。(2) 运行时对一个Java对象进行操作， 包括创建这个类的实例， 设置一个属性的值， 调用这个类的方法等等。 （对了，我们经常使用MyEclipse也是使用了反射，才可以给出我们相对应的提示信息的，反射无处不在啊！）]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Spring中的[控制反转]和[依赖注入]的深入理解]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84%5B%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%5D%E5%92%8C%5B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%5D%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[第一段说明 对于一个Bean 来说，如果你依赖别的Bean , 只需要声明即可， spring 容器负责把依赖的bean 给“注入进去“， 起初大家称之为控制反转(IoC) 后来 Martin flower 给这种方式起来个更好的名字，叫“依赖注入”。 如果一个Bean 需要一些像事务，日志，安全这样的通用的服务， 也是只需要声明即可， spring 容器在运行时能够动态的“织入”这些服务， 这叫AOP。 第二段说明 控制反转（IoC=Inversion of Control）IoC，用白话来讲，就是由容器控制程序之间的（依赖）关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：（依赖）控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。 所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。 正在业界为IoC争吵不休时，大师级人物Martin Fowler也站出来发话，以一篇经典文章《Inversion of Control Containers and the Dependency Injection pattern》为IoC正名，至此，IoC又获得了一个新的名字：“依赖注入（Dependency Injection）”。 从上面的两段说明文字可以看出:其实所谓的Ioc和DI,是说的同一件事，强调的内容不同而已。 IoC控制反转，强调容器的作用，用于组织或控制容器内bean的运行。 DI依赖注入，强调Bean需要外部注入才能正常运转。相对地说做容器框架的（比如Spring)当然强调控制了，怎么更好的控制别的Bean的运行，相反做模块的，当然强调注入了，我到底需要依赖注入什么。 写给自己：自己刚刚接触Spring，对于上面的两个概念还不是很清晰，以作总结。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hibernate,一对多和多对一的实现(双向)]]></title>
    <url>%2F2017%2F05%2F17%2F%E4%BD%BF%E7%94%A8Hibernate%2C%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%9A%84%E5%AE%9E%E7%8E%B0(%E5%8F%8C%E5%90%91)%2F</url>
    <content type="text"><![CDATA[在这里，我们分别通过配置文件的方式和写注释的方式来创建表。例子：现在有一个顾客表和一个订单表，一个顾客可以拥有多个订单，而每个订单只能从属于一个客户，这就是一对多的意思。 123//顾客的字段private int cid;private String cname; 123//订单的字段private int oid;private String oname; 在这里我们需要解释一下了，一般的多对一或者一对多，可以放在一起理解,在创建表的时候，需要将外键设置到[多]的这一方，而不是放到[一]的这一方。即将外键放在此处的订单表中，而不是放到顾客表中，我们找的是从属关系，而不是拥有关系。因为我们要建的是双向的表，即可以通过任意一方找到另一方的数据。所以我们要来一点准备工作。 12345//1.在顾客实体类中加入订单的set字段,当然get和set方法要转备好private Set&lt;Order&gt; orders;//2.在订单实体类中加入顾客的字段private Costum costum; 现在我们创建表：1.使用配置文件的方式使用Hibernate之前的准备工作就不在这里赘述了,直接说代码：hibernate.cfg.xml的代码： 123456789101112131415161718192021222324252627&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定方言，指定要使用的是哪一个数据库 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 创建数据库连接 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hib ernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 自动创建数据库 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;!-- &lt;property name="format_sql"&gt;true&lt;/property&gt; --&gt; &lt;!-- 配置映射信息 --&gt; &lt;mapping resource="com/mi/beans/Costum.hbm.xml"/&gt; &lt;mapping resource="com/mi/beans/Order.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Costum.hbm.xml的代码:(顾客实体类的配置文件) 1234567891011121314151617181920212223&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.mi.beans"&gt; &lt;class name="Costum" table="t_costum"&gt; &lt;id name="cid"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="cname"&gt;&lt;/property&gt; &lt;!-- 因为在顾客的实体类中将order放入了set中,所以标签为set,还有list等 --&gt; &lt;set name="orders" &gt; &lt;!-- //此处极容易错 --&gt; &lt;key column="cid"&gt;&lt;/key&gt; &lt;!--对于顾客来说,是一对多的关系--&gt; &lt;one-to-many class="Order" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Order.hbm.xml中的代码: 1234567891011121314151617&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.mi.beans"&gt; &lt;class name="Order" table="t_order"&gt; &lt;id name="oid"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="oname"&gt;&lt;/property&gt; &lt;!-- 对于order来说,是多对一的关系,即多个订单对应一个顾客 --&gt; &lt;many-to-one name="costum" column="cid"&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 这是结果 2.使用注解的方式:当然需要导入注解包才能进行.hibernate.cfg.xml的代码:和用配置文件的方法有一点不同: 12345678910111213141516171819202122232425262728&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定方言，指定要使用的是哪一个数据库 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 创建数据库连接 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 自动创建数据库 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;!-- &lt;property name="format_sql"&gt;true&lt;/property&gt; --&gt; &lt;!-- 配置映射信息 上面注释掉的是使用配置文件的映射信息,下面的是使用注解的映射信息--&gt; &lt;!-- &lt;mapping resource="com/mi/beans/Costum.hbm.xml"/&gt; &lt;mapping resource="com/mi/beans/Order.hbm.xml"/&gt; --&gt; &lt;mapping class="com.mi.beans.Costum"/&gt; &lt;mapping class="com.mi.beans.Order"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Order实体类:有几点要注意:1.所有注释用到的包都是javax下的,不要导错包.2.主键和主键的生成策略要写到get方法之前,且必须有!!3.生成表需要有!即@Entity@Table.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.mi.beans;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.ManyToOne;import javax.persistence.Table;@Entity //形成一个以"t_order"为名的表,表中的字段和该实体类中的字段相同(每张表必须要有,否则无法建立)@Table(name="t_order")public class Order &#123; private int oid; private String oname; private Costum costum; //订单中的顾客字段,要形成外键,"JoinColumn"表示在表中新增一个字段,表示该实体类中的字段,也是建立关系的字段 @ManyToOne @JoinColumn(name="cid") public Costum getCostum() &#123; return costum; &#125; public void setCostum(Costum costum) &#123; this.costum = costum; &#125; //这是这个表的主键以及主键的生成策略(每张表必须要有,否则无法建立,注意实在get方法之前) @Id @GeneratedValue public int getOid() &#123; return oid; &#125; public void setOid(int oid) &#123; this.oid = oid; &#125; public String getOname() &#123; return oname; &#125; public void setOname(String oname) &#123; this.oname = oname; &#125; @Override public String toString() &#123; return "Order [oid=" + oid + ", oname=" + oname + "]"; &#125; public Order(int oid, String oname) &#123; super(); this.oid = oid; this.oname = oname; &#125; public Order() &#123; super(); // TODO Auto-generated constructor stub &#125; &#125; Costum实体类:该实体类和上面的差不多,只是在关系字段(order)有一点不同12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mi.beans;import java.util.List;import java.util.Set;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.OneToMany;import javax.persistence.Table;@Entity@Table(name="t_costum")public class Costum &#123; private int cid; private String cname; private Set&lt;Order&gt; orders; //被映射为costum @OneToMany(mappedBy="costum") public Set&lt;Order&gt; getOrders() &#123; return orders; &#125; public void setOrders(Set&lt;Order&gt; orders) &#123; this.orders = orders; &#125; @Id @GeneratedValue public int getCid() &#123; return cid; &#125; public void setCid(int cid) &#123; this.cid = cid; &#125; public String getCname() &#123; return cname; &#125; public void setCname(String cname) &#123; this.cname = cname; &#125; public Costum(int cid, String cname) &#123; super(); this.cid = cid; this.cname = cname; &#125; public Costum() &#123; super(); // TODO Auto-generated constructor stub &#125; @Override public String toString() &#123; return "Costum [cid=" + cid + ", cname=" + cname + "]"; &#125; &#125; 会形成和上一个方式相同的结果, 总结:xml方式 hibernate.cfg.xml中的映射信息为下面的： 12&lt;mapping resource="com/mi/beans/Costum.hbm.xml"/&gt;&lt;mappingresource="com/mi/beans/Order.hbm.xml"/&gt; 一对多的信息需要写在set标签下(或其他) 12345//Costum:&lt;set name="orders" &gt; &lt;key column="cid"&gt;&lt;/key&gt; &lt;one-to-many class="Order" /&gt;&lt;/set&gt; 12//Order:&lt;many-to-one name="costum" column="cid"&gt;&lt;/many-to-one&gt; 注解方式 hibernate.cfg.xml中的映射信息为下面的: 12&lt;mapping class="com.mi.beans.Costum"/&gt;&lt;mapping class="com.mi.beans.Order"/&gt; 123//Order:@ManyToOne@JoinColumn(name="cid") 12//Costum:@OneToMany(mappedBy="costum") 上述简单的讲述，如果有大神看到有问题的地方，不吝赐教！！！]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate数据库框架的入门]]></title>
    <url>%2F2017%2F05%2F16%2FHibernate%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A1%86%E6%9E%B6%E7%9A%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 搭建框架的步骤:(使用xml方式) 导入许多包,以下:包括框架包/注释包/Mysql包/日志包/测试包,当然测试包和日志包可选. 创建一个实体类在beans包下加入一个xml文件 如下: 在src下加入一个另一个xml文件,这个文件是使用Hibernate的关键,千万不能出错。 具体代码：实体类中的字段 1234private int uid;private String name;private String password;private int age; User.hbm.xml中的代码,也就是在beans包中的那个xml文件的.相应的代码有注释解释. 1234567891011121314151617181920&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.mi.beans"&gt; &lt;!-- 写上类名以及对应到数据库中的表明 --&gt; &lt;class name="User" table="t_user"&gt; &lt;!-- 这是设置主键 --&gt; &lt;id name="uid"&gt; &lt;!-- 设置主键生成策略,这里一般都用native方法 --&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 将实体类中的其他字段都映射到数据库中 --&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="password" &gt;&lt;/property&gt; &lt;property name="age" &gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate.cfg.xml中的代码主要是配置hibernate的基本设置,包括方言/数据库名称之类的. 123456789101112131415161718192021222324252627&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定方言，指定要使用的是哪一个数据库 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 创建数据库连接 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 在这里的hibernate是要新建的数据库名 "///"可以用localhost代替--&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate&lt;/property&gt; &lt;!-- 这里是你的数据库的用户名和密码 --&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 自动创建数据库 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 配置映射信息 即找到beans包下面的实体类相对应的配置文件--&gt; &lt;mapping resource="com/mi/beans/User.hbm.xml"/&gt; &lt;!--使用注解--&gt; &lt;!-- &lt;mapping class="com.mi.beans.User_girlf"/&gt; --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试类中的代码 123456789101112131415161718public static void main(String[] args) &#123; //1.读取hibernate.cfg.xml Configuration con = new Configuration().configure(); //2.创建sessionFactory SessionFactory sf = con.buildSessionFactory(); //3.创建session Session session = sf.openSession(); //开启事务 session.beginTransaction(); User user = new User("ls", "123", 23); session.save(user); //提交 session.getTransaction().commit(); //关闭 session.close(); sf.close(); &#125;&#125; 最后数据库中就能看到新建的表以及刚刚User创建的对象中的数据。 写在最后大概的步骤就是这个了，如果有不对的地方，欢迎大神指点。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2F05%2F03%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[选择器 示例 示例说明 css .class .intro 选择所有class=”intro”的元素 1 #id #firstname 选择所有id=”firstname”的元素 1 * * 选择所有元素 2 element p 选择所有元素 1 element,element div,p 选择所有元素和元素 1 element element div p 选择元素内的所有元素 1 element&gt;element div&gt;p 选择所有父级是 元素的 元素 2 element+element div+p 选择所有紧接着元素之后的元素 2 [attribute] [target] 选择所有带有target属性元素 2 [attribute=value] [target=-blank] 选择所有使用target=”-blank”的元素 2 [attribute~=value] [title~=flower] 选择标题属性包含单词”flower”的所有元素 2 :link a:link 选择所有未访问链接 1 :visited a:visited 选择所有访问过的链接 1 :active a:active 选择活动链接 1 :hover a:hover 选择鼠标在链接上面时 1 :focus input:focus 选择具有焦点的输入元素 2 :first-letter p:first-letter 选择每一个元素的第一个字母 1 :first-line p:first-line 选择每一个元素的第一行 1 :first-child p:first-child 指定只有当元素是其父级的第一个子级的样式。 2 :before p:before 在每个元素之前插入内容 2 :after p:after 在每个元素之后插入内容 2 :lang(language) p:lang(it) 选择一个lang属性的起始值=”it”的所有元素 2 element1~element2 p~ul 选择p元素之后的每一个ul元素 3 [attribute^=value] a[src^=”https”] 选择每一个src属性的值以”https”开头的元素 3 [attribute$=value] a[src$=”.pdf”] 选择每一个src属性的值以”.pdf”结尾的元素 3 [attribute*=value] a[src*=”runoob”] 选择每一个src属性的值包含子字符串”runoob”的元素 3 :first-of-type p:first-of-type 选择每个p元素是其父级的第一个p元素 3 :last-of-type p:last-of-type 选择每个p元素是其父级的最后一个p元素 3 :only-of-type p:only-of-type 选择每个p元素是其父级的唯一p元素 3 :only-child p:only-child 选择每个p元素是其父级的唯一子元素 3 :nth-child(n) p:nth-child(2) 选择每个p元素是其父级的第二个子元素 3 :nth-last-child(n) p:nth-last-child(2) 选择每个p元素的是其父级的第二个子元素，从最后一个子项计数 3 :nth-of-type(n) p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素 3 :nth-last-of-type(n) p:nth-last-of-type(2) 选择每个p元素的是其父级的第二个p元素，从最后一个子项计数 3 :last-child p:last-child 选择每个p元素是其父级的最后一个子级。 3 :root :root 选择文档的根元素 3 :empty p:empty 选择每个没有任何子级的p元素（包括文本节点） 3 :target #news:target 选择当前活动的#news元素（包含该锚名称的点击的URL） 3 :enabled input:enabled 选择每一个已启用的输入元素 3 :disabled input:disabled 选择每一个禁用的输入元素 3 :checked input:checked 选择每个选中的输入元素 3 :not(selector) :not(p) 选择每个并非p元素的元素 3 ::selection ::selection 匹配元素中被用户选中或处于高亮状态的部分 3 :out-of-range :out-of-range 匹配值在指定区间之外的input元素 3 :in-range :in-range 匹配值在指定区间之内的input元素 3 :read-write :read-write 用于匹配可读及可写的元素 3 :read-only :read-only 用于匹配设置 “readonly”（只读） 属性的元素 3 :optional :optional 用于匹配可选的输入元素 3 :required :required 用于匹配设置了 “required” 属性的元素 3 :valid :valid 用于匹配输入值为合法的元素 3 :invalid :invalid 用于匹配输入值为非法的元素 3]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像"机器"一样思考]]></title>
    <url>%2F2017%2F04%2F29%2F%E5%83%8F-%E6%9C%BA%E5%99%A8-%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[像”机器”一样思考刚刚看了一篇文章，有点感触，简单写写，算是梳理思路，也当作是总结。 文章的题目叫做：《像”机器”一样思考》，我在这儿简单的回顾和总结一下吧。机器的思考方式，即：输入➡️处理➡️输出。简单粗暴，效率高。输入和输出都好理解，这个中间的处理环节，就相当麻烦了。还是简单总结一下,就是： 1.分解问题2.找到子问题之间的关联3.找到问题的边界，明确假设和结果 第三点的大概意思应该就是要详细地分析每一个分解之后的问题，给出假设以及假设的结果。 这也是这篇文章给我最大感触的地方。上述的三点看起来十分简单，但是在实际实施过程中则要麻烦许多。你需要很强的逻辑思维，以及对整个项目把控能力。 （就举做项目的例子吧,在生活中的其它领域,应该都可以使用到）这个能力叫做Analytical Thinking，翻译过来也就是分析问题的能力。你需要把一个复杂的东西拆开，分解成一个个相对简单的，再找到其相对应的点，最后再合成一个整体。 ###还有一个点:面向过程和面向对象的区别及联系我之前一直没有太分得清楚,只是知道两者都是一种实现方法,相对应的解决思路不同.看过这篇文章之后,茅塞顿开,以下是我所理解的两者之间的联系与区别,(如果有大神看到不对之处,望纠正!) 我的理解:上面所说的这种Analytical Thinking其实就是一种面向过程的编程方法,如果仅仅是停留在此处,那也就没有面向对象的事情了.也就是说,如果你的项目规模很小,那用面向过程编程就完全可以实现了,但是如果你的项目很大,后期需要新增一些新的功能,或者要修改一些旧的功能,那面向过程就很方便了. 举个栗子:你要做一个五子棋的游戏. 面向过程编程:黑子走–&gt;在棋盘上绘制–&gt;判断输赢–&gt;白子走–&gt;判断输赢,然后就是重复执行上述步骤. 面向对象编程:将整个游戏划分为三个对象: 1. 棋子 2. 棋盘 3. 规则 每个对象负责相对应的部分,而各个对象给予其对应的方法: 如:棋子对象完成相应的动作后,告知棋盘对象绘制,而后告知规则对象进行相应的判断. 那这样做有什么好处么?举例:要在五子棋的基础上改为围棋游戏 基于面向过程的方式,需要改动的地方就多了吧:每一处引用到规则(也就是判断输赢这个环节)的地方都要修改,当然棋盘需要重新绘制一个比较大一点的了.这个的链路需要重写,需要改动的地方太多. 基于面向对象的方式就简单一点了,只需要把规则对象和棋盘对象改掉就好,可修改性就体现出来了,当然,之前的规则还可以继续保留,五子棋游戏还是可以继续存在的,只需要新添加围棋的规则和围棋的棋盘就好.整体的脉络都可以得以保留,只是需要有新成员的加入。 总结1.面向对象的编程方法,是面向过程编程方法的一种封装,是在其基础上发展出现的.2.像”机器”一样思考 是面向过程思想的一种体现.3.面向过程思想:输入–&gt;处理–&gt;输出4.面向对象思想:A对象–&gt;B对象–&gt;C对象,而每个对象之中又存在[输入–&gt;处理–&gt;输出],也就是面向过程的封装了. 以上是我的一些思考,如果有大神发现一些不对的地方,望指正.]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery中html()/text()/val()的区别]]></title>
    <url>%2F2017%2F03%2F10%2Fhtmltextval%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[介绍html()用为读取和修改元素的HTML标签 对应js中的innerHTML()html()是用来读取元素的HTML内容（包括其Html标签）,html()方法使用在多个元素上时，只读取第一个元素 text()用来读取或修改元素的纯文本内容 对应js中的innerText()text()用来读取元素的纯文本内容，包括其后代元素。text()方法不能使用在表单元素上 val()用来读取或修改表单元素的value值val()是用来读取表单元素的value值，val()只能使用在表单元素上 区别关于三者的区别 1. `val()`方法和`html()`相同，如果其应用在多个元素上时，只能读取第一个表单元素的`value`值，但是`text()`和他们不一样，如果`text()`应用在多个元素上时，将会读取所有选中元素的文本内容。 2. `html()`/`text()`/`val()`都可以使用回调函数的返回值来动态的改变多个元素的内容。 示例1234567891011121314151617181920212223&lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $('#btn').click(function()&#123; alert('html():'+ $('p').html()) &#125;) $('#btn2').click(function()&#123; alert('text():'+ $('p').text()) &#125;) $('#btn3').click(function()&#123; alert('val():'+ $('input').val()) &#125;) &#125;)&lt;/script&gt;&lt;div&gt; &lt;p&gt;点击之后&lt;b&gt;消失&lt;/b&gt;&lt;/p&gt; &lt;input type="text" value="测试文字"&gt; &lt;button id="btn"&gt;按钮html()&lt;/button&gt; &lt;button id="btn2"&gt;按钮text()&lt;/button&gt; &lt;button id="btn3"&gt;按钮val()&lt;/button&gt;&lt;/div&gt; 测试结果：]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
      <tags>
        <tag>区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于抽象]]></title>
    <url>%2F2017%2F01%2F03%2F%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[抽象是计算机科学中最伟大的概念之一《深入理解计算机系统》一书中说： 指令集是对CPU的抽象。文件是对输入、输出设备的抽象。虚拟存储器是对程序存储的抽象。进程是对一个正在运行的程序的抽象。虚拟机是对整个计算机的抽象(包括系统/处理器/程序)。 CPU集成电路硬件无比复杂， 但是我们写程序肯定不用接触这些硬件细节， 那样就累死了， 我们只要遵循CPU的指令集， 程序就可以正确的运行， 而不用关心指令在硬件层次到底是怎么运行的。 硬盘也是这样， 有磁道，柱面，扇区， 我们写应用层程序也不用和这些烦人的细节打交道， 在操作系统和设备驱动的配合下， 我们只需要面对一个个“文件”，打开，读取，关闭就行了。 操作系统会把逻辑的文件翻译成物理磁盘上的字节。 再比如为了实现数据的共享，数据的一致性和安全性，需要大量的，复杂的程序代码来实现， 每个应用程序都实现一份肯定不是现实的。 所以计算机科学抽象出了一个叫数据库的东西， 你只需要安装数据库软件， 使用SQL和事务就能实现多用户对数据的安全访问了。 摘自：码农需要知道的“潜规则”]]></content>
      <categories>
        <category>总结与区别</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
